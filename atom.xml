<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Jangzq技术研究]]></title>
  <subtitle><![CDATA[关注代码的秘密， 记录探索点滴， 分享技术收获]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jangzq.info//"/>
  <updated>2015-08-01T09:08:26.000Z</updated>
  <id>http://jangzq.info//</id>
  
  <author>
    <name><![CDATA[Zhang Zq]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ParNewGeneration垃圾收集]]></title>
    <link href="http://jangzq.info/2015/07/31/ParNewGeneration_collect/"/>
    <id>http://jangzq.info/2015/07/31/ParNewGeneration_collect/</id>
    <published>2015-07-31T14:20:11.000Z</published>
    <updated>2015-08-01T09:08:26.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>使用-XX:+UseParNewGC参数时，young generation为ParNewGeneration，其垃圾收集入口为：ParNewGeneration::collect。<br><a id="more"></a></p>
<ol>
<li><p>首先计算垃圾收集需要的线程数。<br>入口函数为：AdaptiveSizePolicy::calc_active_workers。</p>
<ol>
<li><p>如果设置了ParallelGCThreads参数，或者没有设置UseDynamicNumberOfGCThreads参数，则使用由ParallelGCThreads指定的所有线程,ParallelGCThreads默认值的计算方式见附录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!UseDynamicNumberOfGCThreads ||</span><br><span class="line">   (!FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; !ForceDynamicNumberOfGCThreads)) &#123;</span><br><span class="line">  new_active_workers = total_workers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForceDynamicNumberOfGCThreads为诊断参数，平时恒为false。</p>
</li>
<li><p>否则，动态计算线程数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_active_workers = calc_default_active_workers(total_workers,</span><br><span class="line">                                               <span class="number">2</span>, <span class="comment">/* Minimum number of workers */</span></span><br><span class="line">                                               active_workers,</span><br><span class="line">                                               application_workers);</span><br></pre></td></tr></table></figure>
<p>动态线程数由三个因素决定：上次的线程数、当前的用户线程数、heap大小。<br>通过当前的用户线程数，计算出一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">active_workers_by_JT =</span><br><span class="line">  MAX2((uintx) GCWorkersPerJavaThread * application_workers,</span><br><span class="line">       min_workers);</span><br></pre></td></tr></table></figure>
<p>注：GCWorkersPerJavaThread为2。</p>
<p>通过heap大小计算出一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">active_workers_by_heap_size =</span><br><span class="line">   MAX2((<span class="keyword">size_t</span>) <span class="number">2U</span>, Universe::heap()-&gt;capacity() / HeapSizePerGCThread);</span><br></pre></td></tr></table></figure>
<p>注：HeapSizePerGCThread缺省为64m，可调。</p>
<p>新的active线程数，即这两个值的较大者，但是不能超过ParallelGCThreads，并且如果新的线程数小于之前的线程数，设为两者的中间值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uintx max_active_workers =</span><br><span class="line">MAX2(active_workers_by_JT, active_workers_by_heap_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Limit the number of workers to the the number created,</span></span><br><span class="line"><span class="comment">// (workers()).</span></span><br><span class="line">new_active_workers = MIN2(max_active_workers,</span><br><span class="line">                              (uintx) total_workers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Increase GC workers instantly but decrease them more</span></span><br><span class="line"><span class="comment">// slowly.</span></span><br><span class="line"><span class="keyword">if</span> (new_active_workers &lt; prev_active_workers) &#123;</span><br><span class="line">  new_active_workers =</span><br><span class="line">    MAX2(min_workers, (prev_active_workers + new_active_workers) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>先判断进行垃圾回收是否能成功，如果不能成功就直接跳过此Generation，同DefNewGeneration。</p>
</li>
<li><p>并行遍历alive的oop。 代码入口：<code>void ParNewGenTask::work(uint worker_id)</code>， 将DefNewGeneration中的垃圾收集方式进行并行化，需要解决下面几个并行问题：<br>在并行收集中，每一个回收线程拥有自己单独的ParScanThreadState，用来管理本回收线程的local信息。</p>
<ul>
<li><p>并行的遍历root reference。<br>要处理的root reference包括：Universe中的预定义oop，jni global reference，jni local reference， local stack等等。对于全局的（即不属于某一线程）root reference，遍历的时候会设置一个标识位，如果有回收线程正在处理，就跳过去，代码示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">_process_strong_t</span>asks-&gt;<span class="keyword">is_t</span>ask_claimed(SH_PS_Universe_oops_do)) &#123;</span><br><span class="line">   Universe::oops_do(roots);</span><br><span class="line">   <span class="comment">// Consider perm-gen discovered lists to be strong.</span></span><br><span class="line">   perm_gen()-&gt;ref_processor()-&gt;weak_oops_do(roots);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对于各个用户线程的扫描，每一个线程存在一个Thread::_oops_do_parity变量，而每次收集也有一个对应的标识符SharedHeap::_strong_roots_parity，一个回收线程遍历一个线程时，如果这两个值相同，则说明这个线程已经遍历或者正在遍历，否则使用cmpxchg，原子性的将_oops_do_parity设置为当前的_strong_roots_parity，如果设置成功，就有此回收线程进行遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Thread::claim_oops_do_par_case(<span class="keyword">int</span> strong_roots_parity) &#123;</span><br><span class="line">  jint thread_parity = _oops_do_parity;</span><br><span class="line">  <span class="keyword">if</span> (thread_parity != strong_roots_parity) &#123;</span><br><span class="line">    jint res = Atomic::cmpxchg(strong_roots_parity, &amp;_oops_do_parity, thread_parity);</span><br><span class="line">    <span class="keyword">if</span> (res == thread_parity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      guarantee(res == strong_roots_parity, <span class="string">"Or else what?"</span>);</span><br><span class="line">      assert(SharedHeap::heap()-&gt;workers()-&gt;active_workers() &gt; <span class="number">0</span>,</span><br><span class="line">         <span class="string">"Should only fail when parallel."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(SharedHeap::heap()-&gt;workers()-&gt;active_workers() &gt; <span class="number">0</span>,</span><br><span class="line">         <span class="string">"Should only fail when parallel."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并行的将对象拷贝到to或者promote到下一generation。由于同一个对象有可能通过不同的路径引用，所以很有可能两个回收线程同时拷贝一个对象。在ParNewGeneration中使用ParScanClosure::do_oop_work来处理遍历到的对象。</p>
<ol>
<li>如果此对象已经包含了forwarding指针，说明已经被拷贝了，或者正在拷贝，则读出其真正的forwarding指针。所谓什么是“真正”，下文有详细描述。</li>
<li>如果没有包含forwarding指针，则调用ParNewGeneration::copy_to_survivor_space方法将对象拷贝到to区域，或者到下一个generation。这个方法根据下一generation是否支持promote undo，有两种实现方式。对于cms，不支持undo promote，所以使用<code>copy_to_survivor_space_avoiding_promotion_undo</code>方法，而普通的TenureGeneration则支持undo，使用<code>copy_to_survivor_space_with_undo</code>方法。简单的说，在<code>copy_to_survivor_space_avoiding_promotion_undo</code>方法中，在promote前，就用一个“假的”指针设置了forwarding指针，所以不会有两个线程同时promote，而在<code>copy_to_survivor_space_with_undo</code>中，则是发现了两个线程都copy了，可以调用下一generation的方法进行undo。这两个方法详细描述见附录。</li>
</ol>
</li>
<li><p>循环遍历处理root reference发现的对象发出的引用，处理每一个对象的方法为<code>ParEvacuateFollowersClosure::do_void</code>。<br>在处理root reference时，将待处理的对象放到了一个ParScanThreadState中的队列中，所以在这里就是处理此队列，为了防止都在一个队列的情况，回收线程处理完自己队列里的后，还可以处理别的线程队列里的对象。循环进行下列操作，直到完成。</p>
<ol>
<li><p>处理自己队列里的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">par_scan_state()-&gt;trim_queues(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理完自己的对象，从别的线程里得到处理的对象, 和全局存放的溢出的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (task_queues()-&gt;steal(par_scan_state()-&gt;thread_num(),</span><br><span class="line">                          par_scan_state()-&gt;hash_seed(),</span><br><span class="line">                          <span class="keyword">obj_t</span>o_scan)) &#123;</span><br><span class="line">   <span class="keyword">bool</span> res = work_q-&gt;push(<span class="keyword">obj_t</span>o_scan);</span><br><span class="line">   assert(res, <span class="string">"Empty queue should have room for a push."</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//   if successful, goto Start.</span></span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// try global overflow list.</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (par_gen()-&gt;take_from_overflow_list(par_scan_state())) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>处理java.lang.Reference相关对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rp-&gt;processing_is_mt()) &#123;</span><br><span class="line">    <span class="function">ParNewRefProcTaskExecutor <span class="title">task_executor</span><span class="params">(*<span class="keyword">this</span>, thread_state_set)</span></span>;</span><br><span class="line">    stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                              &amp;evacuate_followers, &amp;task_executor,</span><br><span class="line">                                              <span class="keyword">_gc_t</span>imer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    thread_state_set.flush();</span><br><span class="line">    gch-&gt;<span class="keyword">set_par_t</span>hreads(<span class="number">0</span>);  <span class="comment">// 0 ==&gt; non-parallel.</span></span><br><span class="line">    gch-&gt;save_marks();</span><br><span class="line">    stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                              &amp;evacuate_followers, NULL,</span><br><span class="line">                                              <span class="keyword">_gc_t</span>imer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行完了收集，其余诸如交换from 和 to，和DefNewGeneration没有太大的本质区别，就不再赘述了。</p>
</li>
</ol>
<h2 id="附录">附录</h2><h3 id="ParallelGCThreads缺省值计算方法">ParallelGCThreads缺省值计算方法</h3><p>入口在：Abstract_VM_Version::nof_parallel_worker_threads<br>主机的cpu如果小于8个，则使用cpu数，如果大于8个，则每增加一个cpu，不再增加一个线程，而是按一个比例增加，即使用如下公式计算。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(switch_pt + ((ncpus - switch_pt) * num) / den)</span><br></pre></td></tr></table></figure></p>
<p>其中，switch_pt：8, ncpus为cpu数， num：5, den：8。</p>
<h3 id="copy_to_survivor_space_avoiding_promotion_undo">copy_to_survivor_space_avoiding_promotion_undo</h3><p>诸如age判断之类的同DefNewGeneration，这里不再赘述。总体思路是，多个回收线程可以同时将一个对象拷贝到to区域，然后采用cas的方式设置源对象的forwarding指针，后设置的退回自己分配的内存。如果在to内存上分配失败，或者超过了age，也先使用cas修改forwarding指针，置为一个“假的”指针，然后在promote到下一个generation。为了达到在to上可以退回分配的内存，在ParScanThreadState中引入了一个ParGCAllocBuffer变量_to_space_alloc_buffer，_to_space_alloc_buffer管理着本回收线程在to区域上分配的内存，退回的内存可以再处理下一个对象时重新使用。</p>
<ol>
<li><p>在to上分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dummyOld.age() &lt; <span class="keyword">tenuring_t</span>hreshold()) &#123;</span><br><span class="line">    new_obj = (oop)par_scan_state-&gt;<span class="keyword">alloc_in_t</span>o_space(sz);</span><br><span class="line">    <span class="keyword">if</span> (new_obj == NULL) &#123;</span><br><span class="line">      set_survivor_overflow(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在to上没有分配成功，或者age超过了阈值，则先使用cas修改forwarding指针，置为一个“假的”指针，然后在promote到下一个generation，在修改forwarding指针时，如果发现别的回收线程捷足先登，则返回别人设置的“真正”的forwarding指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">forward_ptr = old-&gt;<span class="keyword">forward_t</span>o_atomic(ClaimedForwardPtr);</span><br><span class="line"><span class="keyword">if</span> (forward_ptr != NULL) &#123;</span><br><span class="line">  <span class="comment">// someone else beat us to it.</span></span><br><span class="line">    <span class="keyword">return</span> real_forwardee(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_obj = _next_gen-&gt;par_promote(par_scan_state-&gt;thread_num(),</span><br><span class="line">                                   old, m, sz);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果promote失败，处理方式和DefNewGeneration本质一样，不再赘述。</p>
<ol>
<li>如果在to上分配成功了，除了拷贝、修改age等常规动作外，使用cas，修改fowarding。</li>
<li>如果在以上cas操作中，是本线程胜利了，则将原来的对象加入到下一步scan的队列中。如果本线程没有胜利，如果已经在to分配了，调用<code>par_scan_state-&gt;undo_alloc_in_to_space((HeapWord*)new_obj, sz)</code>退回内存。</li>
</ol>
<h3 id="copy_to_survivor_space_with_undo">copy_to_survivor_space_with_undo</h3><p>诸如age判断之类的同DefNewGeneration，这里不再赘述。</p>
<ol>
<li><p>在to上分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dummyOld.age() &lt; <span class="keyword">tenuring_t</span>hreshold()) &#123;</span><br><span class="line">  new_obj = (oop)par_scan_state-&gt;<span class="keyword">alloc_in_t</span>o_space(sz);</span><br><span class="line">  <span class="keyword">if</span> (new_obj == NULL) &#123;</span><br><span class="line">    set_survivor_overflow(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在to上没有分配成功，或者age超过了阈值，直接在下一generation分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_obj = _next_gen-&gt;par_promote(par_scan_state-&gt;thread_num(),</span><br><span class="line">                                      old, m, sz);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在to上分配成功了，进行拷贝、修改age等常规动作。</p>
</li>
<li><p>如果上述的to上分配和promote没有出错，通过cas修改forwarding。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">failed_t</span>o_promote) &#123;</span><br><span class="line">  forward_ptr = old-&gt;<span class="keyword">forward_t</span>o_atomic(new_obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在以上cas操作中，是本线程胜利了，则将原来的对象加入到下一步scan的队列中，然后返回。</p>
</li>
<li>如果在cas修改中失败了，如果在to里分配的，调用<code>par_scan_state-&gt;undo_alloc_in_to_space((HeapWord*)new_obj, sz)</code>退回内存。如果在next generation里分配，调用<code>_next_gen-&gt;par_promote_alloc_undo</code>进行undo。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_in_reserved(new_obj)) &#123;</span><br><span class="line">   <span class="comment">// Must be in to_space.</span></span><br><span class="line">   assert(to()-&gt;is_in_reserved(new_obj), <span class="string">"Checking"</span>);</span><br><span class="line">   par_scan_state-&gt;<span class="keyword">undo_alloc_in_t</span>o_space((HeapWord*)new_obj, sz);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   assert(!_avoid_promotion_undo, <span class="string">"Should not be here if avoiding."</span>);</span><br><span class="line">   _next_gen-&gt;par_promote_alloc_undo(par_scan_state-&gt;thread_num(),</span><br><span class="line">                                     (HeapWord*)new_obj, sz);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>使用-XX:+UseParNewGC参数时，young generation为ParNewGeneration，其垃圾收集入口为：ParNewGeneration::collect。<br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DefNewGeneration垃圾收集]]></title>
    <link href="http://jangzq.info/2015/07/31/DefNewGeneration_collect/"/>
    <id>http://jangzq.info/2015/07/31/DefNewGeneration_collect/</id>
    <published>2015-07-31T14:12:10.000Z</published>
    <updated>2015-08-01T09:09:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>DefNewGeneration的垃圾回收方法入口在：DefNewGeneration::collect。<br><a id="more"></a></p>
<ul>
<li><p>首先判断在DefNewGeneration进行垃圾回收是否能成功，如果不能成功就直接跳过此Generation，否则白做无用工。判断的逻辑在DefNewGeneration::collection_attempt_is_safe，如果可以进行回收，返回true.</p>
<ol>
<li><p>首先判断to区域是否是空的，如果不空，说明上次回收都没有搞彻底，所以返回false。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!to()-&gt;is_empty()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    <span class="keyword">gclog_or_t</span>ty-&gt;print(<span class="string">" :: to is not empty :: "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过调用next generation的promotion_attempt_is_safe方法，得到next generation是否能容纳目前本generation已经使用的内存，如果能容纳，返回true，否则false。（一般在并不是只判断能不容纳当前的最大内存，而是也使用历史经验值判断）。</p>
</li>
</ol>
<p>此时在返回前，设置_incremental_collection_failed为true，即incremental collection将会失败。</p>
</li>
<li><p>遍历所有的root reference，处理现在存活的root对象，使用FastScanClosure处理每一个遍历到的oop， FastScanClosure的处理方法见附录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;gen_process_strong_roots(_level,</span><br><span class="line">                                <span class="keyword">true</span>,  <span class="comment">// Process younger gens, if any,</span></span><br><span class="line">                                       <span class="comment">// as strong roots.</span></span><br><span class="line">                                <span class="keyword">true</span>,  <span class="comment">// activate StrongRootsScope</span></span><br><span class="line">                                <span class="keyword">false</span>, <span class="comment">// not collecting perm generation.</span></span><br><span class="line">                                SharedHeap::SO_AllClasses,</span><br><span class="line">                                &amp;fsc_with_no_gc_barrier,</span><br><span class="line">                                <span class="keyword">true</span>,   <span class="comment">// walk *all* scavengable nmethods</span></span><br><span class="line">                                &amp;fsc_with_gc_barrier);</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历上一步得到root对象，遍历它们引用的对象，使用FastScanClosure处理每一个oop，直到遍历完。这是由<code>fastEvacuateFollowersClosure::do_void</code>实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  _gch-&gt;oop_since_save_marks_iterate(_level, _scan_cur_or_nonheap,</span><br><span class="line">                                     _scan_older);</span><br><span class="line">&#125; <span class="keyword">while</span> (!_gch-&gt;no_allocs_since_save_marks(_level));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在之前的遍历里，记录了所有java.lang.Reference相关对象，下面处理这些对象，处理方法和前面的类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FastKeepAliveClosure <span class="title">keep_alive</span><span class="params">(<span class="keyword">this</span>, &amp;scan_weak_ref)</span></span>;</span><br><span class="line">ReferenceProcessor* rp = ref_processor();</span><br><span class="line">rp-&gt;setup_policy(clear_all_soft_refs);</span><br><span class="line"><span class="keyword">const</span> ReferenceProcessorStats&amp; stats =</span><br><span class="line">  rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive, &amp;evacuate_followers,</span><br><span class="line">                                    NULL, <span class="keyword">_gc_t</span>imer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有发生promote错误，则</p>
<ol>
<li>交换from 和 to。</li>
<li>重新计算_tenuring_threshold，见附录。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swap_spaces();</span><br><span class="line"></span><br><span class="line">assert(to()-&gt;is_empty(), <span class="string">"to space should be empty now"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the desired survivor size to half the real survivor space</span></span><br><span class="line"><span class="keyword">_tenuring_t</span>hreshold =</span><br><span class="line">  <span class="keyword">age_t</span>able()-&gt;<span class="keyword">compute_tenuring_t</span>hreshold(to()-&gt;capacity()/HeapWordSize);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如果发生了promote错误，则</p>
<ol>
<li><p>如果一个对象已经挪到了新位置，并且所有引用它的指针已经指向了新位置，所以老的位置的对象就可以清除了，在成功的进行了gc时，整个from（原来的from）都可以不要，所以没必要单独处理每一个对象，但是现在由于eden、from 、to区域里都有活动的对象，以后进行full gc时，需要查看此区域，所以需要将eden和from区域里的对象里的forward oop全部清除。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_forwarding_pointers();</span><br></pre></td></tr></table></figure>
</li>
<li><p>交换from 和 to。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap_spaces();   <span class="comment">// For uniformity wrt ParNewGeneration.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>eden、from 、to区域里都有活动的对象，所以需要将to区域也加入到以后full gc需要compact的区域队列里。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from()-&gt;set_next_compaction_space(to());</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置incremental collection失败了的标志，</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;set_incremental_collection_failed();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通知next generation，发生了promote failure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_next_gen-&gt;promotion_failure_occurred();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="附录">附录</h2><h3 id="FastScanClosure">FastScanClosure</h3><p>如果对象在此generation里，进行下列处理，否则返回。<br>已经forward过了，则返回新地址，否则调用copy_to_survivor_space，拷贝到to或者promote到下一generation,并且返回新地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()</span><br><span class="line">                                    : _g-&gt;<span class="keyword">copy_t</span>o_survivor_space(obj);</span><br><span class="line">oopDesc::encode_store_heap_oop_not_null(p, new_obj);</span><br></pre></td></tr></table></figure></p>
<h3 id="DefNewGeneration::copy_to_survivor_space">DefNewGeneration::copy_to_survivor_space</h3><ol>
<li>如果oop的age小于阈值_tenuring_threshold，在to区域分配内存，如果分配成功，将对象拷贝到to区域，并且增加object的age。</li>
<li>如果在to上分配没有成功，或者age大于阈值，提升到下一个generation，如果promote失败，则留在原地。</li>
<li>如果移动成功了，则在原来的对象头上，记录forward到的新指针，并且增加age值。</li>
</ol>
<h3 id="重新计算_tenuring_threshold">重新计算_tenuring_threshold</h3><p>在每次gc之后，根据young generation里现存对象大小，计算出新的_tenuring_threshold，目标是使目前的对象大小，小于<code>to的大小 * TargetSurvivorRatio</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">  total += sizes[age];</span><br><span class="line">  <span class="comment">// check if including objects of age 'age' made us pass the desired</span></span><br><span class="line">  <span class="comment">// size, if so 'age' is the new threshold</span></span><br><span class="line">  <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">  age++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>DefNewGeneration的垃圾回收方法入口在：DefNewGeneration::collect。<br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之垃圾收集]]></title>
    <link href="http://jangzq.info/2015/07/29/GenCollectedHeap_collect/"/>
    <id>http://jangzq.info/2015/07/29/GenCollectedHeap_collect/</id>
    <published>2015-07-29T13:51:12.000Z</published>
    <updated>2015-07-29T14:02:29.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="VM_GenCollectForAllocation">VM_GenCollectForAllocation</h2><p>在<a href="http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/">分代内存管理之慢速路径内存分配</a>中提到，当分配内存不成功时，使用VM_GenCollectForAllocation来进行GC并且分配，下面详细描述。<br>在<code>VM_GenCollectForAllocation::doit()</code> 方法中，调用了<code>GenCollectedHeap</code>的<code>satisfy_failed_allocation</code>方法，此方法又委托给了<code>GenCollectorPolicy::satisfy_failed_allocation</code>方法，下面即这个方法的实现方式。</p>
<ol>
<li><p>如果当前有jni方法在critical区域，并且有线程要求gc，则不能再请求GC，否则白白阻塞，所以heap如果还有扩展的空间，则扩展，并且分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GC_locker::is_active_and_needs_gc()) &#123;</span><br><span class="line"> <span class="comment">// GC locker is active; instead of a collection we will attempt</span></span><br><span class="line"> <span class="comment">// to expand the heap, if there's room for expansion.</span></span><br><span class="line">   <span class="keyword">if</span> (!gch-&gt;is_maximal_no_gc()) &#123;</span><br><span class="line">      result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;   <span class="comment">// could be null if we are out of space</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果GC没有被阻塞，则根据GenCollectedHeap的incremental_collection_will_fail决定进行full gc还是incremental gc. 如果incremental_collection_will_fail返回true，说明incremental gc将要失败，所以需要进行full gc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">  <span class="comment">// Do an incremental collection.</span></span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    <span class="keyword">gclog_or_t</span>ty-&gt;print(<span class="string">" :: Trying full because partial may fail :: "</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垃圾收集完成后，继续尝试分配内存，如果不成功，则尝试扩展堆大小，然后再次分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/*first_only*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, collection failed, try expansion.</span></span><br><span class="line">result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果还是不能成功分配，则进行一次full gc，并且清除所有soft reference。然后再次分配，如果成功，返回地址，否则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line"> result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/* first_only */</span>);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(!should_clear_all_soft_refs(),</span><br><span class="line">  <span class="string">"Flag should have been handled and cleared prior to this point"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// What else?  We might try synchronous finalization later.  If the total</span></span><br><span class="line"><span class="comment">// space available is large enough for the allocation, then a more</span></span><br><span class="line"><span class="comment">// complete compaction phase than we've tried so far might be</span></span><br><span class="line"><span class="comment">// appropriate.</span></span><br><span class="line"><span class="keyword">return</span> NULL;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="GenCollectedHeap::do_collection">GenCollectedHeap::do_collection</h2><a id="more"></a>
<ol>
<li><p>如果当前有线程进行jni操作，并且位于critical区域，则直接退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GC_locker::check_active_before_gc()) &#123;</span><br><span class="line">   <span class="keyword">return</span>; <span class="comment">// GC is disabled (e.g. JNI Get<span class="doctag"><span class="keyword">XXX</span></span>Critical operation)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行gc_prologue。</p>
<ol>
<li>处理TLAB，见 <a href="http://jangzq.info/2015/06/28/tlab/">HotSpot的TLAB实现解析</a>。</li>
<li>调用各个Generation的gc_prologue。</li>
</ol>
</li>
<li><p>如果是full gc，则需要找到开始回收的，最老的generation，这通过调用Generation的full_collects_younger_generations方法得到，当对此generation进行回收时，同时会回收更新的generation时，返回true。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (full) &#123;</span><br><span class="line">   <span class="comment">// Search for the oldest generation which will collect all younger</span></span><br><span class="line">   <span class="comment">// generations, and start collection loop there.</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = max_level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">     <span class="keyword">if</span> (_gens[i]-&gt;full_collects_younger_generations()) &#123;</span><br><span class="line">       starting_level = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从上一步得到的starting_level到最老的generation,依照从young到old的次序进行垃圾回收。<br> 对于每一个generation。</p>
<ol>
<li>首先，使用<code>_gens[i]-&gt;should_collect(full, size, is_tlab)</code>方法判断是否需要在此generation上进行collect。<br> 见附录。</li>
<li>调用generation的collect方法，进行回收，见后续文章。</li>
<li>检查是否满足分配。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">is_t</span>lab || _gens[i]-&gt;<span class="keyword">supports_t</span>lab_allocation()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size*HeapWordSize &lt;= _gens[i]-&gt;unsafe_max_alloc_nogc()) &#123;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>重新计算每个generation的大小,如果是full gc，则重新计算Perm的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = max_level_collected; j &gt;= <span class="number">0</span>; j -= <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// Adjust generation sizes.</span></span><br><span class="line">  _gens[j]-&gt;compute_new_size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (complete) &#123;</span><br><span class="line">  <span class="comment">// Ask the permanent generation to adjust size for full collections</span></span><br><span class="line">  perm()-&gt;compute_new_size();</span><br><span class="line">  update_full_collections_completed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 gc_epilogue</p>
<ol>
<li>重新调整TLAB大小，见<a href="http://jangzq.info/2015/06/28/tlab/">HotSpot的TLAB实现解析</a>。</li>
<li>调用每个generation上的 gc_epilogue。<br>见后续文章。</li>
</ol>
</li>
</ol>
<h2 id="附录">附录</h2><h3 id="should_collect">should_collect</h3><p>介绍每个generation的should_collect的实现方式。</p>
<h4 id="DefNewGeneration及其子类">DefNewGeneration及其子类</h4><p>如果是full，则返回true，否则判断需要分配的内存是否可以在此generation分配，如果不可以，就不需要回收此generation。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (full || should_allocate(word_size, <span class="keyword">is_t</span>lab));</span><br></pre></td></tr></table></figure></p>
<h4 id="TenuredGeneration">TenuredGeneration</h4><p>full gc， 或者需要分配的内存是否可以在此generation分配， 或者剩余空间少于10k，或者gc开始时的capacity，小于目前的capacity，即说明为了容纳young generation上移的内存，造成了本generationde 扩展。</p>
<h4 id="ConcurrentMarkSweepGeneration">ConcurrentMarkSweepGeneration</h4><p>如果是full，则返回true，否则判断需要分配的内存是否可以在此generation分配，如果不可以，就不需要回收此generation。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="VM_GenCollectForAllocation">VM_GenCollectForAllocation</h2><p>在<a href="http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/">分代内存管理之慢速路径内存分配</a>中提到，当分配内存不成功时，使用VM_GenCollectForAllocation来进行GC并且分配，下面详细描述。<br>在<code>VM_GenCollectForAllocation::doit()</code> 方法中，调用了<code>GenCollectedHeap</code>的<code>satisfy_failed_allocation</code>方法，此方法又委托给了<code>GenCollectorPolicy::satisfy_failed_allocation</code>方法，下面即这个方法的实现方式。</p>
<ol>
<li><p>如果当前有jni方法在critical区域，并且有线程要求gc，则不能再请求GC，否则白白阻塞，所以heap如果还有扩展的空间，则扩展，并且分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GC_locker::is_active_and_needs_gc()) &#123;</span><br><span class="line"> <span class="comment">// GC locker is active; instead of a collection we will attempt</span></span><br><span class="line"> <span class="comment">// to expand the heap, if there's room for expansion.</span></span><br><span class="line">   <span class="keyword">if</span> (!gch-&gt;is_maximal_no_gc()) &#123;</span><br><span class="line">      result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;   <span class="comment">// could be null if we are out of space</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果GC没有被阻塞，则根据GenCollectedHeap的incremental_collection_will_fail决定进行full gc还是incremental gc. 如果incremental_collection_will_fail返回true，说明incremental gc将要失败，所以需要进行full gc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">  <span class="comment">// Do an incremental collection.</span></span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    <span class="keyword">gclog_or_t</span>ty-&gt;print(<span class="string">" :: Trying full because partial may fail :: "</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垃圾收集完成后，继续尝试分配内存，如果不成功，则尝试扩展堆大小，然后再次分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/*first_only*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, collection failed, try expansion.</span></span><br><span class="line">result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果还是不能成功分配，则进行一次full gc，并且清除所有soft reference。然后再次分配，如果成功，返回地址，否则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line"> result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/* first_only */</span>);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(!should_clear_all_soft_refs(),</span><br><span class="line">  <span class="string">"Flag should have been handled and cleared prior to this point"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// What else?  We might try synchronous finalization later.  If the total</span></span><br><span class="line"><span class="comment">// space available is large enough for the allocation, then a more</span></span><br><span class="line"><span class="comment">// complete compaction phase than we've tried so far might be</span></span><br><span class="line"><span class="comment">// appropriate.</span></span><br><span class="line"><span class="keyword">return</span> NULL;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="GenCollectedHeap::do_collection">GenCollectedHeap::do_collection</h2>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之内存初始化]]></title>
    <link href="http://jangzq.info/2015/07/28/GenCollectedHeap_meminit/"/>
    <id>http://jangzq.info/2015/07/28/GenCollectedHeap_meminit/</id>
    <published>2015-07-28T13:30:58.000Z</published>
    <updated>2015-07-28T13:41:36.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理的内存初始化入口在：GenCollectedHeap::initialize。</p>
<h2 id="整体分配内存">整体分配内存</h2><p>在GenCollectedHeap::allocate方法中。在此之前，初始化CollectorPolicy时，已经计算了各个Generation的最大、最小、初始值，并且初始化了GenerationSpec数组。计算大小的过程见：<a href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/">分代内存管理之Generation Size</a><br><strong>注:</strong> 由于UseSharedSpaces只适用于Client mode，所以在此不分析相关代码。<br><strong>注：</strong> 这部分所说的分配内存，并不是真正的分配物理内存，而是在地址空间分配一段内存地址空间，在linux下使用mmap的匿名映射实现，当访问其中的某一地址时，产生缺页中断，由操作系统分配真实物理内存。</p>
<ul>
<li><p>计算需要的内存大小。</p>
<ol>
<li><p>遍历各个Generation Spec，将其最大内存相加。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  total_reserved = add_and_check_overflow(total_reserved, _gen_specs[i]-&gt;max_size());</span><br><span class="line">  n_covered_regions += _gen_specs[i]-&gt;n_covered_regions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再加上Perm区域的最大内存，及misc_data_size()、misc_code_size()<br>misc_data_size()、misc_code_size()并包含在heap内，只是在这里一起分配。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total_reserved = add_and_check_overflow(total_reserved, perm_gen_spec-&gt;max_size());</span><br><span class="line"><span class="keyword">size_t</span> misc = perm_gen_spec-&gt;misc_data_size() + perm_gen_spec-&gt;misc_code_size();</span><br><span class="line">total_reserved = add_and_check_overflow(total_reserved, misc);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>在使用压缩指针的情况下，需要确定heap的base address，和指针的encoding mode，然后在base address上分配，如果分配不成功，则整个虚拟机初始化失败。<br>hotspot中存在三种encoding mode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> NARROW_OOP_MODE &#123;</span><br><span class="line">  UnscaledNarrowOop  = <span class="number">0</span>,</span><br><span class="line">  ZeroBasedNarrowOop = <span class="number">1</span>,</span><br><span class="line">  HeapBasedNarrowOop = <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当heap内存小于4G的情况下，如果把heap分配到4G以下，则原64位指针，narrow为32位，即可作为narrow指针，这种情况即UnscaledNarrowOop。当内存大于4G，小于32G时，如果可以分配在32G以下的部分，则可以base为0,而shift为    LogMinObjAlignmentInBytes (默认为3)，这种对应的情况为ZeroBasedNarrowOop。如果不能分配在32G以下，则原64位指针需要减去一个base，再使用shift，转换为narrow的指针，这种情况即HeapBasedNarrowOop。<br> 如下面程序， 依次尝试 UnscaledNarrowOop、ZeroBasedNarrowOop、HeapBasedNarrowOop三种分配方式，分配成功即返回</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::UnscaledNarrowOop);</span><br><span class="line">*<span class="keyword">_t</span>otal_reserved = total_reserved;</span><br><span class="line">*_n_covered_regions = n_covered_regions;</span><br><span class="line">*heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                             UseLargePages, heap_address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (heap_address != NULL &amp;&amp; !heap_rs-&gt;is_reserved()) &#123;</span><br><span class="line">  <span class="comment">// Failed to reserve at specified address - the requested memory</span></span><br><span class="line">  <span class="comment">// region is taken already, for example, by 'java' launcher.</span></span><br><span class="line">  <span class="comment">// Try again to reserver heap higher.</span></span><br><span class="line">  heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::ZeroBasedNarrowOop);</span><br><span class="line">  *heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                               UseLargePages, heap_address);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (heap_address != NULL &amp;&amp; !heap_rs-&gt;is_reserved()) &#123;</span><br><span class="line">    <span class="comment">// Failed to reserve at specified address again - give up.</span></span><br><span class="line">    heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::HeapBasedNarrowOop);</span><br><span class="line">    assert(heap_address == NULL, <span class="string">""</span>);</span><br><span class="line">    *heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                                 UseLargePages, heap_address);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> heap_address;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有使用压缩指针，则直接分配内存。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">_t</span>otal_reserved = total_reserved;</span><br><span class="line">*_n_covered_regions = n_covered_regions;</span><br><span class="line">*heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                          UseLargePages, heap_address);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="初始化CollectedHeap::_reserved">初始化CollectedHeap::_reserved</h2><p>定义：<code>MemRegion _reserved</code></p>
<ul>
<li>HeapWord* _start 设置为分配的地址。</li>
<li>size_t    _word_size 设置为实际的大小，即排除了misc_data_size()、misc_code_size()的大小。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> actual_heap_size = heap_rs.size() - perm_gen_spec-&gt;misc_data_size()</span><br><span class="line">                                          - perm_gen_spec-&gt;misc_code_size();</span><br><span class="line">       _reserved.set_end((HeapWord*)(heap_rs.base() + actual_heap_size));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="初始化Generation">初始化Generation</h2><p>对于所有的Generation，循环初始化。</p>
<ol>
<li>使用上文分配的地址范围，依次构造ReservedSpace对象（使用每一Generation的内存最大值），来描述每一个Generation的内存范围。</li>
<li>调用Generation Spec的init方法初始化。</li>
<li>初始化Perm Generation。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">    ReservedSpace this_rs = heap_rs.first_part(_gen_specs[i]-&gt;max_size(),</span><br><span class="line">                                              UseSharedSpaces, UseSharedSpaces);</span><br><span class="line">    _gens[i] = _gen_specs[i]-&gt;init(this_rs, i, rem_set());</span><br><span class="line">    <span class="comment">// tag generations in JavaHeap</span></span><br><span class="line">    MemTracker::<span class="keyword">record_virtual_memory_t</span>ype((address)this_rs.base(), mtJavaHeap);</span><br><span class="line">    heap_rs = heap_rs.last_part(_gen_specs[i]-&gt;max_size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">_perm_gen = perm_gen_spec-&gt;init(heap_rs, PermSize, rem_set());</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理的内存初始化入口在：GenCollectedHeap::initialize。</p>
<h2 id="整体分配内存">整体分配内存</h2><p>在GenCollectedHeap::allocate方法中。在此之前，初始化CollectorPolicy时，已经计算了各个Generation的最大、最小、初始值，并且初始化了GenerationSpec数组。计算大小的过程见：<a href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/">分代内存管理之Generation Size</a><br><strong>注:</strong> 由于UseSharedSpaces只适用于Client mode，所以在此不分析相关代码。<br><strong>注：</strong> 这部分所说的分配内存，并不是真正的分配物理内存，而是在地址空间分配一段内存地址空间，在linux下使用mmap的匿名映射实现，当访问其中的某一地址时，产生缺页中断，由操作系统分配真实物理内存。</p>
<ul>
<li><p>计算需要的内存大小。</p>
<ol>
<li><p>遍历各个Generation Spec，将其最大内存相加。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  total_reserved = add_and_check_overflow(total_reserved, _gen_specs[i]-&gt;max_size());</span><br><span class="line">  n_covered_regions += _gen_specs[i]-&gt;n_covered_regions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再加上Perm区域的最大内存，及misc_data_size()、misc_code_size()<br>misc_data_size()、misc_code_size()并包含在heap内，只是在这里一起分配。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total_reserved = add_and_check_overflow(total_reserved, perm_gen_spec-&gt;max_size());</span><br><span class="line"><span class="keyword">size_t</span> misc = perm_gen_spec-&gt;misc_data_size() + perm_gen_spec-&gt;misc_code_size();</span><br><span class="line">total_reserved = add_and_check_overflow(total_reserved, misc);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之Generation Size]]></title>
    <link href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/"/>
    <id>http://jangzq.info/2015/07/27/GenCollectedHeap_size/</id>
    <published>2015-07-27T14:04:41.000Z</published>
    <updated>2015-07-27T14:17:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理中各个generation的内存大小设置，保存在CollectorPolicy及其子类里，如下图所示。<br><img src="/images/gen_size.png" alt="CollectorPolicy"><br>从图中可以看出，CollectorPolicy类管理heap的大小，GenCollectorPolicy类管理着Generation 0的大小，而TwoGenerationCollectorPolicy管理着Generation 1的大小。</p>
<h2 id="Heap大小">Heap大小</h2><p>见：<a href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/">垃圾收集框架：CollectedHeap和CollectorPolicy</a></p>
<h2 id="Generation">Generation</h2><p><strong>Generation大小必须以<code>min_alignment()</code>对齐，一般为64k，并且最小不能小于<code>min_alignment()</code>。为了描述方便，下文有的地方省略对齐及最小值调整部分，请知晓</strong></p>
<h3 id="Generation_0">Generation 0</h3><a id="more"></a>
<h4 id="_max_gen0_size">_max_gen0_size</h4><p>首先，计算中间值max_new_size。</p>
<ul>
<li>当设置了MaxNewSize参数，_max_gen0_size由此参数决定。<ol>
<li>如果MaxNewSize小于最小对齐粒度<code>min_alignment()</code>（一般为64k），则max_new_size设为<code>min_alignment()</code>。</li>
<li>如果大于设置的“堆的最大值”<code>max_heap_byte_size()</code>，则设为<code>align_size_down(max_heap_byte_size() - min_alignment(), min_alignment())</code></li>
<li>否则，设为MaxNewSize，按最小对齐粒度对齐, <code>align_size_down(MaxNewSize, min_alignment())</code>。</li>
</ol>
</li>
<li>当没有设置MaxNewSize参数时，设为“堆的最大值”/(NewRatio+1)，NewRatio缺省为2, 当这个值小于最小对齐粒度<code>min_alignment()</code>（一般为64k），则max_new_size设为<code>min_alignment()</code>。<br>上述结果再根据设置的“堆的最大值”和“堆的最小值”进行调整。</li>
<li>如果“堆的最大值”等于“堆的最小值”，max_new_size不变。</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize，则max_new_size取（max_new_size， NewSize)两者最大的。<br>最后，设置_max_gen0_size为max_new_size，如果超过了“堆的最大值”，设为<code>align_size_down(max_heap_byte_size() - min_alignment(), min_alignment())</code>。</li>
</ul>
<h4 id="_initial_gen0_size">_initial_gen0_size</h4><ul>
<li>如果“堆的最大值”和“堆的最小值”相等， _initial_gen0_size设为max_new_size，</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize参数，则设为NewSize。如果没有设置NewSize，设为“堆的初始值”/(NewRatio+1)，和NewSize缺省值之间最大的。</li>
</ul>
<p>最后，根据“heap的初始值”进行调整，如果超过了“Heap的初始值” (<code>_initial_heap_byte_size</code>)，设为<code>align_size_down(initial_heap_byte_size() - min_alignment(), min_alignment())</code>。</p>
<p><strong>注:</strong> <em>在设置OLD Generation大小时，如果设置了OldSize，并且OldSize+_initial_gen0_size大于“堆的初始值”时，会调整此值。</em></p>
<h4 id="_min_gen0_size">_min_gen0_size</h4><ul>
<li>如果“堆的最大值”和“堆的最小值”相等， _min_gen0_size设为max_new_size，</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize参数，则设为NewSize。如果没有设置NewSize，设为“堆的最小值”/(NewRatio+1)，和NewSize缺省值之间最大的。</li>
</ul>
<p>最后，根据“heap的初始值”进行调整，如果超过了“Heap的最小值” (<code>_min_heap_byte_size</code>)，设为<code>align_size_down(min_heap_byte_size() - min_alignment(), min_alignment())</code>。</p>
<p><strong>注:</strong> <em>在设置OLD Generation大小时，如果设置了OldSize，并且OldSize+_min_gen0_size大于“堆的最小值”时，会调整此值。</em></p>
<h3 id="Generation_1">Generation 1</h3><h4 id="_max_gen1_size">_max_gen1_size</h4><p>设为“堆最大值”-_max_gen0_size，和min_alignment()的最大值。</p>
<h4 id="_initial_gen1_size">_initial_gen1_size</h4><ul>
<li>如果没有设置OldSize，设置为initial_heap_byte_size() - initial_gen0_size()。</li>
<li>如果设置了OldSize，此值设置为OldSize，如果_initial_gen0_size+OldSize 大于“堆的初始值”，则需要调整_initial_gen0_size。</li>
</ul>
<h4 id="_min_gen1_size">_min_gen1_size</h4><ul>
<li>如果没有设置OldSize，设置为initial_heap_byte_size() - _min_gen0_size。</li>
<li>如果设置了OldSize，此值设置为OldSize，如果_min_gen0_size+OldSize 大于“堆的最小值”，则需要调整_min_gen0_size。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理中各个generation的内存大小设置，保存在CollectorPolicy及其子类里，如下图所示。<br><img src="/images/gen_size.png" alt="CollectorPolicy"><br>从图中可以看出，CollectorPolicy类管理heap的大小，GenCollectorPolicy类管理着Generation 0的大小，而TwoGenerationCollectorPolicy管理着Generation 1的大小。</p>
<h2 id="Heap大小">Heap大小</h2><p>见：<a href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/">垃圾收集框架：CollectedHeap和CollectorPolicy</a></p>
<h2 id="Generation">Generation</h2><p><strong>Generation大小必须以<code>min_alignment()</code>对齐，一般为64k，并且最小不能小于<code>min_alignment()</code>。为了描述方便，下文有的地方省略对齐及最小值调整部分，请知晓</strong></p>
<h3 id="Generation_0">Generation 0</h3>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之慢速路径内存分配]]></title>
    <link href="http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/"/>
    <id>http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/</id>
    <published>2015-07-26T03:45:47.000Z</published>
    <updated>2015-07-26T12:39:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代的内存管理使用GenCollectedHeap。generation的类如下：</p>
<p><img src="/images/generation.png" alt="Generation"></p>
<p>在这里我们主要剖析慢速路径使用的GenCollectedHeap::mem_allocate方法。其内存分配委托给了相应的CollectorPolicy实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> collector_policy()-&gt;mem_allocate_work(size,</span><br><span class="line">                                             <span class="keyword">false</span> <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                                             gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure>
<p>所以，下面剖析GenCollectorPolicy::mem_allocate_work的实现。</p>
<ul>
<li><p>内存分配的逻辑在下列循环中，说明此方法只有两个出口，或者分配成功，或者抛出异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> try_count = <span class="number">1</span>; <span class="comment">/* return or throw */</span>; try_count += <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分代的内存管理，在Young generation里实现无锁的分配方式，从assert中可以看出，Young generation必须满足<code>supports_inline_contig_alloc</code>，即必须满足，在堆中必须有一块儿连续的空间，可用范围由top_addr()，end_addr()决定的，并且可以靠移动top_addr来分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(gen0-&gt;supports_inline_contig_alloc(),</span><br><span class="line">      <span class="string">"Otherwise, must do alloc within heap lock"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，在Young generation进行无锁分配。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gen0-&gt;should_allocate(size, <span class="keyword">is_t</span>lab)) &#123;</span><br><span class="line">  result = gen0-&gt;par_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool should_allocate(size_t word_size, bool is_tlab)</strong>：在这个generation中是否可以分配<code>word_size</code>大小的内存。<br><em>defNewGeneration及其子类</em><br>1、没有overflows，即没有超过size_t表示的范围。<br>2、如果设置了PretenureSizeThreshold，小于此值。</p>
<p><em>其它</em><br>只判断是否overflows。</p>
<p><strong>HeapWord* par_allocate(size_t word_size, bool is_tlab)</strong>: 在慢速路径分配时，提供不加锁分配内存的方式。<br><em>defNewGeneration</em>:<br>调用Eden区的par_allocate方法，使用cmpxchg方式修改top指针，分配内存。</p>
</li>
<li><p>如果上面没有分配成功，将使用有锁的慢速分配，这部分使用的是GenCollectedHeap::attempt_allocation方法。首先需要确认是否只在Young generation进行分配，如果只需在Young generation进行分配，那么当不能成功分配的时候，就进行GC，否则尝试在更老的Generation上分配，所以这个判断是很重要的。<br><strong>bool GenCollectorPolicy::should_try_older_generation_allocation(size_t word_size) const</strong>: 判断是否只在Young generation上进行分配。<br>满足下列三个条件之一，就需要在更老的Generation尝试。</p>
<ol>
<li>调用<code>gch-&gt;get_gen(0)-&gt;capacity_before_gc()</code>得到Young generation不用GC，最多能分配的内存大小，defNewGeneration及其子类，直接返回Eden的容量。即如果要分配的内存大于Eden的容量，则需要尝试next generation.</li>
<li><code>GC_locker::is_active_and_needs_gc()</code>，即当前有jni方法在critical区域，并且有线程要求gc，这时如果只在Young generation分配，则势必需要GC，造成阻塞，所以需要尝试next generation.</li>
<li><code>gch-&gt;incremental_collection_failed()</code>，即最近一次的incremental收集错误，也就是在Young generation层GC应该没有效果，所以需要尝试next generation.</li>
</ol>
<p>在GenCollectedHeap::attempt_allocation中，以此调用各个Generation的allocate方法进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_gens[i]-&gt;should_allocate(size, <span class="keyword">is_t</span>lab)) &#123;</span><br><span class="line">    res = _gens[i]-&gt;allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">    <span class="keyword">if</span> (res != NULL) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first_only) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果到此还没有分配成功，首先不要急于GC，如果<code>GC_locker::is_active_and_needs_gc()</code>，即当前有jni方法在critical区域，并且有线程要求gc，则进行如下处理。</p>
<ol>
<li>如果是要求在TLAB上分配，则直接返回NULL，调用者会尝试接下来的分配方式。</li>
<li>使用<code>GenCollectedHeap::is_maximal_no_gc</code>得到各个generation是否没有达到最大设置，如果存在这样的generation，调用<code>GenCollectorPolicy::expand_heap_and_allocate</code>扩展并且分配。</li>
<li>如果上一步没有分配成功，则等待处于critical的jni线程退出后，再次从头执行分配流程。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!jthr-&gt;in_critical()) &#123;</span><br><span class="line">        <span class="function">MutexUnlocker <span class="title">mul</span><span class="params">(Heap_lock)</span></span>;</span><br><span class="line">        <span class="comment">// Wait for JNI critical section to be exited</span></span><br><span class="line">        GC_locker::stall_until_clear();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>进行GC，并且同时分配。</p>
<ol>
<li><p>提交GC. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VM_GenCollectForAllocation <span class="title">op</span><span class="params">(size,</span><br><span class="line">                            is_tlab,</span><br><span class="line">                            gc_count_before)</span></span>;</span><br><span class="line">VMThread::execute(&amp;op);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果别的线程已经请求GC了，则从头执行分配流程重试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op.prologue_succeeded()) &#123;</span><br><span class="line">  result = op.result();</span><br><span class="line">  <span class="keyword">if</span> (op.gc_locked()) &#123;</span><br><span class="line">     assert(result == NULL, <span class="string">"must be NULL if gc_locked() is true"</span>);</span><br><span class="line">     <span class="keyword">continue</span>;  <span class="comment">// retry and/or stall as necessary</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果执行完gc，但是花费了很多时间，才回收下很少内存，返回NULL，并且给<code>gc_overhead_limit_was_exceeded</code>赋值。</p>
</li>
<li>gc并分配成功，返回结果。</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代的内存管理使用GenCollectedHeap。generation的类如下：</p>
<p><img src="/images/generation.png" alt="Generation"></p>
<p>在这里我们主要剖析慢速路径使用的GenCollectedHeap::mem_allocate方法。其内存分配委托给了相应的CollectorPolicy实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> collector_policy()-&gt;mem_allocate_work(size,</span><br><span class="line">                                             <span class="keyword">false</span> <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                                             gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure>
<p>所以，下面剖析GenCollectorPolicy::mem_allocate_work的实现。</p>
<ul>
<li><p>内存分配的逻辑在下列循环中，说明此方法只有两个出口，或者分配成功，或者抛出异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> try_count = <span class="number">1</span>; <span class="comment">/* return or throw */</span>; try_count += <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分代的内存管理，在Young generation里实现无锁的分配方式，从assert中可以看出，Young generation必须满足<code>supports_inline_contig_alloc</code>，即必须满足，在堆中必须有一块儿连续的空间，可用范围由top_addr()，end_addr()决定的，并且可以靠移动top_addr来分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(gen0-&gt;supports_inline_contig_alloc(),</span><br><span class="line">      <span class="string">"Otherwise, must do alloc within heap lock"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，在Young generation进行无锁分配。</p>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过解释器的new操作看内存分配]]></title>
    <link href="http://jangzq.info/2015/07/05/new/"/>
    <id>http://jangzq.info/2015/07/05/new/</id>
    <published>2015-07-04T16:13:29.000Z</published>
    <updated>2015-07-04T16:30:24.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>了解hotspot的内存分配流程，TemplateTable::_new方法是个比较好的入口，这个方法生成了供以后解释执行时使用的汇编代码。从这个方法入手，可以了解hotspot创建对象所需要的操作，对我们开发应用程序时，进行内存管理设计有很大的帮助。</p>
<h2 id="概述">概述</h2><p>新建一个对象，有三种方式。</p>
<ol>
<li><p>在TLAB中分配<br>如果<code>UseTLAB</code>为真（缺省是true），就先进行TLAB分配，本部分的内容在<a href="http://jangzq.info/2015/06/28/tlab/">《HotSpot的TLAB实现解析》</a>一文里也进行了简单的说明，本文后面详细说明。</p>
</li>
<li><p>在shared eden中快速分配。<br>TLAB是eden中的每个线程自己使用的部分，shared eden就是共享的部分。当在TLAB中分配失败后，也就是TLAB中的内存大小不够时，就有可能在shared eden中分配。之所以是有可能，是需要满足以下的条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> allow_shared_alloc =</span><br><span class="line">   Universe::heap()-&gt;supports_inline_contig_alloc() &amp;&amp; !CMSIncrementalMode</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>supports_inline_contig_alloc</code>与具体的<code>CollectedHeap</code>有关，也就是必须满足，在堆中必须有一块儿连续的空间，可用范围由<code>top_addr()</code>，<code>end_addr()</code>决定的，并且可以靠移动<code>top_addr</code>来分配内存。<br><code>CMSIncrementalMode</code>是增量CMS模式，当设置了增量CMS模式时，不允许在share eden中快速分配。</p>
<ol>
<li>慢速路径<br>调用<code>InterpreterRuntime::_new</code>进行分配。当类没有解析或者初始化时，还有上面的两种分配方式都不成功的时候，进入慢速模式。</li>
</ol>
<h2 id="源码解析">源码解析</h2><a id="more"></a>
<h3 id="得到类的大小">得到类的大小</h3><p>要分配内存，首先要知道大小，所以通过下面的操作得到类的大小。<br>首先判断这个类的符号连接在常量池里是否已经解析，没有解析的话，就不能走快速路径了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ <span class="keyword">get_cpool_and_t</span>ags(rsi, rax); <span class="comment">//rsi指向了常量池地址，rax指向了常量池的tags。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tags_offset = typeArrayOopDesc::header_size(T_BYTE) * wordSize;</span><br><span class="line">__ cmpb(Address(rax, rdx, Address::times_1, tags_offset),</span><br><span class="line">        JVM_CONSTANT_Class);</span><br><span class="line">__ jcc(Assembler::notEqual, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>得到instanceKlass，并且判断是否初始化，如果没有初始化，也不能走快速路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__ movptr(rsi, Address(rsi, rdx,</span><br><span class="line">          Address::times_8, <span class="keyword">sizeof</span>(constantPoolOopDesc)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure klass is initialized &amp; doesn't have finalizer</span></span><br><span class="line"><span class="comment">// make sure klass is fully initialized</span></span><br><span class="line">__ cmpb(Address(rsi,</span><br><span class="line">                instanceKlass::init_state_offset()),</span><br><span class="line">        instanceKlass::fully_initialized);</span><br><span class="line">__ jcc(Assembler::notEqual, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>注：解析和初始化的概念请参考《java虚拟机规范》。<br>当分配的是普通类对象（非数组）时， 如果klass::_layout_helper为正数，这个值就是对象的大小。如果最低位为1的话，则说明不能应用快速路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get instance_size in instanceKlass (scaled to a count of bytes)</span></span><br><span class="line"> __ movl(rdx,</span><br><span class="line">         Address(rsi,</span><br><span class="line">                 Klass::layout_helper_offset()));</span><br><span class="line"> <span class="comment">// test to see if it has a finalizer or is malformed in some way</span></span><br><span class="line"> __ testl(rdx, Klass::_lh_instance_slow_path_bit);</span><br><span class="line"> __ jcc(Assembler::notZero, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>经过以上步骤，对象的大小已经放在了rdx寄存器中，下面进行内存分配。</p>
<h3 id="TLAB分配">TLAB分配</h3><p>如果<code>UseTLAB</code>为真（缺省是true），就先进行TLAB分配。<br>首先，尝试直接修改TLAB的当前指针分配。当前线程的TLAB当前待分配指针存放在<code>JavaThread</code>的<code>tlab_top_offset</code>属性里，而r15指向了当前线程的<code>JavaThread</code>，所以首先将其存放到rax里，然后加上前面得到的对象大小，得到如果在TLAB里分配，指针的位置。然后比较这个位置和当前tlab的最大指针，如果超出了这个位置，说明tlab里的空间不足以分配这个对象，否则移动tlab的当前指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ movptr(rax, Address(<span class="keyword">r15_t</span>hread, in_bytes(JavaThread::<span class="keyword">tlab_t</span>op_offset())));</span><br><span class="line"> __ lea(rbx, Address(rax, rdx, Address::times_1));</span><br><span class="line"> __ cmpptr(rbx, Address(<span class="keyword">r15_t</span>hread, in_bytes(JavaThread::tlab_end_offset())));</span><br><span class="line"> __ jcc(Assembler::above, allow_shared_alloc ? allocate_shared : slow_case);</span><br><span class="line"> __ movptr(Address(<span class="keyword">r15_t</span>hread, in_bytes(JavaThread::<span class="keyword">tlab_t</span>op_offset())), rbx);</span><br></pre></td></tr></table></figure></p>
<p>从上面代码中可以看出，如果没空间，根据是否允许在share eden中快速分配，选择 allocate_shared，或者慢速路径。<br>如果设置了ZeroTLAB,则分配的内存已经全置为0了，就不需要初始化对象，只需要初始化header。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ZeroTLAB) &#123;</span><br><span class="line">      <span class="comment">// the fields have been already cleared</span></span><br><span class="line">      __ jmp(initialize_header);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// initialize both the header and fields</span></span><br><span class="line">      __ jmp(initialize_object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Shared_eden快速分配">Shared eden快速分配</h3><p>由于shared eden是共享的，所以不能直接移动指针分配，需要保护机制。在x86_64里，采用的是<code>cmpxchg</code>指令。<br>首先， 比较shared eden的当前指针+对象大小，是否超过了shared eden的范围，如果超过了，只好去慢速路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__ lea(rbx, Address(rax, rdx, Address::times_1));</span><br><span class="line"> __ cmpptr(rbx, Address(RendAddr, <span class="number">0</span>));</span><br><span class="line"> __ jcc(Assembler::above, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>然后， 用cas修改当前指针的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    __ lock();</span><br><span class="line">&#125;</span><br><span class="line">__ cmpxchgptr(rbx, Address(RtopAddr, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// if someone beat us on the allocation, try again, otherwise continue</span></span><br><span class="line">__ jcc(Assembler::notEqual, retry);</span><br></pre></td></tr></table></figure></p>
<p><code>__ lock()</code>方法生成lock前缀， 然后使用<code>cmpxchg</code>，给当前top指针赋值。具体含义为：因为现在rax中存放的是根据当前的top地址计算的object的起始地址，rbx存放的是object的结束地址，当内存中的rtopaddr处的内容等于rax时，将rbx的内容存入内存的这个地方，否则的话，说明别的线程已经改了这个地址的内存，这时将内存此处的值放入rax，以上操作是原子的。当修改失败的时候，需要重试。</p>
<h3 id="初始化对象和头">初始化对象和头</h3><p>初始化对象，即将对象全部清0。<br>初始化头，即初始化对象前面的oopDesc。</p>
<h3 id="慢速分配">慢速分配</h3><p>入口为：<code>InterpreterRuntime::_new</code>。<br>首先，检查类是否已经解析和初始化，然后进入实质分配内存部分：<code>CollectedHeap::common_mem_allocate_noinit</code>。</p>
<h4 id="TLAB分配-1">TLAB分配</h4><p>首先在tlab中分配。这里面可以扩展新的TLAB空间，《HotSpot的TLAB实现解析》里描述的比较详细，请参考。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">  result = <span class="keyword">allocate_from_t</span>lab(klass, THREAD, size);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    assert(!HAS_PENDING_EXCEPTION,</span><br><span class="line">           <span class="string">"Unexpected exception, will result in uninitialized storage"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="CollectedHeap分配">CollectedHeap分配</h4><p>分配不成功，调用当前<code>CollectedHeap</code>的<code>mem_allocate</code>方法，这个是个虚函数，由具体的子类实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = Universe::heap()-&gt;mem_allocate(size,</span><br><span class="line">                                        &amp;gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure></p>
<p>详细描述在另外单独文章描述，请关注<a href="http://jangzq.info/">Jangzq技术研究</a>。</p>
<h4 id="内存溢出处理">内存溢出处理</h4><p>当还没有分配成功，这时就需要报告内存溢出。<br>详细描述在另外单独文章描述，请关注<a href="http://jangzq.info/">Jangzq技术研究</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>了解hotspot的内存分配流程，TemplateTable::_new方法是个比较好的入口，这个方法生成了供以后解释执行时使用的汇编代码。从这个方法入手，可以了解hotspot创建对象所需要的操作，对我们开发应用程序时，进行内存管理设计有很大的帮助。</p>
<h2 id="概述">概述</h2><p>新建一个对象，有三种方式。</p>
<ol>
<li><p>在TLAB中分配<br>如果<code>UseTLAB</code>为真（缺省是true），就先进行TLAB分配，本部分的内容在<a href="http://jangzq.info/2015/06/28/tlab/">《HotSpot的TLAB实现解析》</a>一文里也进行了简单的说明，本文后面详细说明。</p>
</li>
<li><p>在shared eden中快速分配。<br>TLAB是eden中的每个线程自己使用的部分，shared eden就是共享的部分。当在TLAB中分配失败后，也就是TLAB中的内存大小不够时，就有可能在shared eden中分配。之所以是有可能，是需要满足以下的条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> allow_shared_alloc =</span><br><span class="line">   Universe::heap()-&gt;supports_inline_contig_alloc() &amp;&amp; !CMSIncrementalMode</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>supports_inline_contig_alloc</code>与具体的<code>CollectedHeap</code>有关，也就是必须满足，在堆中必须有一块儿连续的空间，可用范围由<code>top_addr()</code>，<code>end_addr()</code>决定的，并且可以靠移动<code>top_addr</code>来分配内存。<br><code>CMSIncrementalMode</code>是增量CMS模式，当设置了增量CMS模式时，不允许在share eden中快速分配。</p>
<ol>
<li>慢速路径<br>调用<code>InterpreterRuntime::_new</code>进行分配。当类没有解析或者初始化时，还有上面的两种分配方式都不成功的时候，进入慢速模式。</li>
</ol>
<h2 id="源码解析">源码解析</h2>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[垃圾收集框架：CollectedHeap和CollectorPolicy]]></title>
    <link href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/"/>
    <id>http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/</id>
    <published>2015-07-03T14:10:27.000Z</published>
    <updated>2015-07-05T11:38:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>hotspot的垃圾收集框架有两个主要的组成部分，其一是CollectedHeap、其一是CollectorPolicy。根据不同的启动参数，hotspot选择相应的Heap和Policy。<br>首先我们看一下类图，看一下有多少种CollectedHeap和CollectorPolicy。</p>
<p><img src="/images/heap_policy.png" alt="类图"></p>
<p>下面列出的是CollectorPolicy和CollectedHeap的关键属性和方法，我们以此来看一下Policy和Heap各自的特性。</p>
<h2 id="CollectedHeap">CollectedHeap</h2><p>CollectedHeap是java堆在hotspot中的体现，根据垃圾收集算法的不同，具有不同类型的子类，CollectedHeap的主要功能是分配内存，在这个父类里实现的主要是分配的流程，包括TLAB、其它分配等。但是不负责真正的内存分配，因为内存是由其子类管理，所以只定义这些分配的抽象方法。</p>
<p><strong>属性</strong><br><a id="more"></a></p>
<ul>
<li><p>MemRegion _reserved<br>描述地址空间中一块儿连续的区域，由子类负责初始化、使用。</p>
</li>
<li><p>uint _n_par_threads<br>并行线程数。</p>
</li>
<li><p>GCCause::Cause _gc_cause<br>GC原因</p>
</li>
<li><p>GCCause::Cause _gc_lastcause<br>最后一次的GC原因</p>
</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><p>virtual HeapWord* allocate_new_tlab(size_t size)<br>创建一个新的TLAB，在CollectedHeap中没有实现这个方法，由子类负责实现。</p>
</li>
<li><p>inline static HeapWord<em> allocate_from_tlab(KlassHandle klass, Thread</em> thread, size_t size);<br>从TLAB里分配内存，流程如下：<br>首先调用thread对象中的_tlab（类型为：ThreadLocalAllocBuffer）的allocate方法,在TLAB上分配内存，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = thread-&gt;tlab().allocate(size)</span><br></pre></td></tr></table></figure>
<p>  如果没有分配成功，调用<code>allocate_from_tlab_slow</code>分配。 </p>
</li>
<li><p>static HeapWord<em> allocate_from_tlab_slow(KlassHandle klass, Thread</em> thread, size_t size)<br>  首先判断本TLAB中剩余内存，是否大于可以浪费的内存limit，如果大于，则不能在TLAB中分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread-&gt;tlab().<span class="built_in">free</span>() &gt; thread-&gt;tlab().refill_waste_limit()) &#123;</span><br><span class="line">   thread-&gt;tlab().record_slow_allocation(size);</span><br><span class="line">   <span class="keyword">return</span> NULL;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>  否则，计算新的TLAB的大小，新分配一个TLAB，并且为了遍历对象，把原来分配TLAB没有使用的部分清0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="keyword">new_t</span>lab_size = thread-&gt;tlab().compute_size(size);</span><br><span class="line">thread-&gt;tlab().clear_before_allocation();</span><br></pre></td></tr></table></figure>
<p>  调用<code>allocate_new_tlab</code>分配了TLAB，如果设置了ZeroTLAB，还需要进行清0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = Universe::heap()-&gt;<span class="keyword">allocate_new_t</span>lab(<span class="keyword">new_t</span>lab_size);</span><br><span class="line"><span class="keyword">if</span> (obj == NULL) &#123;</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ZeroTLAB) &#123;</span><br><span class="line">  Copy::<span class="keyword">zero_t</span>o_words(obj, <span class="keyword">new_t</span>lab_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在新的tlab上分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;tlab().fill(obj, obj + size, <span class="keyword">new_t</span>lab_size);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static HeapWord* common_mem_allocate_noinit(KlassHandle klass, size_t size, TRAPS)<br>  分配对象内存。<br>  首先在tlab中分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">  result = <span class="keyword">allocate_from_t</span>lab(klass, THREAD, size);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    assert(!HAS_PENDING_EXCEPTION,</span><br><span class="line">           <span class="string">"Unexpected exception, will result in uninitialized storage"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  分配不成功，调用当前CollectedHeap的mem_allocate方法，这个是个虚函数，由具体的子类实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = Universe::heap()-&gt;mem_allocate(size,</span><br><span class="line">                                        &amp;gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>inline static HeapWord* common_mem_allocate_init(KlassHandle klass, size_t size, TRAPS)<br>分配并初始化对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_noinit(klass, size, CHECK_NULL);</span><br><span class="line">init_obj(obj, size);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static HeapWord* common_permanent_mem_allocate_noinit(size_t size, TRAPS)<br>在Perm段分配内存。<br>调用虚函数<code>permanent_mem_allocate</code>进行分配，这个函数由子类实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* result = Universe::heap()-&gt;permanent_mem_allocate(size);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果失败，报告oom。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_java_out_of_memory(<span class="string">"PermGen space"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>inline static HeapWord* common_permanent_mem_allocate_init(size_t size, TRAPS)<br>在Perm段分配内存，并初始化。<br>调用common_permanent_mem_allocate_noinit，并初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_permanent_mem_allocate_noinit(size, CHECK_NULL);</span><br><span class="line">init_obj(obj, size);</span><br></pre></td></tr></table></figure>
</li>
<li><p>static oop Class_obj_allocate(KlassHandle klass, int size, KlassHandle real_klass, TRAPS)<br>  分配并且初始化class对象，即创建mirror class时使用。在jdk7里，class对象从PermGen移到了Heap里，可以通过-XX:+JavaObjectsInPerm，使其还在PermGen分配。</p>
<p>  首先在合适位置分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (JavaObjectsInPerm) &#123;</span><br><span class="line">  obj = common_permanent_mem_allocate_init(size, CHECK_NULL);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  assert(ScavengeRootsInCode &gt; <span class="number">0</span>, <span class="string">"must be"</span>);</span><br><span class="line">  obj = common_mem_allocate_init(real_klass, size, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  初始化并且互相设置引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">post_allocation_setup_common(klass, obj);</span><br><span class="line">assert(Universe::is_bootstrapping() ||</span><br><span class="line">       !((oop)obj)-&gt;blueprint()-&gt;oop_is_array(), <span class="string">"must not be an array"</span>);</span><br><span class="line">NOT_PRODUCT(Universe::heap()-&gt;check_for_bad_heap_word_value(obj, size));</span><br><span class="line">oop mirror = (oop)obj;</span><br><span class="line"></span><br><span class="line">java_lang_Class::set_oop_size(mirror, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup indirections</span></span><br><span class="line"><span class="keyword">if</span> (!real_klass.is_null()) &#123;</span><br><span class="line">  java_lang_Class::set_klass(mirror, real_klass());</span><br><span class="line">  real_klass-&gt;set_java_mirror(mirror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static oop obj_allocate(KlassHandle klass, int size, TRAPS)<br>分配对象内存，并初始化.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);</span><br><span class="line">post_allocation_setup_obj(klass, obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static oop array_allocate(KlassHandle klass, int size, int length, TRAPS)<br>分配数组内存，并初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);</span><br><span class="line">post_allocation_setup_array(klass, obj, length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static oop array_allocate_nozero(KlassHandle klass, int size, int length, TRAPS)<br>分配数组内存，不初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_noinit(klass, size, CHECK_NULL);</span><br><span class="line">((oop)obj)-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">post_allocation_setup_array(klass, obj, length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>virtual HeapWord<em> mem_allocate(size_t size, bool</em> gc_overhead_limit_was_exceeded) = 0;<br>真实的分配内存，纯虚函数，由子类实现。</p>
</li>
<li><p>virtual HeapWord* permanent_mem_allocate(size_t size) = 0;<br>真实的分配Perm内存，纯虚函数，由子类实现。</p>
</li>
<li><p>virtual bool supports_inline_contig_alloc() const<br>必须满足，在堆中必须有一块儿连续的空间，可用范围由top_addr()，end_addr()决定的，并且可以靠移动top_addr来分配内存。由子类实现。</p>
</li>
<li><p>virtual HeapWord** top_addr() const<br>见supports_inline_contig_alloc</p>
</li>
<li><p>virtual HeapWord** end_addr() const<br>见supports_inline_contig_alloc</p>
</li>
<li><p>virtual void ensure_parsability(bool retire_tlabs)<br>在解析heap之前调用，在这个类里负责调用tlab的相关方法，剩下的由子类实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (JavaThread *thread = Threads::first(); thread; thread = thread-&gt;next()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">use_t</span>lab) thread-&gt;tlab().make_parsable(<span class="keyword">retire_t</span><span class="built_in">labs</span>);</span><br><span class="line"><span class="preprocessor">#ifdef COMPILER2</span></span><br><span class="line">     <span class="comment">// The deferred store barriers must all have been flushed to the</span></span><br><span class="line">     <span class="comment">// card-table (or other remembered set structure) before GC starts</span></span><br><span class="line">     <span class="comment">// processing the card-table (or other remembered set).</span></span><br><span class="line">     <span class="keyword">if</span> (deferred) flush_deferred_store_barrier(thread);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">     assert(!deferred, <span class="string">"Should be false"</span>);</span><br><span class="line">     assert(thread-&gt;deferred_card_mark().is_empty(), <span class="string">"Should be empty"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>virtual size_t unsafe_max_alloc() = 0;<br>返回在不触发垃圾收集和扩展的情况下，最大能分配的内存。</p>
</li>
<li><p>virtual bool supports_tlab_allocation()<br>是否支持TLAB.</p>
</li>
<li><p>virtual size_t tlab_capacity(Thread *thr)<br>TLAB可以使用的内存大小。</p>
</li>
<li><p>virtual size_t unsafe_max_tlab_alloc(Thread *thr) const<br>返回在不触发垃圾收集和扩展的情况下，最大能在TLAB分配的内存。</p>
</li>
<li><p>virtual void collect(GCCause::Cause cause) = 0<br>提供了垃圾收集的对外接口，供“System.gc”等调用。</p>
</li>
</ul>
<h2 id="CollectorPolicy">CollectorPolicy</h2><p>CollectorPolicy及其子类用来定义垃圾收集的属性。</p>
<p><strong>属性</strong><br>PermanentGenerationSpec *_permanent_generation</p>
<blockquote>
<p>PermanentGenerationSpec<br>size_t           _init_size<br>由PermSize参数决定，缺省为ScaleForWordSize(16<em>M)。<br>size_t           _max_size<br>由MaxPermSize参数决定，缺省为ScaleForWordSize(64</em>M)<br>size_t           _read_only_size<br>由SharedReadOnlySize参数决定，缺省为10M<br>size_t           _read_write_size<br>由SharedReadWriteSize参数确定，缺省13M<br>size_t           _misc_data_size<br>由SharedReadWriteSize参数确定，缺省5M<br>size_t           _misc_code_size<br>由SharedMiscCodeSize参数确定，缺省4M<br>bool             _enable_shared_spaces<br>在client模式下，如果是serial模式的垃圾收集。为了提高启动速度，和减少占用空间。如果jre是通过installer安装的，那么在安装的时候，installer会把一些核心的类，以一种内部格式的形式，dump到client/classes.jsa中，以后启动&gt;时，直接加载这个文件即可。如果不是用installer安装的，可以使用java -Xshare:dump生成，或者运行share模式时，自动生成。我们关注的是server模式，所以不多讨论。</p>
</blockquote>
<p>size_t _max_heap_byte_size<br>如果设置了-Xmx，则为设置值。<br>如果没有设置-Xmx，通过下列几步得到：</p>
<ol>
<li>MaxHeapSize最初的缺省值为：<code>ScaleForWordSize(96*M)</code><br>如果主机内存太小，小于<code>MaxHeapSize * MinRAMFraction(缺省为2）</code>，即大概为250m左右。 MaxHeapSize设置为<code>内存大小/MinRAMFraction</code>,即内存的一半。<br>如果不是内存太小的情况，设置为<code>phys_mem / MaxRAMFraction(缺省为4)</code>和 缺省的MaxHeapSize两者之中较大的。即为内存的四分之一，最小<code>ScaleForWordSize(96*M)</code>。</li>
<li>如果使用UseCompressedOops，还需要考虑不能超过compressedOops能表示的地址范围，这个值大约30多G，所以一般没什么影响。</li>
<li>如果按上述规则得到的值，小于设置的-Xms值，设置为-Xms的大小。</li>
</ol>
<p>size_t _initial_heap_byte_size<br>如果设置了-Xms，则为此值。<br>如果没有设置-Xms，则：设置为<code>内存大小/InitialRAMFraction(缺省为64)</code>，但是这个值不能小于<code>OldSize（缺省大小ScaleForWordSize(4*M)) + NewSize（缺省大小ScaleForWordSize(1*M))</code>,同时也不能大于前面计算的MaxHeapSize。</p>
<p>size_t _min_heap_byte_size<br><code>OldSize（缺省大小ScaleForWordSize(4*M)) + NewSize（缺省大小ScaleForWordSize(1*M))</code></p>
<p><strong>方法</strong><br>virtual GenRemSet* create_rem_set(MemRegion reserved, int max_covered_regions)<br>建立Remember Set。目前没有子类重新实现这个方法，都使用CollectorPolicy中的这个方法。<br>目前只处理CardTable实现方式，用于跨代指针处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CardTableRS* res = <span class="keyword">new</span> CardTableRS(whole_heap, max_covered_regions);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>virtual HeapWord<em> mem_allocate_work(size_t size,  bool is_tlab, bool</em> gc_overhead_limit_was_exceeded)<br>由子类实现，在描述各种收集方法时再描述。请关注<a href="http://jangzq.info/">Jangzq技术研究</a></p>
<p>virtual HeapWord *satisfy_failed_allocation(size_t size, bool is_tlab)<br>由子类实现，在描述各种收集方法时再描述，请关注<a href="http://jangzq.info/">Jangzq技术研究</a></p>
<h2 id="GC参数">GC参数</h2><p>gc参数对应的CollectorPolicy和CollectedHeap如下：</p>
<table>
<thead>
<tr>
<th>GC参数</th>
<th>CollectorPolicy</th>
<th>CollectedHeap</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>MarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>MarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC -XX:+UseAdaptiveSizePolicy</td>
<td>ASConcurrentMarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>ConcurrentMarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1CollectorPolicy</td>
<td>G1CollectedHeap</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>hotspot的垃圾收集框架有两个主要的组成部分，其一是CollectedHeap、其一是CollectorPolicy。根据不同的启动参数，hotspot选择相应的Heap和Policy。<br>首先我们看一下类图，看一下有多少种CollectedHeap和CollectorPolicy。</p>
<p><img src="/images/heap_policy.png" alt="类图"></p>
<p>下面列出的是CollectorPolicy和CollectedHeap的关键属性和方法，我们以此来看一下Policy和Heap各自的特性。</p>
<h2 id="CollectedHeap">CollectedHeap</h2><p>CollectedHeap是java堆在hotspot中的体现，根据垃圾收集算法的不同，具有不同类型的子类，CollectedHeap的主要功能是分配内存，在这个父类里实现的主要是分配的流程，包括TLAB、其它分配等。但是不负责真正的内存分配，因为内存是由其子类管理，所以只定义这些分配的抽象方法。</p>
<p><strong>属性</strong><br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[classpath中没用到的jar的影响]]></title>
    <link href="http://jangzq.info/2015/07/02/classpath_jar/"/>
    <id>http://jangzq.info/2015/07/02/classpath_jar/</id>
    <published>2015-07-02T13:19:16.000Z</published>
    <updated>2015-07-02T13:28:07.000Z</updated>
    <content type="html"><![CDATA[<p>有时，我们的classpath中包含很多并没有用到的jar，这些jar有什么影响，影响大不大，下面分析一下。<br>通过阅读源码，发现在打开jar文件的时候，调用了下面这个方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jzfile *  ZIP_Put_In_Cache0(<span class="keyword">const</span> <span class="keyword">char</span> *name, ZFILE zfd, <span class="keyword">char</span> **pmsg, jlong lastModified, jboolean usemmap)</span><br></pre></td></tr></table></figure></p>
<p>在这个方法里，调用<code>static jlong readCEN(jzfile *zip, jint knownTotal)</code>方法“读取”了zip的central directory部分，里面关键的一句为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mappedAddr = mmap64(<span class="number">0</span>, zip-&gt;mlen, PROT_READ, MAP_SHARED, zip-&gt;zfd, (<span class="keyword">off64_t</span>) offset)</span><br></pre></td></tr></table></figure></p>
<p>即：将zip的 central directory部分进行了文件映射。上文中“读取”两字，我加了引号，就是因为并不是真正的读取了这块儿内容，而是采用文件映射的方式，将文件的这部分内容映射进了内存空间。这个方法里有一处值得我们注意，即是用了MAP_SHARED参数，即这一块儿空间是和其他进程共享的。<br>在JDK6之前，map了这个jar文件，这样占用了大量的地址空间（并没有占用内存），所以改为只映射 central directory，因为 central directory中包含检索包含文件的全部信息。<br>通过pmap，我们可以看到内存映射：</p>
<blockquote>
<p>00007f7bb818a000  63960K ——-   [ anon ]<br>00007f7bbc00a000      8K r—s- axis-ant-1.2.1.jar<br>00007f7bbc00c000      8K r—s- asm-attrs.jar<br>00007f7bbc00e000     20K r—s- antlr-2.7.6rc1.jar<br>00007f7bbc013000     28K r—s- ant-1.4.1.jar<br>00007f7bbc01a000     52K r—s- acegi-security-1.0.7.jar<br>00007f7bbc027000     44K r—s- charsets.jar<br>00007f7bbc032000   5968K rw—-   [ anon ]<br>00007f7bbc606000   1788K r—s- rt.jar<br>00007f7bbc7c5000   5264K rw—-   [ anon ]</p>
</blockquote>
<p>通过上述分析，我们可以得到如下结论：</p>
<ul>
<li>classpath包含的jar，会把 central directory映射到内存中去，在load class时会进行访问，所以会占用内存。如果jar文件较多，而且比较大，也会占用不少空间。</li>
<li>对于一台主机上的不同java进程，引用相同的jar，最好使用同一个文件，这样会共享同一块内存，减少内存占用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时，我们的classpath中包含很多并没有用到的jar，这些jar有什么影响，影响大不大，下面分析一下。<br>通过阅读源码，发现在打开jar文件的时候，调用了下面这个方法。<br><figure class="highlight c"><table><tr><td c]]>
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HotSpot的TLAB实现解析]]></title>
    <link href="http://jangzq.info/2015/06/28/tlab/"/>
    <id>http://jangzq.info/2015/06/28/tlab/</id>
    <published>2015-06-28T09:12:50.000Z</published>
    <updated>2015-06-28T09:12:59.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文解析了TLAB的实现机制，最后讨论了如何利用TLAB机制，进行高效程序设计，如果你对原理不感兴趣，也请看下<strong>启示</strong>部分。</p>
<p>内存分配是虚拟机最常见的操作之一，所以处理效率高低对整体性能有很大的影响。同时，虚拟机是一个多线程的运行环境，内存分配也不可避免的受到并发的制约，而锁又是造成性能下降的主因之一，即使使用CAS，对于如此频繁的操作也是巨大的性能负担。<br>一个自然而然的想法是将内存分为几个部分，每个线程只使用自己的内存区域，这样内存分配就不用进行同步，当然能达到较高的效率，TLAB就是这种想法的产物。每一个线程都有自己的一片内存区域，这片区域就叫<strong>TLAB(Thread Local alloc Buffer)</strong>，虚拟机的任务就是合理的分配TLAB的大小，使内存分配都尽量在TLAB中完成，以达到更高的效率。</p>
<h2 id="TLAB机制解析">TLAB机制解析</h2><p>hotspot用Thread类（Thread.cpp，不是java类）来描述一个线程，在Thread类里有一个<code>ThreadLocalAllocBuffer _tlab</code>变量，表征这个线程的tlab。在ThreadLocalAllocBuffer 类里，有三个属性描述了tlab的范围及使用情况，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* _start;      <span class="comment">//当前tlab的起始地址</span></span><br><span class="line">HeapWord* <span class="keyword">_t</span>op;        <span class="comment">//最后一次在tlab上分配内存后的指针位置。</span></span><br><span class="line">HeapWord* _end;       <span class="comment">//tlab的结束地址。</span></span><br></pre></td></tr></table></figure></p>
<p>采用这样的方法，首先要考虑，给每个线程的TLAB分配多大空间。分配大了，别的线程又无法使用，造成了浪费；分配小了，剩余的空间不够分配的时候，还需要采用别的方式分配。每个线程需要分配的内存是不同的，有的线程需要分配的内存多，有的现场分配的内存少，给所有线程分配同样大小的TLAB空间显然是不适合的。另外，一个线程不同的时间可能有不同的内存要求，这段时间使用内存多，过一会儿又少了，所以给一个线程固定的TLAB空间显然也是不适合的。也就是，需要解决下面两个问题：1）一个线程的TLAB初始时分配多大。2）什么时候进行动态调整，调整成多大。本文将围绕这两个问题，深入hotspot源码，探究答案。</p>
<h3 id="初始分配">初始分配</h3><a id="more"></a>
<p>当一个线程刚刚创建的时候，虚拟机这个线程的行为习惯一无所知，所以需要给它分配一个初始值。最简单的情况是，在启动虚拟机的时候通过<code>TLABSize</code>参数进行指定，需要注意的是，这个参数指定的值，也就是这时候使用一次，以后的TLAB大小和这个值就无关了（见<code>ThreadLocalAllocBuffer::initial_desired_size</code>方法）。如果没有指定这个值，虚拟机就需要自行决定给这个现场分配TLAB的大小了，显而易见，一个线程TLAB应该分配多少，和三个参数有关，一个是<strong>线程总数</strong>，线程越多，每个线程能分配的就越少；另一个参数就是<strong>可供分配的总空间</strong>；不可能把所有的可分配的空间都分配给线程做TLAB，如果这样分配，当一个线程的TLAB不够分配的时候，又没有别的适合分配的空间，势必造成gc，导致别的线程没有使用的TLAB造成了浪费，所以最后一个参数是<strong>每次分配的比例</strong>，这个比例越大，当gc时候，没使用的造成的浪费就越大。这里有一个例外情况，当这个线程是主线程的时候，这个时候heap还没有创建，所以hotspot给它分配了一个缺省值2K，这个值可以由启动参数<code>MinTLABSize</code>指定（见<code>ThreadLocalAllocBuffer::initial_desired_size</code>方法）。<br>当线程不是主线程的时候，就需要结合上面提到的三个参数，确定合适的值。首要问题是这两个值怎么得到，下面首先讨论线程数。由于TLAB分配后要使用一段时间，所以使用当时的线程数是没有意义的，所以在hotspot中，使用的线程数是一种自适应的加权平均的线程数（<code>GlobalTLABStats</code>的<code>_allocating_threads_avg</code>变量，类型是<code>AdaptiveWeightedAverage</code>）。hotspot在每次gc前，统计当前线程中从上次gc以来，曾经使用过TLAB的线程数，用这个线程数和过去得到的历史值进行一个加权平均，即<code>(100.0 - weight) * 历史平均值 / 100.0 + weight * 当前采样值 / 100.0</code>。公式中的weight由<code>TLABAllocationWeight</code>参数决定，如果不设置的话，缺省是35。（线程数的计算过程，见程序<code>ThreadLocalAllocBuffer::accumulate_statistics_before_gc</code>）。<br>第二个参数：可供分配的总空间，在hotspot中，调用<code>CollectedHeap</code>的<code>tlab_capacity</code>函数得到可供tlab分配的总空间，这个函数是一个虚函数，依赖于具体的实现。在采用分代的gc方法时，这个值是整个eden的大小（见<code>DefNewGeneration::tlab_capacity</code>）。<br>最后一个参数：一次分配的比例。在hotspot中通过eden可以浪费的百分比（Percentage of Eden that can be wasted）来指定，虚拟机参数为：<code>TLABWasteTargetPercent</code>。这个值缺省为1，即在gc的时候，已经分配给TLAB，还没有使用的内存，不应该超过eden的1%，所以一次分配eden的2%，当gc的时候，从概率上说，有一半的还没有用，所以浪费了1%，也就是说，一次分配的比例，应该是<code>TLABWasteTargetPercent*2</code>，在hotspot中，将<code>100/(TLABWasteTargetPercent*2）</code>称为<code>_target_refills</code>，即希望在<code>_target_refills</code>次分配后，分配完所有的空间，这个值仅是”期望“，并没有任何的硬性限制。<br>确定了三个参数后，一个线程最初分配的tlab的大小即：<code>可供分配的总空间/(线程数*_target_refills)</code>，在hotspot中，这个值叫做<code>desired_size</code>。（见<code>ThreadLocalAllocBuffer::initial_desired_size</code>方法）</p>
<h3 id="动态调整">动态调整</h3><p>解决了线程TLAB初始分配的问题后，我看看看hotspot如何使用tlab，我们看的代码在：<code>CollectedHeap::common_mem_allocate_noinit</code>。其实，当hotspot用new指令生成对象的时候，通常情况下不会执行到这个方法，hotspot会使用快速分配，首先使用tlab，从当前的线程的tlab的<code>top</code>指针开始分配指定大小的内存，直接修改<code>top</code>指针即可，如果分配的内存大于当前tlab还剩下来的空间，则需要在eden上非tlab的空间进行分配，当然这个过程就需要使用CAS来保证（这个不是本文的研究内容，所以略过），当使用慢速分配或者分配数组的空间时，就会执行<code>CollectedHeap::common_mem_allocate_noinit</code>这个方法。在这个方法里，调用了<code>allocate_from_tlab</code>，顾名思义，即在Tlab上进行分配，只不过这个方法在TLAB空间不够的情况下，会分配新的TLAB空间。由于在Eden中，内存的分配是连续的，所以不能扩大一个已有的TLAB的大小，只有新建一个，这样还没有使用的内存就浪费了，所以并不是每次TLAB不够分配的时候，都会分配新的TLAB，在hotspot中，会查看TLAB剩余的大小，是否小于一个阈值，如果大于这个阈值，那么就不会新分配一个TLAB，而是不在TLAB分配内存，否则就新建一个TLAB。这个阈值由两个JDK参数控制: <code>TLABRefillWasteFraction</code>和<code>TLABWasteIncrement</code>，最初，等于<code>desired_size/TLABRefillWasteFraction</code>，<code>TLABRefillWasteFraction</code>缺省为64，当每一次不成功的分配，这个阈值增长<code>TLABWasteIncrement</code>，单位是<code>HeapWordSize</code>。在丢弃原来的TLAB时，调用<code>make_parsable</code>将剩余的空间填上对象，这个是便于gc时使用。</p>
<p>在TLAB的设计中，处处体现了动态调整的思想。给每个线程分配的TLAB空间并不是一成不变的，这个调整的时机就是GC的时候。当GC后，hotspot会调整所有TLAB的大小，调整的依据当然是每个线程过去对于TLAB的使用情况，同上文中的“线程数”的计算思路一致，也是采用加权平均的方法。<code>ThreadLocalAllocBuffer</code>类的<code>_allocation_fraction</code>变量即代表了这个加权平均值，采样的是：线程的TLAB占所有已经使用的内存的比例（<code>ThreadLocalAllocBuffer::accumulate_statistics</code>）。具体实现细节就不需赘述了，请自行参考源代码(<code>ThreadLocalAllocBuffer::resize</code>)。</p>
<h3 id="结论">结论</h3><p>可以看出，hotspot的TLAB实现中的各种手段，都是为了达到“尽量少的浪费空间”和“尽可能多在TLAB中分配”的平衡，如果一个线程的TLAB分配的空间过大，造成别的线程分配内存不够用，引起gc，造成了空间的浪费；如果分配的过小，造成在TLAB中无法分配，只能在share eden中分配，造成使用CAS等同步操作。所以hotspot采用一种自适应的方式，根据一个线程的过往行为，动态的调整其TLAB大小，力争达到最优的结果。</p>
<h2 id="启示">启示</h2><p>首先，不讨论线程创建的开销，即使从TLAB的角度来看，频繁的生成短生命周期的线程是不可取的，因为hotspot费劲力气设计的“动态调整TLAB”算法，在这种情况下根本用不上，回回只能用初始的值，不能保证内存分配的效果。所以我们一定要使用接近固定的线程池。 其次，尽量的保证每个线程里的行为特征比较固定，让程序的行为能被jvm所侦知，否则基于统计的大小预测效果不会太好，造成大量的TLAB浪费，更加频繁的gc。最后，说句题外话，这应该是一切程序开发的准则，按照“底层依赖系统”期望你的行为去执行，才能达到最高效率，软硬都是如此，比如cpu的cache、比如cpu的指令预取，linux文件预读…….。如果辜负了“底层依赖系统”的期望，轻则效率低，重则踩坑，焉能不慎乎？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文解析了TLAB的实现机制，最后讨论了如何利用TLAB机制，进行高效程序设计，如果你对原理不感兴趣，也请看下<strong>启示</strong>部分。</p>
<p>内存分配是虚拟机最常见的操作之一，所以处理效率高低对整体性能有很大的影响。同时，虚拟机是一个多线程的运行环境，内存分配也不可避免的受到并发的制约，而锁又是造成性能下降的主因之一，即使使用CAS，对于如此频繁的操作也是巨大的性能负担。<br>一个自然而然的想法是将内存分为几个部分，每个线程只使用自己的内存区域，这样内存分配就不用进行同步，当然能达到较高的效率，TLAB就是这种想法的产物。每一个线程都有自己的一片内存区域，这片区域就叫<strong>TLAB(Thread Local alloc Buffer)</strong>，虚拟机的任务就是合理的分配TLAB的大小，使内存分配都尽量在TLAB中完成，以达到更高的效率。</p>
<h2 id="TLAB机制解析">TLAB机制解析</h2><p>hotspot用Thread类（Thread.cpp，不是java类）来描述一个线程，在Thread类里有一个<code>ThreadLocalAllocBuffer _tlab</code>变量，表征这个线程的tlab。在ThreadLocalAllocBuffer 类里，有三个属性描述了tlab的范围及使用情况，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* _start;      <span class="comment">//当前tlab的起始地址</span></span><br><span class="line">HeapWord* <span class="keyword">_t</span>op;        <span class="comment">//最后一次在tlab上分配内存后的指针位置。</span></span><br><span class="line">HeapWord* _end;       <span class="comment">//tlab的结束地址。</span></span><br></pre></td></tr></table></figure></p>
<p>采用这样的方法，首先要考虑，给每个线程的TLAB分配多大空间。分配大了，别的线程又无法使用，造成了浪费；分配小了，剩余的空间不够分配的时候，还需要采用别的方式分配。每个线程需要分配的内存是不同的，有的线程需要分配的内存多，有的现场分配的内存少，给所有线程分配同样大小的TLAB空间显然是不适合的。另外，一个线程不同的时间可能有不同的内存要求，这段时间使用内存多，过一会儿又少了，所以给一个线程固定的TLAB空间显然也是不适合的。也就是，需要解决下面两个问题：1）一个线程的TLAB初始时分配多大。2）什么时候进行动态调整，调整成多大。本文将围绕这两个问题，深入hotspot源码，探究答案。</p>
<h3 id="初始分配">初始分配</h3>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[overcommit_memory深入解析]]></title>
    <link href="http://jangzq.info/2015/06/27/overcommit_memory/"/>
    <id>http://jangzq.info/2015/06/27/overcommit_memory/</id>
    <published>2015-06-27T15:32:52.000Z</published>
    <updated>2015-06-28T09:14:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文从内核角度分析了内核参数<code>overcommit_memory</code>的影响，并给出了如何应用此参数的建议意见。</p>
<h2 id="实例">实例</h2><p>首先，从一个实例开始：<br><strong>操作系统： </strong></p>
<blockquote>
<p>linux 2.6.38</p>
</blockquote>
<p><strong>JDK版本：</strong></p>
<blockquote>
<p>java version “1.6.0_30”<br>Java(TM) SE Runtime Environment (build 1.6.0_30-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 20.5-b03, mixed mode)</p>
</blockquote>
<p>现象：启动java进程的时候，报如下的错误后退出</p>
<blockquote>
<p>Error occurred during initialization of VM<br>Could not reserve enough space for object heap<br>Could not create the Java virtual machine.</p>
</blockquote>
<p>疑惑：粗略的考虑一下，linux是使用虚拟内存的，而且linux分配给进程内存时候，只是分配一个地址空间，并不是马上分配内存，那么是什么限制导致了java虚拟机在初始化的时候即退出呢?</p>
<h2 id="解析">解析</h2><p>首先，我们看一下java虚拟机是用什么系统调用来请求内存？<br>java虚拟机使用-Xms 和-Xmx指出java的堆的初始大小和最大大小，在java进程启动的时候，java虚拟机按照初始大小请求内存，但是虚拟机是用什么来请求内存呢？我们使用strace来看一下（我们使用 -Xms1G -Xmx1G的参数启动）：<br>得到如下输出<br><a id="more"></a><br>[pid 15854] mmap(NULL, 1159725056, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0) = -1 ENOMEM (Cannot allocate memory)<br>从以上打印我们可以看出，java虚拟机是通过mmap系统调用来请求内存的，在这里返回了-1，即ENOMEM</p>
<p>然后，我们看一下mmap的源代码，发现了在mm/mmap.c中的__vm_enough_memory方法中，判断了是否有足够内存，下面我们深入分析一下。<br>在这个函数中我们发现了导致此问题的内核参数:overcommit_memory，此参数在/proc下的文件为：/proc/sys/vm/overcommit_memory 。这个参数的解释如下：</p>
<blockquote>
<p>This file contains the kernel virtual memory accounting mode. Values are:<br>              0: heuristic overcommit (this is the default)<br>              1: always overcommit, never check<br>              2: always check, never overcommit</p>
</blockquote>
<p>检查一下这台机子上的配置，</p>
<blockquote>
<p>cat /proc/sys/vm/overcommit_memory<br>2 </p>
</blockquote>
<p>果然被设置成了2。<br>改成0后，再执行，确实就不在报错退出了。<br>我们下一步通过源码进一步分析一下各个参数值的含义。<br>当参数为1时，这时不检查，直接返回0（内存足够）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>当参数时0时，这时候先拿要请求页数和这个计算值比较：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(global_page_state(NR_FILE_PAGES)+ nr_swap_pages+global_page_state(NR_SLAB_RECLAIMABLE))*<span class="number">31</span>/<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p>即：文件缓存所占的页数+空闲的swap page数量+可以回收的SLAB的空间，然后再留下3%供root使用。<br>如果请求页数小于这个计算值，则返回0，否则把上面的计算值再加上一个值，再比较，这个值是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（global_page_state(NR_FREE_PAGES) -totalreserve_pages）*<span class="number">31</span>/<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p>空闲的内存（页数）-需要保留的内存（必须保留备用的内存），再留下3%供root使用的。<br>通过上面的公式可以看出，在这个参数的情况下，操作系统就是看一下还可用的页（包括swap中和内存中的）是否能满足这次请求的内存，而不管别的进程是否已经请求了很大的内存。这实际是存在风险的，因为虚拟内存已经申请，只是暂时没用，等大家一起使用内存的时候，内存有可能不够用，就会造成OOM-killed进程来终止进程了。<br>为什么需要分以上两步，这是因为历史原因，在以前的版本，nr_free_pages()开销比较大，所以先比较第一步，如果第一步不能满足才比较第二步，2.6.38的代码中，这个函数也是直接取计数器的值了，所以开销应该不大了。</p>
<p>当参数时2时，这时操作系统是拿所有进程请求的(commit)的内存，和一个阈值比较，这个阈值为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（(totalram_pages - <span class="keyword">hugetlb_t</span>otal_pages()) * sysctl_overcommit_ratio / <span class="number">100</span>）*<span class="number">31</span>/<span class="number">32</span>+total_swap_pages</span><br></pre></td></tr></table></figure></p>
<p>含义是：(所有的内存-大页面所占的内存)然后，乘上<code>sysctl_overcommit_ratio</code>设定的百分比，保留给root用的之后，加上swap的大小。<br>即：所有进程的虚拟内存申请量不能大于 所有内存（除去大页面内存）*<code>sysctl_overcommit_ratio</code>，在加上swap的大小。<code>sysctl_overcommit_ratio</code>这个名称现在似乎名不符实，是不是？</p>
<h2 id="结论">结论</h2><p>这两个内核参数应当谨慎设置，以免引起不必要的麻烦。<br>1）在生产环境里，<code>overcommit_memory</code>尽量不要设置为1，这是因为这会大大增加OOM-killed的几率，增加了整个系统的不稳定性。<br>2）如果运行的应用程序的内存可以预测，如数据库，我们可以使用2，因为数据库启动后，将关键的所需内存全部申请了虚拟内存，所以可以防止在数据库主机上运行某些不重要的程序时，造成oom，导致数据库被kill，限制其它程序申请虚拟内存，还可以减少内存导入导出的可能性。<br>3）如果实在不能确定所需内存（我们尽量避免这种情况），就用0吧，但一定要考虑到oom的风险。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文从内核角度分析了内核参数<code>overcommit_memory</code>的影响，并给出了如何应用此参数的建议意见。</p>
<h2 id="实例">实例</h2><p>首先，从一个实例开始：<br><strong>操作系统： </strong></p>
<blockquote>
<p>linux 2.6.38</p>
</blockquote>
<p><strong>JDK版本：</strong></p>
<blockquote>
<p>java version “1.6.0_30”<br>Java(TM) SE Runtime Environment (build 1.6.0_30-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 20.5-b03, mixed mode)</p>
</blockquote>
<p>现象：启动java进程的时候，报如下的错误后退出</p>
<blockquote>
<p>Error occurred during initialization of VM<br>Could not reserve enough space for object heap<br>Could not create the Java virtual machine.</p>
</blockquote>
<p>疑惑：粗略的考虑一下，linux是使用虚拟内存的，而且linux分配给进程内存时候，只是分配一个地址空间，并不是马上分配内存，那么是什么限制导致了java虚拟机在初始化的时候即退出呢?</p>
<h2 id="解析">解析</h2><p>首先，我们看一下java虚拟机是用什么系统调用来请求内存？<br>java虚拟机使用-Xms 和-Xmx指出java的堆的初始大小和最大大小，在java进程启动的时候，java虚拟机按照初始大小请求内存，但是虚拟机是用什么来请求内存呢？我们使用strace来看一下（我们使用 -Xms1G -Xmx1G的参数启动）：<br>得到如下输出<br>]]>
    
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
</feed>