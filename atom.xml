<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Jangzq技术研究]]></title>
  <subtitle><![CDATA[关注代码的秘密， 记录探索点滴， 分享技术收获]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jangzq.info//"/>
  <updated>2015-08-24T14:07:30.000Z</updated>
  <id>http://jangzq.info//</id>
  
  <author>
    <name><![CDATA[Zhang Zq]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[java nio之jdk篇]]></title>
    <link href="http://jangzq.info/2015/08/24/java_nio/"/>
    <id>http://jangzq.info/2015/08/24/java_nio/</id>
    <published>2015-08-24T13:42:59.000Z</published>
    <updated>2015-08-24T14:07:30.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>java nio包括buffer，channel, selector等，最核心的即是多路复用+非阻塞读写，在本篇里，只涉及和socket相关部分的实现。</p>
<h2 id="channel">channel</h2><p>Channel类的继承关系如下（省略了channel读写相关的父类，如ReadableByteChannel等等）。<br><img src="/images/nio-channel.jpeg" alt="Channel类图"><br>通过上图，可以看出Socket相关的两个Channel，需要具备两个特性：selectable和interruptible。</p>
<h3 id="Selectable">Selectable</h3><p>selectable表示可以用来IO多路复用，在<code>AbstractSelectableChannel</code>中，保存着这个channel所有注册的SelectionKey（变量：SelectionKey[] keys），通过SelectionKey同Selector关联起来，当关闭channel时，使用这个信息，从Selector中关闭自己的监听, 表现Selectable的几个主要方法：<br><strong>public abstract int validOps()</strong><br>返回支持的操作。在ServerSocketChannel中为<code>return SelectionKey.OP_ACCEPT</code>，在SocketChannel中<code>return (SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT)</code>。</p>
<p><strong>public abstract SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException</strong><br>注册时调用的方法，将这个channel注册到指定的Selector中，关注的操作为ops，att为附件对象，当事件满足时，返回的SelectionKey里包含此对象。这个方法在AbstractSelectableChannel中实现。</p>
<ol>
<li><p>首先检查操作是否是自己关注的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查channel是否已经设置成了非阻塞，如果是阻塞的，抛出异常退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blocking)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在注册的SelectionKey（变量：SelectionKey[] keys）里查找这个Selector的对应SelectionKey，如果存在，更新其中的关注操作属性，否则调用Selector的register方法，将返回的SelectionKey保存在注册SelectionKey数组中。Selector的register方法后文介绍，这里提前说一句，在java nio中，当正在执行select阻塞，那么是无法注册新的事件的，这是因为两个操作使用同一个锁同步，在select时，进入这个锁没有退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey k = findKey(sel);</span><br><span class="line"><span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line">    k.attach(att);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// New registration</span></span><br><span class="line">    <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">        addKey(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>public abstract SelectableChannel configureBlocking(boolean block) throws IOException</strong><br>设为阻塞或者非阻塞模式，在底层，使用fcntl方法进行设置。</p>
<h3 id="interruptible">interruptible</h3><p>interruptible指的是，这个channel可以异步关闭或者interrupted，即当这个channel阻塞在一个io操作时，我们调用这个channel的close方法，会导致阻塞退出，并且抛出<code>AsynchronousCloseException</code>异常。另外，当阻塞的时候，当我们调用这个线程的interrupt()方法时，会导致阻塞退出，并且抛出ClosedByInterruptException，下面我们看看这是如何实现的，首先看<code>AbstractInterruptibleChannel</code>类。<br>在<code>AbstractInterruptibleChannel</code>类里，实现了begin和end方法，在所有阻塞操作时，都采用如下方式调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> completed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    begin();</span><br><span class="line">    completed = ...;    <span class="comment">// Perform blocking I/O operation</span></span><br><span class="line">    <span class="keyword">return</span> ...;         <span class="comment">// Return result</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    end(completed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>protected final void begin()</strong><br>在begin操作里，调用<code>blockedOn(interruptor)</code>将一个Interruptible回调注册到当前线程，当我们调用此线程的interrupt()方法时，会回调Interruptible的interrupt方法，这个方法定义如下，即调用implCloseChannel方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!open)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          open = <span class="keyword">false</span>;</span><br><span class="line">          interrupted = target;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过上述定义可以看出，interrupt时的操作和close就一致了，下面我们看看close如何终结阻塞操作，相关操作和channel的类型有关，我们看一下ServerSocketChannel的实现,在<code>ServerSocketChannelImpl</code>里，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implCloseSelectableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != ST_KILLED)</span><br><span class="line">            nd.preClose(fd);</span><br><span class="line">        <span class="keyword">long</span> th = thread;</span><br><span class="line">        <span class="keyword">if</span> (th != <span class="number">0</span>)</span><br><span class="line">            NativeThread.signal(th);</span><br><span class="line">        <span class="keyword">if</span> (!isRegistered())</span><br><span class="line">            kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述实现可以看出，是向目标线程发送信号，导致阻塞退出，关于阻塞退出block，在前面文章介绍内核实现的时候，多次提到。<code>NativeThread.signal</code>在jdk里的实现是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_kill((<span class="keyword">pthread_t</span>)thread, INTERRUPT_SIGNAL))</span><br><span class="line">    JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Thread signal failed"</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<p>在ServerSocketChannel和SocketChannel中的connect， bind, listen等操作虽然进行了重新封装，但调用系统调用等和过去的socket操作基本一样，这里不再赘述。 在输入输出函数方面，nio中用ByteBuffer重新实现，在系统调用方面使用的是write/read，不同于过去的send/recv操作，但是在内核中，最终调用的代码是一样的。nio和过去的socket的io操作，一个显著的变化是nio中支持直接使用Direct Buffer，即堆外内存。</p>
</blockquote>
</blockquote>
<h2 id="Selector—多路复用">Selector—多路复用</h2><p>Selector类的继承关系为：<br><img src="/images/nio-selector.jpeg" alt="Selector类图"></p>
<h3 id="抽象实现">抽象实现</h3><p>在这里，讲解java nio对多路复用的抽象，即和具体实现如epoll，select等无关的部分。<br>在SelectorImpl中，有两个Set，分别对应于注册的事件（HashSet<selectionkey> keys），和就绪的事件（Set<selectionkey> selectedKeys），在返回给调用者时为了防止直接修改，进行了只读封装，即<code>publicKeys = Collections.unmodifiableSet(keys)</code>和<code>publicSelectedKeys = Util.ungrowableSet(selectedKeys)</code>。在这个类里，另外需要注意的是，register、selector、close都使用publicKeys同步，说明这几个操作是同步的，具体的实现都在子类里，在后文中，将看一下epll的实现。</selectionkey></selectionkey></p>
<h4 id="register">register</h4><p><strong>protected final SelectionKey register(AbstractSelectableChannel ch,  int ops, Object attachment)</strong><br>这个方法是在Channel的regiser方法中调用的，在那里已经判断了不存在相应的SelectionKey，所以在这里新建一个SelectionKey对象，并调用子类的<code>implRegister</code>方法交给具体的实现去处理，然后，调用SelectionKey的interestOps方法关注事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</span><br><span class="line">k.attach(attachment);</span><br><span class="line"><span class="keyword">synchronized</span> (publicKeys) &#123;</span><br><span class="line">    implRegister(k);</span><br><span class="line">&#125;</span><br><span class="line">k.interestOps(ops);</span><br></pre></td></tr></table></figure></p>
<h4 id="select">select</h4><p><strong>public int select() throws IOException</strong><br>调用的是lockAndDoSelect。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (publicKeys) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</span><br><span class="line">        <span class="keyword">return</span> doSelect(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="unregister">unregister</h4><p>取消关注某一个文件，是调用SelectionKey的cancel方法，在这里面调用的<code>AbstractSelector</code>的<code>void cancel(SelectionKey k)</code>方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(SelectionKey k)</span> </span>&#123;                       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cancelledKeys) &#123;</span><br><span class="line">        cancelledKeys.add(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，并没有真正的取消，而是加到了一个cancel队列，留待以后处理，处理这个cancel队列的代码在<code>SelectorImpl</code>的<code>processDeregisterQueue</code>方法，这个方法在select操作（如select或者poll_wait）前后执行，比如在<code>EPollSelectorImpl</code>的<code>doSelect</code>中，就是如此实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processDeregisterQueue();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    begin();</span><br><span class="line">    pollWrapper.poll(timeout);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    end();</span><br><span class="line">&#125;</span><br><span class="line">processDeregisterQueue();</span><br></pre></td></tr></table></figure></p>
<p><code>processDeregisterQueue</code>方法即遍历cancle队列，依次调用<code>implDereg(SelectionKeyImpl ski)</code>，并清空cancel队列。</p>
<h4 id="修改关注的事件">修改关注的事件</h4><p>调用的是<code>SelectionKeyImpl</code>的<code>SelectionKey interestOps(int ops)</code>方法，这个方法调用的是channel的<code>void translateAndSetInterestOps(int ops, SelectionKeyImpl sk)</code>方法，最终调用的是Selector的<code>void putEventOps(SelectionKeyImpl sk, int ops)</code>方法。</p>
<h3 id="epoll实现">epoll实现</h3><p><strong>请先阅读“java nio之内核篇”</strong><br>java nio使用Selector来实现多路复用，在linux中采用的是epoll方式，实现类为<code>EPollSelectorImpl</code>， 在这部分分别介绍上一节里涉及到的操作。<br>在java中，使用<code>EPollArrayWrapper</code>封装了epoll实例，在构造函数里，调用了epoll_create方法，并且将返回的epoll实例文件描述符保存到成员变量<code>private final int epfd</code>中。</p>
<h4 id="register-1">register</h4><p><strong>protected void implRegister(SelectionKeyImpl ski)</strong><br><code>EPollArrayWrapper</code>使用<code>private final byte[] eventsLow = new byte[MAX_UPDATE_ARRAY_SIZE]</code>和<code>private Map&lt;Integer,Byte&gt; eventsHigh</code>保存注册的文件事件，如果文件描述符小于MAX_UPDATE_ARRAY_SIZE，则存放在数组里，如果大于这个值，则存放在map里。在这个方法里，其实只是修改了其中的值。</p>
<h4 id="select-1">select</h4><p><strong>protected int doSelect(long timeout) throws IOException</strong></p>
<ol>
<li>首先处理cancel队列，对于每一个SelectionKey调用<code>implDereg</code>。</li>
<li>调用EPollArrayWrapper的poll方法，在其中调用epoll_wait。<br>首先，处理变化了关注事件的文件描述符，在EPollArrayWrapper中，使用<code>int[] updateDescriptors</code>记录了关注事件变化了的文件描述符，<code>BitSet registered</code>保存了文件描述符是否已经注册了，上文中提到的<code>eventsLow</code>和<code>eventsHigh</code>中存放着现在关注的事件，使用这些信息，可以判断出调用epoll_ctl时需要的操作，即EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL，然后调用epoll_ctl。<br>然后，调用epoll_wait，在EPollArrayWrapper初始化的时候，分配了一块儿堆外内存（AllocatedNativeObject pollArray），作为epoll_wait调用传出的epoll_event数组地址，其大小为NUM_EPOLLEVENTS * SIZE_EPOLLEVENT。<br>当epoll_wait返回后，判断是否被interrupt，后文详细描述。</li>
<li>再次处理cancel队列，对于每一个SelectionKey调用<code>implDereg</code>。</li>
<li>调用<code>updateSelectedKeys</code>，将堆外的epoll_event信息，保存到java的<code>Set&lt;SelectionKey&gt; selectedKeys</code>里，并且把就绪的操作，保存到其中的SelectionKey中。</li>
</ol>
<h4 id="unregister-1">unregister</h4><p><strong>protected void implDereg(SelectionKeyImpl ski) throws IOException</strong><br>其中，最主要的操作是调用EPollArrayWrapper的remove，首先把<code>eventsLow</code>和<code>eventsHigh</code>中对应文件的event设置为KILLED。如果文件已经注册了，直接调用epoll_ctl。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kill pending and future update for this file descriptor</span></span><br><span class="line">setUpdateEvents(fd, KILLED, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove from epoll</span></span><br><span class="line"><span class="keyword">if</span> (registered.get(fd)) &#123;</span><br><span class="line">    epollCtl(epfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    registered.clear(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改关注的事件-1">修改关注的事件</h4><p><strong>void putEventOps(SelectionKeyImpl ski, int ops)</strong><br>修改关注事件时候调用，主要进行两个操作，一个是修改<code>eventsLow</code>和<code>eventsHigh</code>，另一个是修改<code>int[] updateDescriptors</code>,这两个的作用前文已经描述了。</p>
<h4 id="wakeup">wakeup</h4><p>当阻塞在epoll_wait时，可以通过此方法使其返回，在epoll的实现中，采用了如下方法。<br>在EPollSelectorImpl的构造函数里，新建了一个pipe，把这个管道的读写文件描述符，保存在<code>EPollArrayWrapper</code>的<code>incomingInterruptFD</code>，<code>outgoingInterruptFD</code>里，并且调用epoll_ctl关注incomingInterruptFD的读事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInterrupt</span><span class="params">(<span class="keyword">int</span> fd0, <span class="keyword">int</span> fd1)</span> </span>&#123;</span><br><span class="line">    outgoingInterruptFD = fd1;</span><br><span class="line">    incomingInterruptFD = fd0;</span><br><span class="line">    epollCtl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，当我们向管道里写数据的时候，则就会将epoll_wait退出等待，在调用wakeUp时，调用的本地方法如下，即向管道里写入一个字节的数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java_sun_nio_ch_EPollArrayWrapper_interrupt(JNIEnv *env, jobject <span class="keyword">this</span>, jint fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fakebuf[<span class="number">1</span>];</span><br><span class="line">    fakebuf[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(fd, fakebuf, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env,<span class="string">"write to interrupt fd failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>从上面可以看出，在java中一个Selector会占用3个文件描述符</strong>。<br>为什么不采用发送信号的方式使epoll_wait退出呢？这是因为从内核篇我们可以看出，如果收到信号，内核并不处理已经就绪的事件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>java nio包括buffer，channel, selector等，最核心的即是多路复用+]]>
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java nio之内核篇]]></title>
    <link href="http://jangzq.info/2015/08/24/nio-kernel/"/>
    <id>http://jangzq.info/2015/08/24/nio-kernel/</id>
    <published>2015-08-24T13:42:58.000Z</published>
    <updated>2015-08-24T14:05:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在本篇里，介绍了内核中epoll的相关实现，诸如epoll实例在内核中是怎么表示的，epoll_wait是怎么等待的， 文件上的就绪事件是怎么唤醒epoll_wait的，以及Level-triggered和edge-triggered怎么实现的，等等。<br>在内核中，一个epoll实例由文件表示，具有一个文件描述符。epoll实例独有的信息，由eventpoll结构体描述，存放于文件描述符的private_data变量中。这个结构体关键变量如下：<br>struct rb_root rbr：使用epoll_ctl添加到epoll实例的的文件，都存在一个epitem结构体，使用红黑树保存到这个变量中。<br>wait_queue_head_t wq：使用epoll_wait等待队列。</p>
<p>对于每一个监视文件，用一个struct epitem表示，包含如下关键属性：<br>struct list_head fllink：用这个变量把epitem连接到struct file的f_ep_links链表中，这样从struct file中就可以遍历所有相关epoll实例，在关闭文件的时候，可以使用这个链表取消这些监视。<br>struct list_head rdllink：用这个变量将epitem连接到就绪队列（eventpoll-&gt;rdllist)。</p>
<h3 id="epoll_create">epoll_create</h3><p>epoll_create的实现如下，从中可以看出size参数只要是正数，具体值无所谓。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在epoll_create1中，可以看出主要操作为：</p>
<ol>
<li><p>创建并初始化一个eventpoll结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error = ep_alloc(&amp;ep);</span><br></pre></td></tr></table></figure>
</li>
<li><p>分配一个epoll类型的文件，并把eventpoll放在private_data成员变量里，并分配fd，建立fd和文件的映射，从中可以看出epoll也受打开文件数目的限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">             O_RDWR | (flags &amp; O_CLOEXEC));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="epoll_ctl">epoll_ctl</h3><p>首先在保存epitem的红黑树中，查找需要监视的文件，然后再根据操作的不同，进行判断，即在EPOLL_CTL_ADD的情况下，如果存在是错误的，对于其他情况，不存在是错误的。然后根据操作，调用不同的方法。<br><strong>注：</strong>另外，从这段代码可以看出， POLLERR和POLLHUP是必须监视的，如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">    <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">        epds.events |= POLLERR | POLLHUP;</span><br><span class="line">        error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ep_insert">ep_insert</h4><p>当操作为EPOLL_CTL_ADD时，调用的是<code>ep_insert</code>，主要步骤为：</p>
<ol>
<li>首先，检查当前epoll实例监视的文件数，不能超过<code>/proc/sys/fs/epoll/max_user_watches</code>。</li>
<li>在eventpoll_epi slab cache中，分配epitem。</li>
<li><p>向所监视的文件注册，调用的是struct file —-&gt; file_operations    <em>f_op —-&gt;`unsigned int (</em>poll) (struct file <em>, struct poll_table_struct </em>)`方法，凡是支持poll操作的文件，这个方法指针不为null，其中poll_table_struct结构体定义如下，其中poll_queue_proc是一个回调方法，在文件的poll方法里，使用这个回调函数，将本epitem信息加入到监视file的等待队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">poll_t</span>able_struct &#123;</span><br><span class="line">    poll_queue_proc _qproc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _key;</span><br><span class="line"> &#125; <span class="keyword">poll_t</span>able</span><br><span class="line"> ``` </span><br><span class="line">  在这里这个回调函数是`ep_ptable_queue_proc`，在文件的poll函数里，调用这个函数，其中`<span class="keyword">wait_queue_head_t</span> *whead`用来传入等待队列头，在`ep_ptable_queue_proc`函数里，构造了一个等待队列成员，加入到这个队列中，这个等待队列成员包含一个回调方法，需要唤醒等待队列成员时调用，这个函数是`ep_poll_callback`，这部分在后面详细描述。</span><br><span class="line"><span class="number">4.</span> 将epitem加入到监视file的f_ep_links里，并且插入红黑树。</span><br><span class="line">  ```<span class="function">c</span><br><span class="line"> <span class="title">list_add_tail_rcu</span><span class="params">(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links)</span></span>;</span><br><span class="line">  ep_rbtree_insert(ep, epi);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果注册时返回值表明，现在已经ready了，就把此epitem连接到就绪队列（eventpoll-&gt;rdllist）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">      <span class="keyword">list_add_t</span>ail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有进程正在调用epoll_wait等待，唤醒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">          wake_up_locked(&amp;ep-&gt;wq);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="ep_remove">ep_remove</h4><p>当操作为EPOLL_CTL_DEL时，调用的是<code>ep_remove</code>，主要步骤为：</p>
<ol>
<li><p>从被监视文件的等待队列里删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep_unregister_pollwait(ep, epi);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从struct file的f_ep_links链表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_del_rcu(&amp;epi-&gt;fllink);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从epoll实例的红黑表删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果ready队列里包含此epitem，删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">  list_del_init(&amp;epi-&gt;rdllink);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="ep_modify">ep_modify</h4><p>当操作为EPOLL_CTL_MOD时，调用的是<code>ep_modify</code>，主要步骤为：</p>
<ol>
<li><p>修改epitem中的事件属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epi-&gt;event.events = event-&gt;events; <span class="comment">/* need barrier below */</span></span><br><span class="line">epi-&gt;event.data = event-&gt;data; <span class="comment">/* protected by mtx */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和新加时一样，调用监视文件的poll方法，不同的是，将本epitem信息加入到监视file的等待队列的回调函数为null，也就是得到当前是否有满足的事件，如果有的话，将自己加入到就绪队列，并唤醒等待队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   init_poll_funcptr(&amp;pt, NULL);</span><br><span class="line">   revents = ep_item_poll(epi, &amp;pt);</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">if</span> (revents &amp; event-&gt;events) &#123;</span><br><span class="line">     spin_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">     <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="keyword">list_add_t</span>ail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">     &#125;</span><br><span class="line">     spin_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="epoll_wait">epoll_wait</h3><ol>
<li>首先，确定超时时间，当timeout小于0时，无限等待，等于0时，立即返回，正数代表等待的毫秒数。</li>
<li><p>当没有就绪的事件时，把自己加入到epoll实例的等待队列中，然后开始等待，直到有就绪的事件，或者超时，或者收到信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span> (ep_events_available(ep) || timed_out)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">        res = -EINTR;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当退出等待后，见下面代码，首先将自己从等待队列删除，如果不是收到信号（!res），并且存在就绪事件（eavail），遍历就绪队列，将拷贝事件结果到用户空间，如果拷贝个数为0，并且没有超时，继续等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">  !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">  <span class="keyword">goto</span> fetch_events;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面介绍遍历就绪队列，将事件拷贝到用户空间的函数<code>ep_send_events</code>，这个函数主要调用的是<code>ep_scan_ready_list</code>。</p>
<ol>
<li><p>一次性把就绪队列全部移到一个临时队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">ep-&gt;ovflist = NULL;</span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用传入的方法将事件拷贝到用户空间，在这里为：ep_send_events_proc。<br>遍历上一步的就绪队列，处理的最大个数即传入的maxevents。对于每一个就绪队列上的epitem，调用注册文件上的poll方法，得到目前存在的就绪事件，将事件拷贝到用户空间, 如果出错，再放回就绪队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">        !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;</span><br><span class="line">       epi = list_first_entry(head, <span class="keyword">struct</span> epitem, rdllink);</span><br><span class="line">       .......</span><br><span class="line">       list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">revents = ep_item_poll(epi, &amp;pt);</span><br><span class="line">        <span class="keyword">if</span> (revents) &#123;</span><br><span class="line">           <span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">               __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">          list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">               ep_pm_stay_awake(epi);</span><br><span class="line">               <span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br></pre></td></tr></table></figure>
<p>如果设置了EPOLLONESHOT，则设置<code>epi-&gt;event.events &amp;= EP_PRIVATE_BITS</code>，下次不触发。<br>如果没有设置edge trigger（说明level trigger是缺省的），即如果没有读完，或者没有操作，会一直通知。这是通过如下机制实现的，只要本次有需要通知的事件，处理完成后，仍然将本epitem挂到就绪队列，下次调用epoll_wait时，由于首先查看就绪队列，就会处理这个epitem，如果此epitem没有就绪事件，就不再挂回去。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">    <span class="keyword">list_add_t</span>ail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当上一步处理时，新来的就绪epitem保存在ep-&gt;ovflist里，这时，如果这些epitem不在就绪队列，将它们加入到就绪队列。</p>
</li>
<li>由于处理就绪队列时有处理个数限制，所以临时队列里可能有剩余未处理的epitem，将它们重新放回就绪队列。</li>
<li>如果就绪队列不为空，唤醒等待队列。</li>
</ol>
<h3 id="就绪通知">就绪通知</h3><p>在这里，讲解如何通知epoll实例事件发生的。上文在ep_insert中，向目标文件注册时，在事件等待队列成员里设置了回调函数，当事件唤醒时，执行此函数，这个函数为：<code>ep_poll_callback</code>，首先讲解此函数，这个函数的主要功能就是如果这个epitem符合条件，加入到就绪队列，并唤醒等待在epoll_wait上的进程。</p>
<ol>
<li><p>如果设置了EPOLLONESHOT，在上文中设置了<code>EP_PRIVATE_BITS</code>,如果这种情况，直接跳过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">    <span class="keyword">goto</span> out_unlock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是不关心的事件，跳过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>) key &amp; epi-&gt;event.events))</span><br><span class="line">    <span class="keyword">goto</span> out_unlock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不在就绪队列里，加入就绪队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">    <span class="keyword">list_add_t</span>ail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    ep_pm_stay_awake_rcu(epi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒等待在epoll_wait的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line"> wake_up_locked(&amp;ep-&gt;wq);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在本篇里，介绍了内核中epoll的相关实现，诸如epoll实例在内核中是怎么表示的，epoll]]>
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之accept]]></title>
    <link href="http://jangzq.info/2015/08/24/socket_accept/"/>
    <id>http://jangzq.info/2015/08/24/socket_accept/</id>
    <published>2015-08-24T13:42:56.000Z</published>
    <updated>2015-08-24T14:02:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。</p>
<h2 id="JDK实现">JDK实现</h2><p>调用的为<code>Java_java_net_PlainSocketImpl_socketAccept</code>，如果设置了超时，则使用NET_Timeout来等待超时，或者可读，详细描述见<a href="http://jangzq.info/2015/08/06/jdk_linux_close/">自顶向下话socket之blocking io wrapper</a>，当超时或者出错，抛异常退出。<br>然后调用accept系统调用。</p>
<h2 id="linux内核实现">linux内核实现</h2><p>和accept相关的内核操作分为两部分，一部分是内核软中断上下文中的协议处理部分，即完成3次握手等协议处理，最后将连接放入request_sock_queue的rskq_accept_head链表，在进程上下文中，即调用accept系统调用时，处理此链表中的连接。下面分别描述。</p>
<h3 id="内核软中断上下文">内核软中断上下文</h3><p>在这里不展开讨论tcp协议，只是描述一下我们感兴趣的部分。在<code>tcp_rcv_state_process</code>方法里，可以看出当socket的状态为TCP_LISTEN时，如果收到syn，调用相应协议的<code>conn_request</code>方法，在这里，调用的是<code>tcp_conn_request</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line">    <span class="keyword">if</span> (th-&gt;ack)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (th-&gt;rst)</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (th-&gt;fin)</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        <span class="keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>tcp_conn_request</code>，当accept backlog满了，丢弃此包。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);</span><br><span class="line">    <span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的判断逻辑为<code>sk-&gt;sk_ack_backlog &gt; sk-&gt;sk_max_ack_backlog</code>。</p>
<h3 id="进程上下文">进程上下文</h3><p>调用inet_accept，在这个函数里，最终调用的是<code>inet_csk_accept</code>方法，这个方法里就是从request_sock_queue的rskq_accept_head链表中取出连接，如果队列为空，则根据是否阻塞模式，进行等待，或者退出，从下面代码可以看出，当为非阻塞模式时，将errno设为EAGAIN，然后退出，否则以timeout进行等待。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    <span class="keyword">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a non blocking socket don't sleep */</span></span><br><span class="line">    error = -EAGAIN;</span><br><span class="line">    <span class="keyword">if</span> (!timeo)</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">    error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之bind、listen]]></title>
    <link href="http://jangzq.info/2015/08/24/bind_listen/"/>
    <id>http://jangzq.info/2015/08/24/bind_listen/</id>
    <published>2015-08-24T13:42:55.000Z</published>
    <updated>2015-08-24T14:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>在java程序中，bind函数调用了bind和listen两个操作，由于bind比较简单，就是判断地址是否已经使用，如未使用将本地地址保存在socket里，所以不再讨论，主要看一下listen操作。</p>
<h2 id="JDK实现">JDK实现</h2><p>调用的是listen系统调用。</p>
<h2 id="linux内核实现">linux内核实现</h2><ol>
<li><p>参数中backlog如果大于<code>/proc/sys/net/core/somaxconn</code>，设置为<code>/proc/sys/net/core/somaxconn</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)backlog &gt; somaxconn)</span><br><span class="line">    backlog = somaxconn;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用<code>inet_listen</code>，使用backlog参数初始化icsk_accept_queue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rc = reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue, <span class="keyword">nr_t</span>able_entries);</span><br></pre></td></tr></table></figure>
<p>在这个函数里，给request_sock_queue的struct listen_sock  *listen_opt分配内存，首先确定分配的对象个数，代码很清晰，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nr_t</span>able_entries = <span class="keyword">min_t</span>(u32, <span class="keyword">nr_t</span>able_entries, sysctl_max_syn_backlog);</span><br><span class="line"><span class="keyword">nr_t</span>able_entries = <span class="keyword">max_t</span>(u32, <span class="keyword">nr_t</span>able_entries, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">nr_t</span>able_entries = <span class="keyword">roundup_pow_of_t</span>wo(<span class="keyword">nr_t</span>able_entries + <span class="number">1</span>);</span><br><span class="line">lopt_size += <span class="keyword">nr_t</span>able_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request_sock *);</span><br></pre></td></tr></table></figure>
<p>分配内存，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          </span><br><span class="line"><span class="keyword">if</span> (lopt_size &lt;= (PAGE_SIZE &lt;&lt; PAGE_ALLOC_COSTLY_ORDER))</span><br><span class="line">    lopt = kzalloc(lopt_size, GFP_KERNEL |</span><br><span class="line">                  __GFP_NOWARN |</span><br><span class="line">                  __GFP_NORETRY);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之close]]></title>
    <link href="http://jangzq.info/2015/08/24/socket_close/"/>
    <id>http://jangzq.info/2015/08/24/socket_close/</id>
    <published>2015-08-24T13:42:53.000Z</published>
    <updated>2015-08-24T13:59:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>在本篇将讨论socket的关闭。</p>
<h2 id="JDK实现">JDK实现</h2><p>socket.close方法，调用的本地方法<code>Java_java_net_PlainSocketImpl_socketClose0</code>，其中调用的是<code>NET_SocketClose</code>，详情见<a href="http://jangzq.info/2015/08/06/jdk_linux_close/">自顶向下话socket之blocking io wrapper</a>， 在其中调用的是close系统调用。</p>
<h2 id="linux内核实现">linux内核实现</h2><p><strong>本文并不关注于关闭时的4次握手，而只关注开发网络程序相关内容。</strong><br>close是文件系统子系统的系统调用，所以遵循文件子系统close的规则，当打开的文件的引用大于1时，只是减少引用，并不关闭，这部分由于是vfs子系统内容，以后有机会再详细描述。最终调用的是<code>sock_release</code>，然后调用<code>inet_release</code>，在这个函数里，如果socket设置了SOCK_LINGER参数，则使用相关参数调用<code>tcp_close</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp;</span><br><span class="line">    !(current-&gt;flags &amp; PF_EXITING))</span><br><span class="line">    timeout = sk-&gt;sk_lingertime;</span><br><span class="line">sock-&gt;sk = NULL;</span><br><span class="line">sk-&gt;sk_prot-&gt;close(sk, timeout);</span><br></pre></td></tr></table></figure></p>
<p>下面介绍<code>tcp_close</code>：</p>
<ol>
<li><p>丢弃接收队列中的skb,如果存在丢弃的数据，向对端发送RST。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != NULL) &#123;</span><br><span class="line">      u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">          len--;</span><br><span class="line">      data_was_unread += len;</span><br><span class="line">      __kfree_skb(skb);</span><br><span class="line">  &#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">if</span> (data_was_unread) &#123;</span><br><span class="line">      <span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">      NET_INC_STATS_USER(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">      tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">      tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果设置了SO_LINGER，如下一直等待到timeout，或者发送完数据和FIN后，状态不为“ (TCPF_FIN_WAIT1 | TCPF_CLOSING | TCPF_LAST_ACK)”，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sk_stream_wait_close</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">long</span> timeout)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        DEFINE_WAIT(wait);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">prepare_t</span>o_wait(sk_sleep(sk), &amp;wait,</span><br><span class="line">                    TASK_INTERRUPTIBLE);</span><br><span class="line">            <span class="keyword">if</span> (sk_wait_event(sk, &amp;timeout, !sk_stream_closing(sk)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!signal_pending(current) &amp;&amp; timeout);</span><br><span class="line"></span><br><span class="line">        finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之缓存区内存分配限制]]></title>
    <link href="http://jangzq.info/2015/08/24/socket_buf/"/>
    <id>http://jangzq.info/2015/08/24/socket_buf/</id>
    <published>2015-08-24T13:42:52.000Z</published>
    <updated>2015-08-24T13:58:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>注：简单起见，不考虑cgroup情况。<br>在这里，讨论当需要分配一个新的skb时，需要满足的限制，相关代码在：<code>int __sk_mem_schedule(struct sock *sk, int size, int kind)</code>。</p>
<h2 id="整体内存限制">整体内存限制</h2><p>首先需要满足一个整体内存限制。在proto结构体里，<code>atomic_long_t       *memory_allocated</code>存放着当前分配的内存数。在TCP协议里，这个内存数受<code>sysctl_tcp_mem</code>限制，此变量在tcp_init_mem中初始化，可以通过<em>/proc/sys/net/ipv4/tcp_mem</em>修改，初始值代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">tcp_init_mem</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> limit = nr_free_buffer_pages() / <span class="number">8</span>;</span><br><span class="line">    limit = max(limit, <span class="number">128U</span>L);</span><br><span class="line">    <span class="keyword">sysctl_t</span>cp_mem[<span class="number">0</span>] = limit / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">sysctl_t</span>cp_mem[<span class="number">1</span>] = limit;</span><br><span class="line">    <span class="keyword">sysctl_t</span>cp_mem[<span class="number">2</span>] = <span class="keyword">sysctl_t</span>cp_mem[<span class="number">0</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sysctl_tcp_mem中设置了三个界限，超过sysctl_tcp_mem[1]即进入了pressure模式， 进入pressure模式后，在缓存的分配、回收行为都会发生变化，当内存小于sysctl_tcp_mem[0]时，才会退出pressure模式，当内存大于sysctl_tcp_mem[2]时，会阻止内存的分配。相关代码在：<code>int __sk_mem_schedule(struct sock *sk, int size, int kind)</code>，这个方法是判断是否可以分配skb，下面进行分析。<br>如果小于sysctl_tcp_mem[0],才能退出pressure模式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parent_status == UNDER_LIMIT &amp;&amp;</span><br><span class="line">        allocated &lt;= sk_prot_mem_limits(sk, <span class="number">0</span>)) &#123;</span><br><span class="line">    sk_leave_memory_pressure(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大于sysctl_tcp_mem[1]，进入pressure模式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((parent_status &gt; SOFT_LIMIT) ||</span><br><span class="line">        allocated &gt; sk_prot_mem_limits(sk, <span class="number">1</span>))</span><br><span class="line">    sk_enter_memory_pressure(sk);</span><br></pre></td></tr></table></figure></p>
<p>大于sysctl_tcp_mem[2]，阻止内存分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((parent_status == OVER_LIMIT) || </span><br><span class="line">            (allocated &gt; sk_prot_mem_limits(sk, <span class="number">2</span>)))</span><br><span class="line">        <span class="keyword">goto</span> suppress_allocation;</span><br></pre></td></tr></table></figure></p>
<h2 id="读写缓存区限制">读写缓存区限制</h2><p>还有两个系统参数，分别定义了读写缓存区的限制，分别为<code>/proc/sys/net/ipv4/tcp_wmem</code>和<code>/proc/sys/net/ipv4/tcp_rmem</code>，其初始值如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sysctl_t</span>cp_wmem[<span class="number">0</span>] = SK_MEM_QUANTUM;</span><br><span class="line"><span class="keyword">sysctl_t</span>cp_wmem[<span class="number">1</span>] = <span class="number">16</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">sysctl_t</span>cp_wmem[<span class="number">2</span>] = max(<span class="number">64</span>*<span class="number">1024</span>, max_wshare);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sysctl_t</span>cp_rmem[<span class="number">0</span>] = SK_MEM_QUANTUM;</span><br><span class="line"><span class="keyword">sysctl_t</span>cp_rmem[<span class="number">1</span>] = <span class="number">87380</span>;</span><br><span class="line"><span class="keyword">sysctl_t</span>cp_rmem[<span class="number">2</span>] = max(<span class="number">87380</span>, max_rshare);</span><br></pre></td></tr></table></figure></p>
<p>当整体内存判断完后，当一个socket的已分配的内存小于sysctl_tcp_wmem[0]和sysctl_tcp_rmem[0]时，新分配内存的操作一定成功，还是在<code>int __sk_mem_schedule(struct sock *sk, int size, int kind)</code>函数里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kind == SK_MEM_RECV) &#123;</span><br><span class="line">    <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt; prot-&gt;sysctl_rmem[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* SK_MEM_SEND */</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;<span class="keyword">sk_t</span>ype == SOCK_STREAM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_wmem_queued &lt; prot-&gt;sysctl_wmem[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt;</span><br><span class="line">           prot-&gt;sysctl_wmem[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注：</strong><br>sysctl_tcp_wmem[1]和sysctl_tcp_rmem[1]是一个socket读写缓存大小的初始值，在<code>tcp_init_sock</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sk-&gt;sk_sndbuf = <span class="keyword">sysctl_t</span>cp_wmem[<span class="number">1</span>];</span><br><span class="line">sk-&gt;sk_rcvbuf = <span class="keyword">sysctl_t</span>cp_rmem[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>sysctl_tcp_wmem[2]和sysctl_tcp_rmem[2]是一个socket的读写缓存扩展时的最大值。</p>
<h2 id="pressure模式下最后判断">pressure模式下最后判断</h2><p>执行到这里，一定在pressure模式，这时需要一个公平性判断，即虽然整个内存很大了，但是这个socket占用的不足平均数，仍可以分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alloc = sk_sockets_allocated_read_positive(sk);</span><br><span class="line"><span class="keyword">if</span> (sk_prot_mem_limits(sk, <span class="number">2</span>) &gt; alloc *</span><br><span class="line">    sk_mem_pages(sk-&gt;sk_wmem_queued +</span><br><span class="line">         atomic_read(&amp;sk-&gt;sk_rmem_alloc) +</span><br><span class="line">         sk-&gt;sk_forward_alloc))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之outputStream]]></title>
    <link href="http://jangzq.info/2015/08/24/outputstream_write/"/>
    <id>http://jangzq.info/2015/08/24/outputstream_write/</id>
    <published>2015-08-24T13:42:51.000Z</published>
    <updated>2015-08-24T13:52:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>在本篇里讨论socket的outputStream的读操作。<br>在java中，使用<code>outputStream.write(b, 0, b.length)</code>发送数据，下面自顶向下进行讨论，在内核部分，关注的是开发网络程序及调优，密切相关的缓存、等待、时延相关的部分。</p>
<h2 id="JDK实现">JDK实现</h2><p>最终调用到本地方法<code>Java_java_net_SocketOutputStream_socketWrite0</code>，在其中调用<code>NET_Send</code>发送，即使用blocking io wrapper里的NET_Send，保证关闭的时候，不至于退出不了，详情见<a href="http://jangzq.info/2015/08/06/jdk_linux_close/">自顶向下话socket之blocking io wrapper</a>， 在其中调用的是send系统调用。</p>
<h2 id="linux内核实现">linux内核实现</h2><h3 id="主要流程">主要流程</h3><p>同connect，send系统调用，最终调用的是tcp proto的tcp_sendmsg方法，现在介绍这个方法的主要部分。</p>
<ol>
<li>首先检查socket是否被关闭了，或者存在错误，如果存在错误，则转到错误处理。这个说明了如果一个程序不停的发送数据，发送出错不一定会立刻发现，有可能在后面的发送中发现。</li>
<li>得到当前的mss，计算时需要考虑SACKs和IP选项，以及PMTU发现事件。</li>
<li><p>将数据拷贝到写缓冲区。</p>
<ol>
<li><p>如果输出队列（struct sock中的struct sk_buff_head sk_write_queue）中的最后一个sk_buff已经超过了mss，检查是否可以分配一个新的sk_buff，首先需要检查当前缓存的数据（sk-&gt;sk_wmem_queued）是否超过了发送缓存的大小（sk-&gt;sk_sndbuf），如果小于发送缓存大小，还需要判断要分配的内存是否超过了tcp协议的内存限制（另文描述），如果上述两个判断不满足，则需要等待（等待前需要把已经拷贝的数据发送），等待超时时间为SO_SNDTIMEO(如果是non-block，不需要等待），如果满足了，将新分配的sk_buff加入到输出队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!sk_stream_memory_free(sk))</span><br><span class="line">    <span class="keyword">goto</span> wait_for_sndbuf;</span><br><span class="line"></span><br><span class="line">skb = sk_stream_alloc_skb(sk,</span><br><span class="line">              select_size(sk, sg),</span><br><span class="line">              sk-&gt;sk_allocation);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line">    <span class="keyword">goto</span> wait_for_memory;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将数据拷贝到skb中，先在线性区分配，如果线性区没有空间，则尝试在frag_list中分配，在这里不详细描述。</p>
</li>
</ol>
</li>
<li><p>检查是否需要立即发送，在<code>forced_push</code>方法里，当需要发送的数据，大于对方声明的最大窗口大小的一半时，需要立即发送。如果不需要立即发送，并且只有这一个skb，只发送当前的skb。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forced_push(tp)) &#123;</span><br><span class="line">          tcp_mark_push(tp, skb);</span><br><span class="line">          <span class="keyword">__t</span>cp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb == tcp_send_head(sk))</span><br><span class="line">          tcp_push_one(sk, mss_now);</span><br></pre></td></tr></table></figure>
<p>其中判断逻辑：</p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">forced_push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tcp_sock *tp)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">     <span class="keyword">return</span> after(tp-&gt;write_seq, tp-&gt;pushed_seq + (tp-&gt;max_window &gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="发生错误后的流程">发生错误后的流程</h3><p>当发生错误，比如等待内存超时，如果已经将部分数据拷贝到了发送缓冲，则请求发送这些数据，并且返回发送的字节数，请看do_error后的操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (copied)</span><br><span class="line">        tcp_push(sk, flags, mss_now, tp-&gt;nonagle, size_goal);</span><br><span class="line">out_nopush:</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">return</span> copied + copied_syn;</span><br><span class="line"></span><br><span class="line">do_error:</span><br><span class="line">    <span class="keyword">if</span> (copied + copied_syn)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></p>
<h3 id="nagle和cork">nagle和cork</h3><p>在这里，主要关注nagle和cork。nagle是标准协议，而cork是linux独有的，都是为了减少小包传输，减少网络负载，但是又有所不同，下面通过源码说明。<br>nagle协议默认开启，可以通过TCP_NODELAY关闭，cork可以通过TCP_CORK打开，在实现上都是保存在tcp_sock的nonagle属性。<br>判断是否应用nagle和cork协议的方法是：<code>tcp_nagle_test</code>，从中也可以看出两者的异同。这个方法如果返回true，则是允许发送这个包，声明为：<code>static inline bool tcp_nagle_test(const struct tcp_sock *tp, const struct sk_buff *skb, unsigned int cur_mss, int nonagle)</code>。</p>
<ol>
<li><p>首先如果nonagle参数包含TCP_NAGLE_PUSH，说明是调用者需要立即发送包，如nagle和cork的参数状态发生变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nonagle &amp; TCP_NAGLE_PUSH)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果数据是urgent data，或者包含FIN，需要立即发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcp_urg_mode(tp) || (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>tcp_nagle_check</code>判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tcp_nagle_check(skb-&gt;len &lt; cur_mss, tp, nonagle))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>此函数定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> partial &amp;&amp;</span><br><span class="line">    ((nonagle &amp; TCP_NAGLE_CORK) ||</span><br><span class="line">     (!nonagle &amp;&amp; tp-&gt;packets_out &amp;&amp; tcp_minshall_check(tp)));</span><br></pre></td></tr></table></figure>
<p>这个函数的返回值如果为true的时候，是不发送， 不发送的条件如下：<br>1）如果包不满，即小于mss, 并且设置了TCP_NAGLE_CORK，则不发送。<br>2）如果包不满，并且没有设置TCP_NODELAY，并且有包没有收到ack，则不发送。</p>
</li>
</ol>
<p>从上文可以看出，cork比nagle严格，只要包不满，不管前面还有没有包没有收到ack，全都不发送，等着拼成大包，而nagle算法，如果前面的包都收到ack了，即使小包也发送，也就是当网络非常快的时候，还是会存在大量的小包。<br><strong>注</strong>：nagle和cork，在一段时间后，即使不符合条件，也会发送出去，这个时间一般为200或者300毫秒。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之inputStream]]></title>
    <link href="http://jangzq.info/2015/08/24/inputstream_read/"/>
    <id>http://jangzq.info/2015/08/24/inputstream_read/</id>
    <published>2015-08-24T13:42:50.000Z</published>
    <updated>2015-08-24T13:51:11.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>在本篇里讨论socket的inputStream的读操作。</p>
<h2 id="JDK实现">JDK实现</h2><p>socket.getInputStream().read调用的是本地方法<code>Java_java_net_SocketInputStream_socketRead0</code>.<br>如果设置了超时，则使用NET_Timeout来等待超时，或者可读，详细描述见<a href="http://jangzq.info/2015/08/06/jdk_linux_close/">自顶向下话socket之blocking io wrapper</a>，当超时或者出错，抛异常退出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    nread = NET_Timeout(fd, timeout);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没超时或者出错，说明可读，这时调用<code>NET_Read</code>进行读数据操作，这里面调用的是recv系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NET_ReadV</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">struct</span> iovec * <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    BLOCKING_IO_RETURN_INT( s, readv(s, <span class="built_in">vector</span>, count) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内核实现">内核实现</h2><p>recv系统调用最终调用的是<code>tcp_recvmsg</code>函数，而涉及接收的操作，在两类上下文里执行。其一为软中断上下文，其一为进程上下文。当用户程序调用recv读取数据时，此时运行在进程上下文，而收到tcp包时，系统将包或拷贝到用户空间，或放入相关队列，供用户进程使用，这些操作执行在软中断上下文里，下面分别描述。</p>
<h3 id="软中断上下文">软中断上下文</h3><p>在收到包后，网络软中断里调用<code>tcp_v4_rcv</code>，根据不同的情况处理接收到的包。</p>
<ul>
<li><p>如果socket上没有上锁，说明接收进程正在休眠等待，或者没有开始读取。在“休眠等待”的情况下，我们尝试把包放入prequeue队列，见<code>tcp_prequeue</code>。</p>
<ol>
<li><p>如果设置了<code>/proc/sys/net/ipv4/tcp_low_latency</code>，或者没有开始读取，返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">sysctl_t</span>cp_low_latency || !tp-&gt;ucopy.task)</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当prequeue队列里的内存大于接收缓存（<code>sk-&gt;sk_rcvbuf</code>），这时也调用<code>sk_backlog_rcv</code>处理prequeue队列里的skb。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tp-&gt;ucopy.memory &gt; sk-&gt;sk_rcvbuf) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> ((skb1 = __skb_dequeue(&amp;tp-&gt;ucopy.prequeue)) != NULL) &#123;</span><br><span class="line">        sk_backlog_rcv(sk, skb1);</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp-&gt;ucopy.memory = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当第一个skb放入prequeue队列时，唤醒等待的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (skb_queue_len(&amp;tp-&gt;ucopy.prequeue) == <span class="number">1</span>) &#123;</span><br><span class="line">    wake_up_interruptible_sync_poll(sk_sleep(sk),</span><br><span class="line">                   POLLIN | POLLRDNORM | POLLRDBAND);</span><br><span class="line">    <span class="keyword">if</span> (!inet_csk_ack_scheduled(sk))</span><br><span class="line">        <span class="keyword">inet_csk_reset_xmit_t</span>imer(sk, ICSK_TIME_DACK,</span><br><span class="line">                      (<span class="number">3</span> * tcp_rto_min(sk)) / <span class="number">4</span>,</span><br><span class="line">                      TCP_RTO_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>当socket上有锁，说明接收者正在处理，这时，将skb放入backlog队列，当<code>sk-&gt;sk_backlog.len + atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf + sk-&gt;sk_sndbuf</code>时，丢弃这个包，释放内存返回。</p>
</li>
<li>在没有开始读取（主要是非阻塞的情况下），或者设置了<code>/proc/sys/net/ipv4/tcp_low_latency</code>的情况下，直接调用<code>tcp_v4_do_rcv</code>，在这里只关注在连接建立后，处理包的流程，这里的逻辑非常复杂，简而言之，就是将乱序的包放入out_of_order队列，如果是顺序的包，如果已经开始了数据直接拷贝，并且拷贝线程是本线程，直接内存拷贝，否则放入receive队列<code>sk-&gt;sk_receive_queue</code>，并检查out_of_order队列里是否有下一个包，放入receive队列。上述逻辑见<code>tcp_rcv_established</code>。</li>
</ul>
<h3 id="进程上下文">进程上下文</h3><p>在这里分析<code>tcp_recvmsg</code>函数，在这里只分析对我们编程有指导意义的部分。</p>
<ul>
<li>block模式的超时时间是由<code>SO_RCVTIMEO</code>决定的。</li>
<li><p>目标读取数据量的确定。缺省情况下，只要读到了数据即返回，但这时有可能因为小包导致执行过多内核操作，所以在对数据协议清楚的情况下，调用recv时，flag可以设置MSG_WAITALL，一定读取到参数len才返回。另外socket option SO_RCVLOWAT参数也会起作用，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sock_rcvlowat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> waitall, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (waitall ? len : <span class="keyword">min_t</span>(<span class="keyword">int</span>, sk-&gt;sk_rcvlowat, len)) ? : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将各种队列里的数据拷贝到用户空间。</p>
<ol>
<li>先处理receive队列，如果没有读到数据，直接返回-EAGAIN。</li>
<li>处理prequeue队列，对于每个包，调用tcp_v4_do_rcv，见上文描述，见<code>tcp_prequeue_process</code>。</li>
<li><p>如果是被唤醒的，则先处理prequeue队列， 即从下面的代码之下的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copied &gt;= target) &#123;</span><br><span class="line">    <span class="comment">/* Do not sleep, just process backlog. */</span></span><br><span class="line">    release_sock(sk);</span><br><span class="line">    lock_sock(sk);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    sk_wait_data(sk, &amp;timeo);</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于在处理过程中，新来的包在backlog队列里，所以在<code>__release_sock</code>中遍历backlog队列，调用的还是tcp_v4_do_rcv。</p>
</li>
</ol>
</li>
</ul>
<h2 id="总结">总结</h2><p>在整个过程中，涉及如下几个队列：receive队列、prequeue队列、backlog队列、out_of_order队列。其中，receive队列是存放顺序的包，已经具备拷贝到用户空间的条件，处理一个顺序包时（这个包可能是新读取的，也可能是处理别的队列缓存的包），如果目前没有读取（或者读取的不是本进程），则放入此队列，如果正在读取，则直接拷贝到用户空间。prequeue队列，当收到一个包时，有进程正在读此socket，并且处于阻塞等待，放入此队列，当进程被唤醒，继续执行时，首先处理这个队列。当收到一个包时，有的线程正在读取，则放到backlog队列时，当进程处理完，准备退出时处理这个队列的包。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之connect超时]]></title>
    <link href="http://jangzq.info/2015/08/11/connect_timeout/"/>
    <id>http://jangzq.info/2015/08/11/connect_timeout/</id>
    <published>2015-08-11T12:28:23.000Z</published>
    <updated>2015-08-11T12:33:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>不做特殊说明，全部指linux平台。<br>当不设置超时，connect操作多久超时，实验如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Socket s = <span class="keyword">new</span> Socket(<span class="string">"192.168.1.132"</span>, <span class="number">1666</span>);</span><br><span class="line">	s.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis()-beginTime);</span><br></pre></td></tr></table></figure></p>
<p>输出为：127202，即127秒，这个值怎么来的，我们深入源码一探究竟。<br>在<code>tcp_connect</code>中，发送syn后，调用<code>inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX)</code>重置或者重启“重传timer”，这个函数相关部分如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inet_csk_reset_xmit_timer</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">const</span> <span class="keyword">int</span> what,</span><br><span class="line">                         <span class="keyword">unsigned</span> <span class="keyword">long</span> when,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> max_when)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     ......</span><br><span class="line">    <span class="keyword">if</span> (what == ICSK_TIME_RETRANS || what == ICSK_TIME_PROBE0 ||</span><br><span class="line">        what == ICSK_TIME_EARLY_RETRANS || what ==  ICSK_TIME_LOSS_PROBE) &#123;</span><br><span class="line">        icsk-&gt;icsk_pending = what;</span><br><span class="line">        icsk-&gt;<span class="keyword">icsk_t</span>imeout = jiffies + when;</span><br><span class="line">        <span class="keyword">sk_reset_t</span>imer(sk, &amp;icsk-&gt;<span class="keyword">icsk_retransmit_t</span>imer, icsk-&gt;<span class="keyword">icsk_t</span>imeout);</span><br><span class="line">    &#125;</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，重置icsk_retransmit_timer的超时时间，如果没有启动，则启动，超时时间为<code>inet_csk(sk)-&gt;icsk_rto</code>，这个值的初始值在初始化socket时设置的，初始值为<code>icsk-&gt;icsk_rto = TCP_TIMEOUT_INIT;</code>，TCP_TIMEOUT_INIT的定义为：<code>#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))</code>,HZ是1秒的节拍数，1HZ在时间上来说，就是1秒。也就是最初是1秒种超时，调用timer的回调函数<code>tcp_retransmit_timer</code>，在这个函数里，首先重发了syn包，然后判断整个操作是否超时了（下文详细描述），如果没有超时，然后重新计算下一次等待超时时间，并且重启定时器，超时时间的计算规则为：<code>icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; 1, TCP_RTO_MAX)</code>即上次的超时时间*2，最大为TCP_RTO_MAX（120秒）。<br>从上面可以看出关键是判断整个操作是否超时，计算整个操作超时时间的逻辑在函数<code>retransmits_timed_out</code>里（程序如下），在这里boundary即重试次数，当boundary小于ilog2(TCP_RTO_MAX/rto_base)时，超时次数为一个指数关系，当大于的时候，ilog2(TCP_RTO_MAX/rto_base)之下的为指数增长，之上为线性增长，重试次数由系统参数：/proc/sys/net/ipv4/tcp_syn_retries确定，缺省为6,带入公式计算， 得到的正是127。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">linear_backoff_t</span>hresh = ilog2(TCP_RTO_MAX/rto_base);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (boundary &lt;= <span class="keyword">linear_backoff_t</span>hresh)</span><br><span class="line">           timeout = ((<span class="number">2</span> &lt;&lt; boundary) - <span class="number">1</span>) * rto_base;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           timeout = ((<span class="number">2</span> &lt;&lt; <span class="keyword">linear_backoff_t</span>hresh) - <span class="number">1</span>) * rto_base +</span><br><span class="line">               (boundary - <span class="keyword">linear_backoff_t</span>hresh) * TCP_RTO_MAX;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示sock]]>
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之connect]]></title>
    <link href="http://jangzq.info/2015/08/06/java_connect/"/>
    <id>http://jangzq.info/2015/08/06/java_connect/</id>
    <published>2015-08-06T15:51:01.000Z</published>
    <updated>2015-08-11T12:54:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>在本篇里讨论socket的connect这个操作。<br>当java程序，进行socket connect时，调用方法为<code>PlainSocketImpl</code>中的native方法<code>native void socketConnect(InetAddress address, int port, int timeout) throws IOException</code>。</p>
<h2 id="JDK实现">JDK实现</h2><p>jdk的connect操作，先是调用connect系统调用，然后根据错误码抛出异常，并且设置java类的参数。需要注意的是，在linux版本的jdk中，根据是否设置了超时参数，调用connect方式不同，见<code>Java_java_net_PlainSocketImpl_socketConnect</code><br><a id="more"></a></p>
<ul>
<li><p>没有设置超时<br>使用blocking io wrapper里的NET_Connect，保证关闭的时候，不至于退出不了，详情见<a href="http://jangzq.info/2015/08/06/jdk_linux_close/">自顶向下话socket之blocking io wrapper</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NET_Connect</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">int</span> addrlen)</span> </span>&#123;</span><br><span class="line">    BLOCKING_IO_RETURN_INT( s, connect(s, addr, addrlen) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在设置超时的情况下，就是标准的异步建立connect的操作，熟悉linux网络编程的一定不会陌生。</p>
<ol>
<li><p>将fd设置为非阻塞状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SET_NONBLOCKING(fd) &#123;           \</span><br><span class="line">    int flags = fcntl(fd, F_GETFL); \</span><br><span class="line">    flags |= O_NONBLOCK;            \</span><br><span class="line">    fcntl(fd, F_SETFL, flags);      \</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用connect系统调用，这时不会阻塞，立刻返回，如果返回0,说明连接成功。否则说明发生错误，当errno等于EINPROGRESS时，说明正在进行中，如果错误码不是EINPROGRESS，说明发生真的错误。当正在进行中时，可以使用select或者poll监视文件描述符的写操作，当然，超时需要设置。当poll返回时，如果返回值为0,说明超时了，小于0，如果errno是EINTR,即中断的系统调用，需要修正超时时间后，重复调用poll，否则不是成功，就是失败，可以进行下一步的判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">   errno = <span class="number">0</span>;</span><br><span class="line">   connect_rv = NET_Poll(&amp;pfd, <span class="number">1</span>, timeout);</span><br><span class="line">   <span class="keyword">if</span> (connect_rv &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//修正timeout。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，poll使用的也是blocking io wrapper里面的方法，这样就保证了close时能退出。</p>
</li>
<li>无论如何，都要把fd置回blocking。</li>
<li>如果上一步poll的返回值为0,说明超时了，返回，但是需要调用<code>JVM_SocketShutdown</code>关闭socket。</li>
<li>检查SO_ERROR参数是否为0,如果为0,说明成功了，否则失败。</li>
</ol>
</li>
<li><p>如果出错了，根据errno，抛出相应的异常。</p>
<blockquote>
<p>Invalid argument or cannot assign requested address<br> operation interrupted<br> Connection refused<br> Connection timed out<br> Host unreachable<br> Address not available<br> Socket closed<br> connect failed</p>
</blockquote>
</li>
<li><p>如果成功了, 设置Socket类的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;SetIntField(env, fdObj, IO_fd_fdID, fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the remote peer address and port */</span></span><br><span class="line">(*env)-&gt;SetObjectField(env, <span class="keyword">this</span>, psi_addressID, iaObj);</span><br><span class="line">(*env)-&gt;SetIntField(env, <span class="keyword">this</span>, psi_portID, port);</span><br><span class="line"><span class="keyword">if</span> (localport == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Now that we're a connected socket, let's extract the port number</span><br><span class="line">     * that the system chose for us and store it in the Socket object.</span><br><span class="line">     */</span></span><br><span class="line">    len = SOCKADDR_LEN;</span><br><span class="line">    <span class="keyword">if</span> (JVM_GetSockName(fd, (<span class="keyword">struct</span> sockaddr *)&amp;him, &amp;len) == -<span class="number">1</span>) &#123;</span><br><span class="line">        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                       <span class="string">"Error getting socket name"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        localport = NET_GetPortFromSockaddr((<span class="keyword">struct</span> sockaddr *)&amp;him);</span><br><span class="line">        (*env)-&gt;SetIntField(env, <span class="keyword">this</span>, psi_localportID, localport);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="linux内核">linux内核</h2><p>tcp协议中的connect对应于tcp协议的三次握手过程，由于tcp协议非常复杂，所以不可能详细描述，在这里只涉及一些比较有趣的细节。首先，大致介绍一下内核中的操作。</p>
<ol>
<li><p>首先，通过fd找到相应的socket。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用sock-&gt;ops-&gt;connect方法，即inet_stream_connect方法。</p>
<ol>
<li>根据sock-&gt;state做不同的处理，如果是SS_CONNECTED，则将errno设为EISCONN，退出;如果是SS_CONNECTING，则将errno设为EALREADY，然后继续执行下面的程序;如果是SS_UNCONNECTED，则调用<code>sk-&gt;sk_prot-&gt;connect</code>即<code>tcp_v4_connect</code>，在这个方法里，主要是发送SYN，并且启动重传timer，然后将sock-&gt;state设置为SS_CONNECTING，errno设为EINPROGRESS。</li>
<li><p>判断是否需要等待，在上文“JDK实现”中可以看到，如果设为非阻塞状态则不会等待，在这里得到了证明,见下面的程序，如果是noblock，则超时时间设为0,否则设为socket option SO_SNDTIMEO，这个值缺省值为MAX_SCHEDULE_TIMEOUT，即LONG_MAX，基本不会超时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">sock_sndtimeo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sock *sk, <span class="keyword">bool</span> noblock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> noblock ? <span class="number">0</span> : sk-&gt;sk_sndtimeo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前状态是TCPF_SYN_SENT | TCPF_SYN_RECV时，如果超时时间不为0,则进行等待，见方法 <code>inet_wait_for_connect</code>, 退出有三种可能，一种是timeout，一种是有信号需要处理（这也是为什么上面“JDK实现中”收到信号需要重新调用），一种是状态进行了变化，即收到了ack，进入了TCPF_ESTABLISHED状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    timeo = <span class="keyword">schedule_t</span>imeout(timeo);</span><br><span class="line">    lock_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current) || !timeo)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">prepare_t</span>o_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果上面的等待函数退出，并且返回值不为0（说明不是timeout）,并且没有阻塞的信号（说明不是因为信号退出），则说明是成功连接了，<code>sock-&gt;state = SS_CONNECTED</code>。否则，直接退出。</p>
</li>
</ol>
</li>
</ol>
<p>通过上面的描述，一些在“JDK实现”中的用到的方法，在内核层得到了解释。</p>
<ul>
<li>为什么收到信号会退出，而还可以继续重新调用。<br><em>提示：sock-&gt;state是SS_CONNECTING的操作</em></li>
<li>是否可以设置SO_SNDTIMEO，达到超时的目的。<br>可以，但是超时后的errno是EINPROGRESS，可以再次调用connect。</li>
<li>缺省情况下，connect多长时间超时。<br>请参见本系列的《自顶向下话socket之connect超时》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。<br>在本篇里讨论socket的connect这个操作。<br>当java程序，进行socket connect时，调用方法为<code>PlainSocketImpl</code>中的native方法<code>native void socketConnect(InetAddress address, int port, int timeout) throws IOException</code>。</p>
<h2 id="JDK实现">JDK实现</h2><p>jdk的connect操作，先是调用connect系统调用，然后根据错误码抛出异常，并且设置java类的参数。需要注意的是，在linux版本的jdk中，根据是否设置了超时参数，调用connect方式不同，见<code>Java_java_net_PlainSocketImpl_socketConnect</code><br>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之blocking io wrapper]]></title>
    <link href="http://jangzq.info/2015/08/06/jdk_linux_close/"/>
    <id>http://jangzq.info/2015/08/06/jdk_linux_close/</id>
    <published>2015-08-06T13:28:16.000Z</published>
    <updated>2015-08-06T13:59:41.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在JDK中，<code>linux_close.c</code>里对socket中涉及blocking io操作的方法做了封装，主要解决如下问题：</p>
<ol>
<li>对于blocking操作，当关闭socket时，必须能从阻塞中退出。</li>
<li>当阻塞的操作被收到的signal打断时，需要能继续操作。</li>
</ol>
<p>JDK中的实现，对于我们自己编写网络应用也很有借鉴意义，所以单独用一篇文章介绍一下，总的思路是1）当调用close时，向所有的阻塞在此fd上的线程发送信号，造成阻塞操作退出。2）阻塞操作退出后，检查信号是不是我们发送的信号，如果不是我们发送的信号，则再次执行原操作。<br><a id="more"></a></p>
<ul>
<li><p>首先，看两个数据结构，一个是线程链表，一个是文件描述符项，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> threadEntry &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;                      <span class="comment">/* this thread */</span></span><br><span class="line">    <span class="keyword">struct</span> threadEntry *next;           <span class="comment">/* next thread */</span></span><br><span class="line">    <span class="keyword">int</span> intr;                           <span class="comment">/* interrupted */</span></span><br><span class="line">&#125; threadE<span class="keyword">ntry_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;               <span class="comment">/* fd lock */</span></span><br><span class="line">    threadE<span class="keyword">ntry_t</span> *threads;             <span class="comment">/* threads blocked on fd */</span></span><br><span class="line">&#125; fdE<span class="keyword">ntry_t</span>;</span><br></pre></td></tr></table></figure>
<p>fdEntry_t保存了一个fd，和阻塞在这个fd上的线程链表。当初始化的时候，创建了一个fdEntry_t的列表，<code>static fdEntry_t *fdTable</code>，大小为一个进程最大能打开的文件数，即ulimit设置的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getrlimit(RLIMIT_NOFILE, &amp;nbr_files);</span><br><span class="line">fdCount = nbr_files.rlim_max;</span><br><span class="line">fdTable = (fdE<span class="keyword">ntry_t</span> *)<span class="built_in">calloc</span>(fdCount, <span class="keyword">sizeof</span>(fdE<span class="keyword">ntry_t</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在初始化的时候，注册信号监听，这个信号将用来通知线程退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sa.sa_handler = sig_wakeup;</span><br><span class="line">sa.sa_flags   = <span class="number">0</span>;</span><br><span class="line">sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">sigaction(sigWakeup, &amp;sa, NULL);</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;sigset);</span><br><span class="line">sigaddset(&amp;sigset, sigWakeup);</span><br><span class="line">sigprocmask(SIG_UNBLOCK, &amp;sigset, NULL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭连接时的操作，见<code>closefd</code>，在这个函数里，把dup2和close的处理放在了一起。<br> 首先，通过fd，得到fdEntry_t。<br> 然后，关闭fd，如果发生错误并且是由于信号中断了系统调用，循环关闭。</p>
 <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="comment">(fd1 &lt; 0)</span> &#123;</span><br><span class="line">         rv = close<span class="comment">(fd2)</span>;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         rv = dup<span class="number">2</span><span class="comment">(fd1, fd2)</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> <span class="comment">(rv == -1 &amp;&amp; errno == EINTR)</span>;</span><br></pre></td></tr></table></figure>
<p>  最后，遍历所有阻塞在此FD的线程，向它们发送信号，并且把线程结构体里的intr设置为1，是为了区别引起退出的信号是这里发出的，还是别的原因收到的。</p>
  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadEntry_t *curr = fdEntry-&gt;threads;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="constant">NULL)</span> &#123;</span><br><span class="line">    curr-&gt;intr = <span class="number">1</span>;</span><br><span class="line">    pthread_kill( curr-&gt;thr, sigWakeup );</span><br><span class="line">    curr = curr-&gt;<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过一个宏定义包装了原来的阻塞操作,如下，其中FD是文件描述符，FUNC就是阻塞操作。首先通过FD，得到对应的fdEntry_t，由于在初始化的时候，创建了所有可能FD的fdEntry_t，所以应该都能得到。然后在<code>startOp</code>里，把当前线程加入到fdEntry_t里，紧接着就调用FUNC，阻塞在这里，当退出后，在<code>endOp</code>中，如果本线程的curr-&gt;intr被设置了，说明是关闭连接了，所以把errno改成了EBADF，并且把自己从等待此FD的线程链表里删除。最后，判断当前errno是否是EINTR，如果是，说明是因为别的原因退出的，所以循环回去，继续阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BLOCKING_IO_RETURN_INT(FD, FUNC) &#123;      \</span><br><span class="line">    int ret;                                    \</span><br><span class="line">    threadEntry_t self;                         \</span><br><span class="line">    fdEntry_t *fdEntry = getFdEntry(FD);        \</span><br><span class="line">    <span class="keyword">if</span> (fdEntry == NULL) &#123;                      \</span><br><span class="line">        errno = EBADF;                          \</span><br><span class="line">        return -1;                              \</span><br><span class="line">    &#125;                                           \</span><br><span class="line">    do &#123;                                        \</span><br><span class="line">        startOp(fdEntry, &amp;self);                \</span><br><span class="line">        ret = FUNC;                             \</span><br><span class="line">        endOp(fdEntry, &amp;self);                  \</span><br><span class="line">    &#125; while (ret == -1 &amp;&amp; errno == EINTR);      \</span><br><span class="line">    return ret;                                 \</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所有的方法都是使用的这个宏，举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NET_Read</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">void</span>* buf, size_t len)</span> </span>&#123;</span><br><span class="line">    BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, <span class="number">0</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>在这个文件里，有一个非常常用的方法，<code>NET_Timeout</code>。在JDK里，大量使用了poll来实现超时，具体原理就是用poll监视指定描述符的读和错误操作，并且设置超时时间的，当文件操作符可读或者超时时，poll就会返回，所以可以用poll来进行超时判断。</p>
<ol>
<li><p>使用poll监视文件，并且设置超时，在调用前，<code>startOp</code>里，把当前线程加入到fdEntry_t里，紧接着就调用poll，阻塞在这里，当退出后，在<code>endOp</code>中，如果本线程的curr-&gt;intr被设置了，说明是关闭连接了，所以把errno改成了EBADF，并且把自己从等待此FD的线程链表里删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pfd.fd = s;</span><br><span class="line">pfd.events = POLLIN | POLLERR;</span><br><span class="line"></span><br><span class="line">startOp(fdEntry, &amp;self);</span><br><span class="line">rv = poll(&amp;pfd, <span class="number">1</span>, timeout);</span><br><span class="line">endOp(fdEntry, &amp;self);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是因为错误退出，而且不是因为close fd造成的，修正超时时间后继续poll，否则退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rv &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gettimeofday(&amp;t, NULL);</span><br><span class="line">            newtime = t.tv_sec * <span class="number">1000</span>  +  t.tv_usec / <span class="number">1000</span>;</span><br><span class="line">            timeout -= newtime - prevtime;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prevtime = newtime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在JDK中，<code>linux_close.c</code>里对socket中涉及blocking io操作的方法做了封装，主要解决如下问题：</p>
<ol>
<li>对于blocking操作，当关闭socket时，必须能从阻塞中退出。</li>
<li>当阻塞的操作被收到的signal打断时，需要能继续操作。</li>
</ol>
<p>JDK中的实现，对于我们自己编写网络应用也很有借鉴意义，所以单独用一篇文章介绍一下，总的思路是1）当调用close时，向所有的阻塞在此fd上的线程发送信号，造成阻塞操作退出。2）阻塞操作退出后，检查信号是不是我们发送的信号，如果不是我们发送的信号，则再次执行原操作。<br>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自顶向下话socket之create socket]]></title>
    <link href="http://jangzq.info/2015/08/06/java_createsocket/"/>
    <id>http://jangzq.info/2015/08/06/java_createsocket/</id>
    <published>2015-08-06T13:12:38.000Z</published>
    <updated>2015-08-06T13:19:18.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>java中的socket编程比c简洁的多，例如简单的一句<code>Socket socket = new Socket(&quot;192.168.1.1&quot;, 8888)</code>就完成了c中好几步操作，接下来，在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。</p>
<p>下面的JDK源码，为Socket的一种构造函数，从中可以看出，在这个函数中完成了创建socket、bind（server only）、connect（client only)三个操作，在本篇里讨论socket的创建这个操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(SocketAddress address, SocketAddress localAddr,</span><br><span class="line">               <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createImpl(stream);</span><br><span class="line">        <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>)</span><br><span class="line">            bind(localAddr);</span><br><span class="line">        <span class="keyword">if</span> (address != <span class="keyword">null</span>)</span><br><span class="line">            connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="JDK实现">JDK实现</h2><p>在JDK里，创建socket的代码为：<code>AbstractPlainSocketImpl.create</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">socketCreate(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>socketCreate为jni方法，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = JVM_Socket(domain, type, <span class="number">0</span>)) == JVM_IO_ERR) &#123;</span><br><span class="line">    NET_ThrowNew(env, errno, <span class="string">"can't create socket"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">(*env)-&gt;SetIntField(env, fdObj, IO_fd_fdID, fd);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>JVM_Socket</code>创建socket，并且将返回的文件描述符，传回java中。<code>JVM_Socket</code>方法调用的是socket系统调用，分析见下文“内核实现”部分。</p>
<h2 id="linux内核实现">linux内核实现</h2><p>socket系统调用的定义如下：<code>SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)</code>。</p>
<ol>
<li><p>分配一个socket数据结构。<br>首先从内存中分配socket结构体，实际是分配了一个<code>socket_alloc</code>结构，如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket_alloc &#123;</span><br><span class="line">  <span class="keyword">struct</span> socket socket;</span><br><span class="line">  <span class="keyword">struct</span> inode vfs_inode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>入口为:<code>sock_alloc</code>方法，在其中调用fs子系统的<code>new_inode_pseudo</code>方法，在其中调用了super operations的方法，最终调用的为<code>sock_alloc_inode</code>。在这个方法中，分配了一个<code>socket_alloc</code>结构。这个结构分配在了SLAB中，SLAB cache的名称为“sock_inode_cache”，通过cat /proc/slabinfo | grep sock_inode_cache可以看出一个<strong>对象的大小为640字节</strong>。<code>sock_alloc_inode</code>方法关键部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket_alloc *ei;</span><br><span class="line"><span class="keyword">struct</span> socket_wq *wq;</span><br><span class="line">  </span><br><span class="line">ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ei)</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">wq = kmalloc(<span class="keyword">sizeof</span>(*wq), GFP_KERNEL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>socket初始化数据<br>通过系统调用参数里的family参数，调用相应协议族的create方法，进行初始化，在这里即调用<code>inet_create</code>, 主要操作包括：</p>
<ol>
<li>通过type和protocol找到对应的inet_protosw。</li>
<li>将inet_protosw中的ops，赋值给socket的ops： <code>sock-&gt;ops = answer-&gt;ops</code>。</li>
<li><p>新建socket的<code>sock     *sk</code>，入口函数为<code>struct sock *sk_alloc(struct net *net, int family, gfp_t priority,  struct proto *prot)</code>。<br>内存分配在prot中的slab里，对于TCP协议来说，为tcp_sock，分配在tcp协议的slab cache（名称为TCP)里，一个<strong>对象大小为1856</strong>。（<code>sk_prot_alloc</code>）。<br>给sock属性赋值，需要注意的几个值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sk-&gt;sk_family = family;</span><br><span class="line">sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot;</span><br><span class="line">sk-&gt;sk_rcvbuf       =   sysctl_rmem_default; <span class="comment">//即/proc/sys/net/core/rmem_default的值</span></span><br><span class="line">sk-&gt;sk_sndbuf       =   sysctl_wmem_default;<span class="comment">//即proc/sys/net/core/wmem_default的值。</span></span><br></pre></td></tr></table></figure>
<p>使用prot的init方法给sock复制，<code>sk-&gt;sk_prot-&gt;init(sk)</code>，对于tcp来说，就是调用<code>tcp_v4_init_sock</code>方法。在这里面将进行了覆盖。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sk-&gt;sk_sndbuf = sysctl_tcp_wmem[<span class="number">1</span>]; //即/<span class="keyword">proc</span>/sys/net/ipv4/tcp_wmem</span><br><span class="line">sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[<span class="number">1</span>]; //即/<span class="keyword">proc</span>/sys/net/ipv4/tcp_rmem</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>为了使socket可以像文件一样操作，需要分配一个文件描述符，以及一个file结构，就像打开一个新文件一样，这部分操作的入口在<code>sock_map_fd</code>，由于这里面调用的几个方法是vfs子系统的方法，所以在这里就不再展开描述，以后有机会在别的文章再展开，这里只是需要强调，既然是打开文件，所以一定受<strong>打开文件的限制</strong>，影响打开文件的因素请参考<a href="http://jangzq.info/2015/08/06/linux-file-limit/">深入分析linux打开文件数限制</a></p>
<ol>
<li><p>首先，调用<code>get_unused_fd_flags</code>，得到一个未使用的文件描述符。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd = get_unused_fd_flags<span class="list">(<span class="keyword">flags</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>sock_alloc_file</code>中，首先分配一个dentry，即目录项，在VFS里，每一个文件必须有一个目录项，连接在一起构成了路径的树状关系。既然socket当作文件，所以也需要有目录项，所以调用<code>d_alloc_pseudo</code>进行分配,分配完成后使用<code>d_instantiate(path.dentry, SOCK_INODE(sock))</code>将dentry和上一步中分配的inode联系起来。</p>
</li>
<li><p>分配和初始化<code>struct file</code>，得到file指针后，通过<code>sock-&gt;file = file</code>和<code>file-&gt;private_data = sock</code>将文件和socket关联起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE,</span><br><span class="line">      &amp;socket_file_ops);</span><br><span class="line"><span class="keyword">if</span> (unlikely(IS_ERR(file))) &#123;</span><br><span class="line">    <span class="comment">/* drop dentry, keep inode */</span></span><br><span class="line">    ihold(path.dentry-&gt;d_inode);</span><br><span class="line">    path_put(&amp;path);</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，在调用alloc_file时传入的socket_file_ops参数，指出了文件操作对应的socket方法，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations socket_file_ops = &#123;</span><br><span class="line">    .owner =    THIS_MODULE,</span><br><span class="line">    .llseek =   no_llseek,</span><br><span class="line">    .aio_read = sock_aio_read,</span><br><span class="line">    .aio_write =    sock_aio_write,</span><br><span class="line">    .poll =     sock_poll,</span><br><span class="line">    .unlocked_ioctl = sock_ioctl,</span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_COMPAT</span></span><br><span class="line">    .compat_ioctl = compat_sock_ioctl,</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    .mmap =     sock_mmap,</span><br><span class="line">    .release =  sock_close,</span><br><span class="line">    .fasync =   sock_fasync,</span><br><span class="line">    .sendpage = sock_sendpage,</span><br><span class="line">    .splice_write = generic_splice_sendpage,</span><br><span class="line">    .splice_read =  sock_splice_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，将文件描述符和file结构体管理起来：<code>fd_install(fd, newfile)</code>。</p>
</li>
</ol>
</li>
</ol>
<p>至此socket系统调用完毕。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>java中的socket编程比c简洁的多，例如简单的一句<code>Socket socket = new Socket(&quot;192.168.1.1&quot;, 8888)</code>就完成了c中好几步操作，接下来，在“自顶向下话socket”系列里，将从jdk向下一直到linux内核，通过源码来揭示socket操作究竟是什么原理，都消耗了哪些资源，受到什么限制，为开发出稳定、高效的网络程序，乃至诊断、排障、调优提供理论基础。</p>
<p>下面的JDK源码，为Socket的一种构造函数，从中可以看出，在这个函数中完成了创建socket、bind（server only）、connect（client only)三个操作，在本篇里讨论socket的创建这个操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(SocketAddress address, SocketAddress localAddr,</span><br><span class="line">               <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        createImpl(stream);</span><br><span class="line">        <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>)</span><br><span class="line">            bind(localAddr);</span><br><span class="line">        <span class="keyword">if</span> (address != <span class="keyword">null</span>)</span><br><span class="line">            connect(address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="jdk" scheme="http://jangzq.info/tags/jdk/"/>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入分析linux打开文件数限制]]></title>
    <link href="http://jangzq.info/2015/08/06/linux-file-limit/"/>
    <id>http://jangzq.info/2015/08/06/linux-file-limit/</id>
    <published>2015-08-05T16:06:55.000Z</published>
    <updated>2015-08-05T16:11:16.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在linux中，影响打开文件数的参数主要有如下几个：</p>
<ul>
<li>ulimit中的nofile参数。</li>
<li>/proc/sys/fs/nr_open</li>
<li>/proc/sys/fs/file-max<br>这几个参数各有什么作用，又有什么不同，影响范围是哪些，下面通过源代码来一探究竟。<a id="more"></a>
<h2 id="ulimit_nofile">ulimit nofile</h2>此参数如何查看，以及如何修改，网上有很多资料，如果不清楚，请参考那些资料。但是你是否有疑问，如果通过<code>ulimit -Sn</code>命令修改的值，为什么只对本shell有效？下面通过源码说明。<br>首先，我们先看一下，这个参数是怎么限制打开文件的。我们都清楚，当一个进程打开一个文件时，linux会在进程范围内分配一个文件描述符，这个操作入口方法如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_unused_fd_flags</span><span class="params">(<span class="keyword">unsigned</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __alloc_fd(current-&gt;files, <span class="number">0</span>, rlimit(RLIMIT_NOFILE), flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __alloc_fd(<span class="keyword">struct</span> files_struct *files, <span class="keyword">unsigned</span> start, <span class="keyword">unsigned</span> end, <span class="keyword">unsigned</span> flags) &#123;</span><br><span class="line">   .......</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= end)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">   .......</span><br><span class="line">out:</span><br><span class="line">    spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过上面的代码节选，就可以看出，分配文件描述符的时候，是在[0, rlimit(RLIMIT_NOFILE))这个区间选择的，这里先提前说明一下，<code>rlimit(RLIMIT_NOFILE)</code>即我们现在研究的参数。由于最大范围就是这么大，所以当然打不开比这个更多的文件。<br>看了这个参数如何限制文件的打开之后，我们探讨一下这个参数储存在哪里，以及怎么来的。我们查看rlimit的定义，发现这个函数以及它调用的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rlimit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> limit)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task_rlimit(current, limit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">task_rlimit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> task_struct *tsk,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> limit)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ACCESS_ONCE(tsk-&gt;signal-&gt;rlim[limit].rlim_cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码就很清楚的看出，这个参数保存在当前线程的task_struct里，即大名鼎鼎的进程描述符里。在task_struct中的<code>struct signal_struct *signal</code>遍历里保存，定义如下：<code>struct rlimit rlim[RLIM_NLIMITS]</code>。其中rlimit定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rlimit &#123;</span><br><span class="line">    <span class="keyword">__kernel_ulong_t</span>    rlim_cur;</span><br><span class="line">    <span class="keyword">__kernel_ulong_t</span>    rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的rlim_cur即软限制，rlim_max为硬限制。现在就很清楚了，在shell里使用ulimit命令修改时，其实是修改的本进程的进程描述符里的相关设置，设置之后，启动别的命令时，由于子进程会继承父进程的这个参数，所以也会影响子进程，下面就是fork时拷贝这些参数的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_signal：</span><br><span class="line">    <span class="built_in">memcpy</span>(sig-&gt;rlim, current-&gt;signal-&gt;rlim, <span class="keyword">sizeof</span> sig-&gt;rlim);</span><br></pre></td></tr></table></figure></p>
<p>掌握上面的原理后，应该很轻松的理解这个参数的影响范围是什么。</p>
<h2 id="nr_open">nr_open</h2><p>nr_open参数是在创建和扩展进程的文件描述符表时起作用，所以限制也是进程级的，但是影响的范围是所有的用户的进程，使用代码如下：<br>进程中的文件描述符表并不是一开始就设置为最大的，而是根据打开的文件动态扩展的，扩展时的函数为<code>expand_files</code>，在这个函数里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nr &gt;= sysctl_nr_open)</span><br><span class="line">       <span class="keyword">return</span> -EMFILE;</span><br></pre></td></tr></table></figure></p>
<p>另外，需要注意的是，通过ulimit设置nofile时，最大值不能超过nr_open，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resource == RLIMIT_NOFILE &amp;&amp;</span><br><span class="line">        new_rlim-&gt;rlim_max &gt; sysctl_nr_open)</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br></pre></td></tr></table></figure></p>
<h2 id="file-max">file-max</h2><p>在linux内核中，维护着一个计数，记录着目前打开了多少文件：<code>static struct percpu_counter nr_files __cacheline_aligned_in_smp</code>。当打开文件时，都要判断这个值是否超过了file-max，如果超过了则不许打开，在<code>get_empty_filp</code>方法里，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_nr_files() &gt;= files_stat.max_files &amp;&amp; !capable(CAP_SYS_ADMIN)) &#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * percpu_counters are inaccurate.  Do an expensive check before</span><br><span class="line">     * we go and fail.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (percpu_counter_sum_positive(&amp;nr_files) &gt;= files_stat.max_files)</span><br><span class="line">        <span class="keyword">goto</span> over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，这个值是整个系统范围内的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>在linux中，影响打开文件数的参数主要有如下几个：</p>
<ul>
<li>ulimit中的nofile参数。</li>
<li>/proc/sys/fs/nr_open</li>
<li>/proc/sys/fs/file-max<br>这几个参数各有什么作用，又有什么不同，影响范围是哪些，下面通过源代码来一探究竟。]]>
    
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[socket内核基础数据结构]]></title>
    <link href="http://jangzq.info/2015/08/04/socket_kernel_struct/"/>
    <id>http://jangzq.info/2015/08/04/socket_kernel_struct/</id>
    <published>2015-08-04T15:52:28.000Z</published>
    <updated>2015-08-04T15:57:54.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>这是“自顶向下话socket”系列的第一篇，本系列文章计划从java到linux内核，讲解socket的方方面面。除了本篇，其余文章都遵循从顶向下的原则，从java到内核。之所以以本篇作为此系列的第一篇，是因为只有了解本篇中的内容，才能理解后续相关文章，本篇内容在后续文章中将会多次提到。</p>
<h2 id="Protocol_family">Protocol family</h2><p>socket作为一种网络编程接口，支持多种协议族，比如IP、Unix domain sockets、Novell IPX等等。linux内核支持的所有协议族常量定义在<code>linux/socket.h</code>中，比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> AF_UNIX     1   /* Unix domain sockets      */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> AF_INET     2   /* Internet IP Protocol     */</span></span><br></pre></td></tr></table></figure></p>
<p>描述协议族的结构是<code>net_proto_family</code>，每一个协议族都必须提供一个net_proto_family变量，这个结构的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_proto_family &#123;</span><br><span class="line">    <span class="keyword">int</span>     family;</span><br><span class="line">    <span class="keyword">int</span>     (*create)(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock,</span><br><span class="line">                  <span class="keyword">int</span> protocol, <span class="keyword">int</span> kern);</span><br><span class="line">    <span class="keyword">struct</span> module   *owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其中，<strong>family</strong>即<em>socket.h</em>中定义的常量，而<strong>create</strong>则是一个方法指针，每个协议族依靠此方法提供创建本协议族socket的方法，下面举一个inet协议族的例子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> net_proto_family inet_family_ops = &#123;</span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所有协议族的定义保存在<code>net_families</code>数组里，其声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> net_proto_family __rcu *net_families[NPROTO] __read_mostly;</span><br></pre></td></tr></table></figure></p>
<p>注册的过程即向net_families添加元素的过程，通过<code>sock_register</code>方法实现。</p>
<h2 id="proto">proto</h2><p>每一个四层协议，如TCP、UDP，都有一个proto结构体，当创建了此协议的socket后，相应的proto变量会保存在socket中，供socket操作使用。proto结构里主要定义了以下几类信息：</p>
<ol>
<li>协议操作的方法指针，比如关闭一个socket需要调用的close方法指针：<code>void (*close)(struct sock *sk, long timeout)</code>，建立连接使用的connect方法指针：<code>int (*connect)(struct sock *sk, struct sockaddr *uaddr,         int addr_len)</code>，发送数据使用的sendmsg方法指针：<code>int (*sendmsg)(struct kiocb *iocb, struct sock *sk,  struct msghdr *msg, size_t len)</code>等等，在以后的文章中用到了再详细说明。</li>
<li>保存协议范围的状态、信息。比如分配内存使用的slab cache: <code>struct kmem_cache   *slab</code>，当前socket数：<code>struct percpu_counter   *sockets_allocated</code>等，在以后的文章中用到了再详细说明。</li>
</ol>
<h2 id="inet_protosw">inet_protosw</h2><p>inet_protosw可以说是协议族和协议之间的桥梁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inet_protosw &#123;</span><br><span class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>   type;     <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>   protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> proto     *prot;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> proto_ops *ops;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，<strong>type</strong>为socket的type，socket函数的第二个参数，具体值见附录: “SOCKET TYPE”。<strong>protocol</strong>为传输层的协议号，定义在<code>./include/uapi/linux/in.h</code>中。<strong>ops</strong>: 通用的接口，其中有可能调用prot的方法，proto_ops的部分属性见附录“proto_ops”。<br>以TCP协议为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    .type =       SOCK_STREAM,</span><br><span class="line">    .protocol =   IPPROTO_TCP,</span><br><span class="line">    .prot =       &amp;tcp_prot,</span><br><span class="line">    .ops =        &amp;inet_stream_ops,</span><br><span class="line">    .flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">              INET_PROTOSW_ICSK,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>在inet协议族中，所支持的协议定义在<code>static struct inet_protosw inetsw_array[]</code>中，并且在初始化时，构建为<code>static struct list_head inetsw[SOCK_MAX]</code>，此数组的每个元素为一个socket type的list。</p>
<h2 id="socket结构">socket结构</h2><p>socket数据结构是一个socket在内核中的体现，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket &#123;</span><br><span class="line">    socket_state        state;</span><br><span class="line"></span><br><span class="line">    kmemcheck_bitfield_begin(type);</span><br><span class="line">    <span class="keyword">short</span>           type;</span><br><span class="line">    kmemcheck_bitfield_end(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> socket_wq __rcu  *wq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> file     *file;</span><br><span class="line">    <span class="keyword">struct</span> sock     *sk;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> proto_ops  *ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，<strong>state</strong>为Socket的状态，具体值见附录：“socket状态”， <strong>type</strong>为socket的类型，具体值见附录：“SOCKET TYPE”。<strong>file</strong>: 回指到file的指针。<strong>sk</strong>: 与网络协议有关的socket的属性，指向的是sock的子类，而不一定是sock结构。由于这个成员很多，涉及到很多方面，以后用到的时候再进行说明。<strong>ops</strong>: 通用的接口，其中有可能调用prot的方法，proto_ops的部分属性见附录“proto_ops”。<strong>flags</strong>: 标识着socket一些状态，比如队列是否已满等等，后续用到时再进行说明。<strong>wq</strong>: 等待队列。</p>
<h2 id="sock结构">sock结构</h2><p>sock是公用属性，其“子类”存放协议相关属性（c语言实现继承，如不清楚请自行google），其继承关系举例为：<br><img src="/images/sock.png" alt="sock继承"></p>
<h2 id="sockfs文件系统">sockfs文件系统</h2><p>为了socket能像文件一样处理，在内核中定义了一种特殊的文件系统-sockfs，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">file_system_t</span>ype <span class="keyword">sock_fs_t</span>ype = &#123; </span><br><span class="line">    .name =     <span class="string">"sockfs"</span>, </span><br><span class="line">    .mount =    sockfs_mount, </span><br><span class="line">    .kill_sb =  kill_anon_super, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中sockfs_mount为mount方法，当mount这种类型的文件系统时，将会调用这个方法。<br>在系统初始化时，mount了一个sockfs类型的文件系统。其中super_operations为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> super_operations sockfs_ops = &#123;</span><br><span class="line">    .alloc_inode    = sock_alloc_inode,</span><br><span class="line">    .destroy_inode  = sock_destroy_inode,</span><br><span class="line">    .statfs     = simple_statfs,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="附录">附录</h2><h3 id="SOCKET_TYPE">SOCKET TYPE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">sock_t</span>ype &#123;</span><br><span class="line">    SOCK_STREAM = <span class="number">1</span>,</span><br><span class="line">    SOCK_DGRAM  = <span class="number">2</span>,</span><br><span class="line">    SOCK_RAW    = <span class="number">3</span>,</span><br><span class="line">    SOCK_RDM    = <span class="number">4</span>,</span><br><span class="line">    SOCK_SEQPACKET  = <span class="number">5</span>,</span><br><span class="line">    SOCK_DCCP   = <span class="number">6</span>,</span><br><span class="line">    SOCK_PACKET = <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="proto_ops">proto_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proto_ops &#123;</span><br><span class="line">    <span class="keyword">int</span>     family;</span><br><span class="line">    <span class="keyword">struct</span> module   *owner;</span><br><span class="line">    <span class="keyword">int</span>     (*release)   (<span class="keyword">struct</span> socket *sock);</span><br><span class="line">    <span class="keyword">int</span>     (*bind)      (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">                      <span class="keyword">struct</span> sockaddr *myaddr,</span><br><span class="line">                      <span class="keyword">int</span> sockaddr_len);</span><br><span class="line">    <span class="keyword">int</span>     (*connect)   (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">                      <span class="keyword">struct</span> sockaddr *vaddr,</span><br><span class="line">                      <span class="keyword">int</span> sockaddr_len, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span>     (*socketpair)(<span class="keyword">struct</span> socket *sock1,</span><br><span class="line">                      <span class="keyword">struct</span> socket *sock2);</span><br><span class="line">    <span class="keyword">int</span>     (*accept)    (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">                      <span class="keyword">struct</span> socket *newsock, <span class="keyword">int</span> flags);</span><br><span class="line">  ...........</span><br></pre></td></tr></table></figure>
<h3 id="socket状态">socket状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    SS_FREE = <span class="number">0</span>,            <span class="comment">/* not allocated        */</span></span><br><span class="line">    SS_UNCONNECTED,         <span class="comment">/* unconnected to any socket    */</span></span><br><span class="line">    SS_CONNECTING,          <span class="comment">/* in process of connecting */</span></span><br><span class="line">    SS_CONNECTED,           <span class="comment">/* connected to socket      */</span></span><br><span class="line">    SS_DISCONNECTING        <span class="comment">/* in process of disconnecting  */</span></span><br><span class="line">&#125; socket_state;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>这是“自顶向下话socket”系列的第一篇，本系列文章计划从java到linux内核，讲解socket的方方面面。除了本篇，其余文章都遵循从顶向下的原则，从java到内核。之所以以本篇作为此系列的第一篇，是因为只有了解本篇中的内容，才能理解后续相关文章，本篇内容在后续文章中将会多次提到。</p>
<h2 id="Protocol_family">Protocol family</h2><p>socket作为一种网络编程接口，支持多种协议族，比如IP、Unix domain sockets、Novell IPX等等。linux内核支持的所有协议族常量定义在<code>linux/socket.h</code>中，比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> AF_UNIX     1   /* Unix domain sockets      */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> AF_INET     2   /* Internet IP Protocol     */</span></span><br></pre></td></tr></table></figure></p>
<p>描述协议族的结构是<code>net_proto_family</code>，每一个协议族都必须提供一个net_proto_family变量，这个结构的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_proto_family &#123;</span><br><span class="line">    <span class="keyword">int</span>     family;</span><br><span class="line">    <span class="keyword">int</span>     (*create)(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock,</span><br><span class="line">                  <span class="keyword">int</span> protocol, <span class="keyword">int</span> kern);</span><br><span class="line">    <span class="keyword">struct</span> module   *owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TenuredGeneration垃圾收集]]></title>
    <link href="http://jangzq.info/2015/08/02/tenure_collect/"/>
    <id>http://jangzq.info/2015/08/02/tenure_collect/</id>
    <published>2015-08-02T11:57:26.000Z</published>
    <updated>2015-08-03T12:01:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>当使用TenuredGeneration作为Old generation时，垃圾收集方法的入口为： <code>TenuredGeneration::collect</code>，只有在full gc时调用，其核心的程序在<code>GenMarkSweep::invoke_at_safepoint</code>中，其主要操作分为4步：</p>
<ol>
<li>标记live的对象，对应<code>mark_sweep_phase1</code>方法。</li>
<li>计算对象新的地址， 对应<code>mark_sweep_phase2</code>方法。</li>
<li>更新引用地址，对应<code>mark_sweep_phase3</code>方法。</li>
<li>将对象移动到新的地址，对应<code>mark_sweep_phase4</code>方法。<br>可以看出，这是一个mark-compact算法，经过以上操作后，不存在内存碎片。</li>
</ol>
<h2 id="标记live对象">标记live对象</h2><a id="more"></a>
<ol>
<li><p>在<code>mark_sweep_phase1</code>方法中，在这里使用MarkSweep::FollowRootClosure处理遍历到的对象，最终调用的函数为：MarkSweep::follow_root。</p>
<ol>
<li><p>标记root对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!obj-&gt;mark()-&gt;is_marked()) &#123;</span><br><span class="line">  mark_object(obj);</span><br><span class="line">  obj-&gt;follow_contents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记这个对象的方法为：mark_object：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> MarkSweep::mark_object(oop obj) &#123;</span><br><span class="line">  <span class="comment">// some marks may contain information we need to preserve so we store them away</span></span><br><span class="line">  <span class="comment">// and overwrite the mark.  We'll restore it at the end of markSweep.</span></span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  obj-&gt;set_mark(markOopDesc::prototype()-&gt;set_marked());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;must_be_preserved(obj)) &#123;</span><br><span class="line">    preserve_mark(obj, mark);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>obj-&gt;follow_contents()</code>将此对象引用的对象放入stack，通过此stack进行广度优先遍历。</p>
</li>
<li>循环遍历被引用的对象，方法为<code>follow_stack()</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkSweep::follow_stack() &#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!_marking_stack.is_empty()) &#123;</span><br><span class="line">      oop obj = _marking_stack.pop();</span><br><span class="line">      assert (obj-&gt;is_gc_marked(), <span class="string">"p must be marked"</span>);</span><br><span class="line">      obj-&gt;follow_contents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process ObjArrays one at a time to avoid marking stack bloat.</span></span><br><span class="line">    <span class="keyword">if</span> (!_objarray_stack.is_empty()) &#123;</span><br><span class="line">      ObjArrayTask task = _objarray_stack.pop();</span><br><span class="line">      objArrayKlass* <span class="keyword">const</span> k = (objArrayKlass*)task.obj()-&gt;blueprint();</span><br><span class="line">      k-&gt;oop_follow_contents(task.obj(), task.index());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!_marking_stack.is_empty() || !_objarray_stack.is_empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>处理java.lang.Reference相关对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ref_processor()-&gt;setup_policy(clear_all_softrefs);</span><br><span class="line">   <span class="keyword">const</span> ReferenceProcessorStats&amp; stats =</span><br><span class="line">     ref_processor()-&gt;process_discovered_references(</span><br><span class="line">       &amp;is_alive, &amp;keep_alive, &amp;follow_stack_closure, NULL, <span class="keyword">_gc_t</span>imer);</span><br><span class="line">   <span class="keyword">gc_t</span>racer()-&gt;report_gc_reference_stats(stats);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="计算对象新的地址">计算对象新的地址</h2><p>调用GenCollectedHeap::prepare_for_compaction，其中从old—&gt;young，依次调用generation上的prepare_for_compaction。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Generation* scanning_gen = _gens[_n_gens-<span class="number">1</span>];</span><br><span class="line"><span class="comment">// Start by compacting into same gen.</span></span><br><span class="line"><span class="function">CompactPoint <span class="title">cp</span><span class="params">(scanning_gen, NULL, NULL)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (scanning_gen != NULL) &#123;</span><br><span class="line">  scanning_gen-&gt;prepare_for_compaction(&amp;cp);</span><br><span class="line">  scanning_gen = prev_gen(scanning_gen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>generation中的prepare_for_compaction，调用各个区域的prepare_for_compaction，比如DefNewGeneration中的eden、from、to。在DefNewGeneration的垃圾收集文章里，介绍了这个链表是如何构成的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic implementation, can be specialized</span></span><br><span class="line">CompactibleSpace* space = first_compaction_space();</span><br><span class="line"><span class="keyword">while</span> (space != NULL) &#123;</span><br><span class="line">  space-&gt;prepare_for_compaction(cp);</span><br><span class="line">  space = space-&gt;next_compaction_space();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ContiguousSpace::prepare_for_compaction如下：</p>
<ol>
<li><p>mark-compact的本意是将所有存活的对象全部挪到空间的一端，消除碎片，但是如果一开始只存在少量的碎片，挪动所有对象带来的开销很大，但是收到的效果不大，所以引入了几个参数控制是否进行挪动。<br>MarkSweepAlwaysCompactCount: 每执行MarkSweepAlwaysCompactCount次，不计代价的执行一次全挪动的操作。<br>MarkSweepDeadRatio：考虑挪动代价的时候，允许多大的空间可以作为碎片存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> skip_dead = (MarkSweepAlwaysCompactCount &lt; <span class="number">1</span>)                         \</span><br><span class="line">  ||((invocations % MarkSweepAlwaysCompactCount) != <span class="number">0</span>);    </span><br><span class="line"><span class="keyword">size_t</span> allowed_deadspace = <span class="number">0</span>;                                              \</span><br><span class="line"><span class="keyword">if</span> (skip_dead) &#123;                                                           \</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> ratio = allowed_dead_ratio();                               \</span><br><span class="line">  allowed_deadspace = (capacity() * ratio / <span class="number">100</span>) / HeapWordSize;           \</span><br><span class="line">&#125;                                                                          \</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历整个空间。compact_top指向下一个alive对象可以挪到的位置，q为当前遍历指针，以下操作循环执行。</p>
<ol>
<li><p>当q所指向的对象是alive对象时，将此对象的forwarding指针置为当前compact_top，并且修改compact_top为compact_top+对象大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_is_obj(q) &amp;&amp; oop(q)-&gt;is_gc_marked()) &#123;                         \</span><br><span class="line">  <span class="comment">/* prefetch beyond q */</span>                                                \</span><br><span class="line">  Prefetch::write(q, interval);                                          \</span><br><span class="line">  <span class="comment">/* size_t size = oop(q)-&gt;size();  changing this for cms for perm gen */</span>\</span><br><span class="line">  <span class="keyword">size_t</span> size = block_size(q);                                           \</span><br><span class="line">  <span class="keyword">compact_t</span>op = cp-&gt;space-&gt;forward(oop(q), size, cp, <span class="keyword">compact_t</span>op);       \</span><br><span class="line">  q += size;                                                             \</span><br><span class="line">  end_of_live = q;                                                       \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当q指向的对象不alive时，首先找到下一个alive的对象,end指向下一个alive对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;                                                                   \</span><br><span class="line">   <span class="comment">/* prefetch beyond end */</span>                                            \</span><br><span class="line">   Prefetch::write(end, interval);                                      \</span><br><span class="line">   end += block_size(end);                                              \</span><br><span class="line"> &#125; <span class="keyword">while</span> (end &lt; t &amp;&amp; (!block_is_obj(end) || !oop(end)-&gt;is_gc_marked()));</span><br></pre></td></tr></table></figure>
<p>然后判断中间的碎片是否需要跳过，如果需要跳过，除了满足上文提到的<code>allowed_deadspace</code>条件，还有当前指针必须是compact_top时，才能跳过，否则就跳不过了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (allowed_deadspace &gt; <span class="number">0</span> &amp;&amp; q == <span class="keyword">compact_t</span>op) &#123;                       \</span><br><span class="line">  <span class="keyword">size_t</span> sz = pointer_delta(end, q);                                   \</span><br><span class="line">  <span class="keyword">if</span> (insert_deadspace(allowed_deadspace, q, sz)) &#123;                    \</span><br><span class="line">    <span class="keyword">compact_t</span>op = cp-&gt;space-&gt;forward(oop(q), sz, cp, <span class="keyword">compact_t</span>op);     \</span><br><span class="line">    q = end;                                                           \</span><br><span class="line">    end_of_live = end;                                                 \</span><br><span class="line">    <span class="keyword">continue</span>;                                                          \</span><br><span class="line">  &#125;                                                                    \</span><br><span class="line">&#125;                                                                      \</span><br></pre></td></tr></table></figure>
<p>如果不能跳过，则需要修正当前liveRange的值，并且开始一个新的liveRange， liveRange记录了最近一次alive对象组成的连续空间，liveRange复用了free space空间，liveRange在下一步需要遍历alive对象时，可以跳过其间的碎片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (liveRange) &#123;                                                       \</span><br><span class="line">  liveRange-&gt;set_end(q);                                               \</span><br><span class="line">&#125;     </span><br><span class="line">liveRange = (LiveRange*)q;                                             \</span><br><span class="line">liveRange-&gt;set_start(end);                                             \</span><br><span class="line">liveRange-&gt;set_end(end);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="更新引用地址">更新引用地址</h2><p>经过上一步之后，每个alive对象的forwarding指针都记录了以后将要挪到的位置。在这一步里，修改所有引用这些对象的指针的地址。<br>核心代码入口： CompactibleSpace::adjust_pointers</p>
<ol>
<li><p>在第二步里，有可能在一开始的地方，保留了一部分碎片（不是alive的对象），所以，需要遍历范围里面所有的对象，包括dead的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q &lt; t &amp;&amp; _first_dead &gt; q &amp;&amp;                                               \</span><br><span class="line">      !oop(q)-&gt;is_gc_marked()) &#123;                                                \</span><br><span class="line">    HeapWord* end = _first_dead;                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">    <span class="keyword">while</span> (q &lt; end) &#123;                                                           \</span><br><span class="line">      <span class="comment">/* point all the oops to the new location */</span>                              \</span><br><span class="line">      <span class="keyword">size_t</span> size = oop(q)-&gt;adjust_pointers();                                  \</span><br><span class="line">      size = adjust_obj_size(size);                                             \</span><br><span class="line">                                                                                \</span><br><span class="line">      q += size;                                                                \</span><br><span class="line">    &#125;                                                                           \</span><br><span class="line">                                                                                \</span><br><span class="line">    <span class="keyword">if</span> (_first_dead == t) &#123;                                                     \</span><br><span class="line">      q = t;                                                                    \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line">      <span class="comment">/* $$$ This is funky.  Using this to read the previously written          \</span><br><span class="line">       * LiveRange.  See also use below. */</span>                                     \</span><br><span class="line">      q = (HeapWord*)oop(_first_dead)-&gt;mark()-&gt;decode_pointer();                \</span><br><span class="line">    &#125;                                                                           \</span><br><span class="line">  &#125;                                                                             \</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理后面的alive对象，当处理的对象不是alive的，那么保留着下一个alive对象的指针，所以可以越过dead的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q &lt; t) &#123;                                                               \</span><br><span class="line">  <span class="comment">/* prefetch beyond q */</span>                                                     \</span><br><span class="line">  Prefetch::write(q, interval);                                               \</span><br><span class="line">  <span class="keyword">if</span> (oop(q)-&gt;is_gc_marked()) &#123;                                               \</span><br><span class="line">    <span class="comment">/* q is alive */</span>                                                          \</span><br><span class="line">    VALIDATE_MARK_SWEEP_ONLY(MarkSweep::track_interior_pointers(oop(q)));     \</span><br><span class="line">    <span class="comment">/* point all the oops to the new location */</span>                              \</span><br><span class="line">    <span class="keyword">size_t</span> size = oop(q)-&gt;adjust_pointers();                                  \</span><br><span class="line">    size = adjust_obj_size(size);                                             \</span><br><span class="line">    VALIDATE_MARK_SWEEP_ONLY(MarkSweep::check_interior_pointers());           \</span><br><span class="line">    VALIDATE_MARK_SWEEP_ONLY(MarkSweep::validate_live_oop(oop(q), size));     \</span><br><span class="line">    debug_only(prev_q = q);                                                   \</span><br><span class="line">    q += size;                                                                \</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line">    <span class="comment">/* q is not a live object, so its mark should point at the next           \</span><br><span class="line">     * live object */</span>                                                         \</span><br><span class="line">    debug_only(prev_q = q);                                                   \</span><br><span class="line">    q = (HeapWord*) oop(q)-&gt;mark()-&gt;decode_pointer();                         \</span><br><span class="line">    assert(q &gt; prev_q, <span class="string">"we should be moving forward through memory"</span>);         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">&#125;                                                                             \</span><br><span class="line">                                                                              \</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="将对象移动到新的地址">将对象移动到新的地址</h2><p>现在开始挪动，入口在<code>CompactibleSpace::compact</code>。</p>
<ol>
<li><p>首先跳过包含保留了一部分碎片的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q &lt; t &amp;&amp; _first_dead &gt; q &amp;&amp;                                               \</span><br><span class="line">    !oop(q)-&gt;is_gc_marked()) &#123;                                                \</span><br><span class="line">  <span class="keyword">if</span> (_first_dead == t) &#123;                                                     \</span><br><span class="line">    q = t;                                                                    \</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line">    <span class="comment">/* $$$ Funky */</span>                                                           \</span><br><span class="line">    q = (HeapWord*) oop(_first_dead)-&gt;mark()-&gt;decode_pointer();               \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">&#125;                                                                             \</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理后面的alive对象，当处理的对象不是alive的，那么保留着下一个alive对象的指针，所以可以越过dead的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q &lt; t) &#123;                                                               \</span><br><span class="line">  <span class="keyword">if</span> (!oop(q)-&gt;is_gc_marked()) &#123;                                              \</span><br><span class="line">    <span class="comment">/* mark is pointer to next marked oop */</span>                                  \</span><br><span class="line">    debug_only(prev_q = q);                                                   \</span><br><span class="line">    q = (HeapWord*) oop(q)-&gt;mark()-&gt;decode_pointer();                         \</span><br><span class="line">    assert(q &gt; prev_q, <span class="string">"we should be moving forward through memory"</span>);         \</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line">    <span class="comment">/* prefetch beyond q */</span>                                                   \</span><br><span class="line">    Prefetch::read(q, scan_interval);                                         \</span><br><span class="line">                                                                              \</span><br><span class="line">    <span class="comment">/* size and destination */</span>                                                \</span><br><span class="line">    <span class="keyword">size_t</span> size = obj_size(q);                                                \</span><br><span class="line">    HeapWord* <span class="keyword">compaction_t</span>op = (HeapWord*)oop(q)-&gt;forwardee();                \</span><br><span class="line">                                                                              \</span><br><span class="line">    <span class="comment">/* prefetch beyond compaction_top */</span>                                      \</span><br><span class="line">    Prefetch::write(<span class="keyword">compaction_t</span>op, copy_interval);                           \</span><br><span class="line">                                                                              \</span><br><span class="line">    <span class="comment">/* copy object and reinit its mark */</span>                                     \</span><br><span class="line">    VALIDATE_MARK_SWEEP_ONLY(MarkSweep::<span class="keyword">live_oop_moved_t</span>o(q, size,            \</span><br><span class="line">                                                          <span class="keyword">compaction_t</span>op));   \</span><br><span class="line">    assert(q != <span class="keyword">compaction_t</span>op, <span class="string">"everything in this pass should be moving"</span>);  \</span><br><span class="line">    Copy::aligned_conjoint_words(q, <span class="keyword">compaction_t</span>op, size);                    \</span><br><span class="line">    oop(<span class="keyword">compaction_t</span>op)-&gt;init_mark();                                         \</span><br><span class="line">    assert(oop(<span class="keyword">compaction_t</span>op)-&gt;klass() != NULL, <span class="string">"should have a class"</span>);      \</span><br><span class="line">                                                                              \</span><br><span class="line">    debug_only(prev_q = q);                                                   \</span><br><span class="line">    q += size;                                                                \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">&#125;                                                                             \</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>当使用TenuredGeneration作为Old generation时，垃圾收集方法的入口为： <code>TenuredGeneration::collect</code>，只有在full gc时调用，其核心的程序在<code>GenMarkSweep::invoke_at_safepoint</code>中，其主要操作分为4步：</p>
<ol>
<li>标记live的对象，对应<code>mark_sweep_phase1</code>方法。</li>
<li>计算对象新的地址， 对应<code>mark_sweep_phase2</code>方法。</li>
<li>更新引用地址，对应<code>mark_sweep_phase3</code>方法。</li>
<li>将对象移动到新的地址，对应<code>mark_sweep_phase4</code>方法。<br>可以看出，这是一个mark-compact算法，经过以上操作后，不存在内存碎片。</li>
</ol>
<h2 id="标记live对象">标记live对象</h2>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ParNewGeneration垃圾收集]]></title>
    <link href="http://jangzq.info/2015/07/31/ParNewGeneration_collect/"/>
    <id>http://jangzq.info/2015/07/31/ParNewGeneration_collect/</id>
    <published>2015-07-31T14:20:11.000Z</published>
    <updated>2015-08-01T09:08:26.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>使用-XX:+UseParNewGC参数时，young generation为ParNewGeneration，其垃圾收集入口为：ParNewGeneration::collect。<br><a id="more"></a></p>
<ol>
<li><p>首先计算垃圾收集需要的线程数。<br>入口函数为：AdaptiveSizePolicy::calc_active_workers。</p>
<ol>
<li><p>如果设置了ParallelGCThreads参数，或者没有设置UseDynamicNumberOfGCThreads参数，则使用由ParallelGCThreads指定的所有线程,ParallelGCThreads默认值的计算方式见附录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!UseDynamicNumberOfGCThreads ||</span><br><span class="line">   (!FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; !ForceDynamicNumberOfGCThreads)) &#123;</span><br><span class="line">  new_active_workers = total_workers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForceDynamicNumberOfGCThreads为诊断参数，平时恒为false。</p>
</li>
<li><p>否则，动态计算线程数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_active_workers = calc_default_active_workers(total_workers,</span><br><span class="line">                                               <span class="number">2</span>, <span class="comment">/* Minimum number of workers */</span></span><br><span class="line">                                               active_workers,</span><br><span class="line">                                               application_workers);</span><br></pre></td></tr></table></figure>
<p>动态线程数由三个因素决定：上次的线程数、当前的用户线程数、heap大小。<br>通过当前的用户线程数，计算出一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">active_workers_by_JT =</span><br><span class="line">  MAX2((uintx) GCWorkersPerJavaThread * application_workers,</span><br><span class="line">       min_workers);</span><br></pre></td></tr></table></figure>
<p>注：GCWorkersPerJavaThread为2。</p>
<p>通过heap大小计算出一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">active_workers_by_heap_size =</span><br><span class="line">   MAX2((<span class="keyword">size_t</span>) <span class="number">2U</span>, Universe::heap()-&gt;capacity() / HeapSizePerGCThread);</span><br></pre></td></tr></table></figure>
<p>注：HeapSizePerGCThread缺省为64m，可调。</p>
<p>新的active线程数，即这两个值的较大者，但是不能超过ParallelGCThreads，并且如果新的线程数小于之前的线程数，设为两者的中间值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uintx max_active_workers =</span><br><span class="line">MAX2(active_workers_by_JT, active_workers_by_heap_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Limit the number of workers to the the number created,</span></span><br><span class="line"><span class="comment">// (workers()).</span></span><br><span class="line">new_active_workers = MIN2(max_active_workers,</span><br><span class="line">                              (uintx) total_workers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Increase GC workers instantly but decrease them more</span></span><br><span class="line"><span class="comment">// slowly.</span></span><br><span class="line"><span class="keyword">if</span> (new_active_workers &lt; prev_active_workers) &#123;</span><br><span class="line">  new_active_workers =</span><br><span class="line">    MAX2(min_workers, (prev_active_workers + new_active_workers) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>先判断进行垃圾回收是否能成功，如果不能成功就直接跳过此Generation，同DefNewGeneration。</p>
</li>
<li><p>并行遍历alive的oop。 代码入口：<code>void ParNewGenTask::work(uint worker_id)</code>， 将DefNewGeneration中的垃圾收集方式进行并行化，需要解决下面几个并行问题：<br>在并行收集中，每一个回收线程拥有自己单独的ParScanThreadState，用来管理本回收线程的local信息。</p>
<ul>
<li><p>并行的遍历root reference。<br>要处理的root reference包括：Universe中的预定义oop，jni global reference，jni local reference， local stack等等。对于全局的（即不属于某一线程）root reference，遍历的时候会设置一个标识位，如果有回收线程正在处理，就跳过去，代码示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">_process_strong_t</span>asks-&gt;<span class="keyword">is_t</span>ask_claimed(SH_PS_Universe_oops_do)) &#123;</span><br><span class="line">   Universe::oops_do(roots);</span><br><span class="line">   <span class="comment">// Consider perm-gen discovered lists to be strong.</span></span><br><span class="line">   perm_gen()-&gt;ref_processor()-&gt;weak_oops_do(roots);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对于各个用户线程的扫描，每一个线程存在一个Thread::_oops_do_parity变量，而每次收集也有一个对应的标识符SharedHeap::_strong_roots_parity，一个回收线程遍历一个线程时，如果这两个值相同，则说明这个线程已经遍历或者正在遍历，否则使用cmpxchg，原子性的将_oops_do_parity设置为当前的_strong_roots_parity，如果设置成功，就有此回收线程进行遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Thread::claim_oops_do_par_case(<span class="keyword">int</span> strong_roots_parity) &#123;</span><br><span class="line">  jint thread_parity = _oops_do_parity;</span><br><span class="line">  <span class="keyword">if</span> (thread_parity != strong_roots_parity) &#123;</span><br><span class="line">    jint res = Atomic::cmpxchg(strong_roots_parity, &amp;_oops_do_parity, thread_parity);</span><br><span class="line">    <span class="keyword">if</span> (res == thread_parity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      guarantee(res == strong_roots_parity, <span class="string">"Or else what?"</span>);</span><br><span class="line">      assert(SharedHeap::heap()-&gt;workers()-&gt;active_workers() &gt; <span class="number">0</span>,</span><br><span class="line">         <span class="string">"Should only fail when parallel."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(SharedHeap::heap()-&gt;workers()-&gt;active_workers() &gt; <span class="number">0</span>,</span><br><span class="line">         <span class="string">"Should only fail when parallel."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并行的将对象拷贝到to或者promote到下一generation。由于同一个对象有可能通过不同的路径引用，所以很有可能两个回收线程同时拷贝一个对象。在ParNewGeneration中使用ParScanClosure::do_oop_work来处理遍历到的对象。</p>
<ol>
<li>如果此对象已经包含了forwarding指针，说明已经被拷贝了，或者正在拷贝，则读出其真正的forwarding指针。所谓什么是“真正”，下文有详细描述。</li>
<li>如果没有包含forwarding指针，则调用ParNewGeneration::copy_to_survivor_space方法将对象拷贝到to区域，或者到下一个generation。这个方法根据下一generation是否支持promote undo，有两种实现方式。对于cms，不支持undo promote，所以使用<code>copy_to_survivor_space_avoiding_promotion_undo</code>方法，而普通的TenureGeneration则支持undo，使用<code>copy_to_survivor_space_with_undo</code>方法。简单的说，在<code>copy_to_survivor_space_avoiding_promotion_undo</code>方法中，在promote前，就用一个“假的”指针设置了forwarding指针，所以不会有两个线程同时promote，而在<code>copy_to_survivor_space_with_undo</code>中，则是发现了两个线程都copy了，可以调用下一generation的方法进行undo。这两个方法详细描述见附录。</li>
</ol>
</li>
<li><p>循环遍历处理root reference发现的对象发出的引用，处理每一个对象的方法为<code>ParEvacuateFollowersClosure::do_void</code>。<br>在处理root reference时，将待处理的对象放到了一个ParScanThreadState中的队列中，所以在这里就是处理此队列，为了防止都在一个队列的情况，回收线程处理完自己队列里的后，还可以处理别的线程队列里的对象。循环进行下列操作，直到完成。</p>
<ol>
<li><p>处理自己队列里的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">par_scan_state()-&gt;trim_queues(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理完自己的对象，从别的线程里得到处理的对象, 和全局存放的溢出的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (task_queues()-&gt;steal(par_scan_state()-&gt;thread_num(),</span><br><span class="line">                          par_scan_state()-&gt;hash_seed(),</span><br><span class="line">                          <span class="keyword">obj_t</span>o_scan)) &#123;</span><br><span class="line">   <span class="keyword">bool</span> res = work_q-&gt;push(<span class="keyword">obj_t</span>o_scan);</span><br><span class="line">   assert(res, <span class="string">"Empty queue should have room for a push."</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//   if successful, goto Start.</span></span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// try global overflow list.</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (par_gen()-&gt;take_from_overflow_list(par_scan_state())) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>处理java.lang.Reference相关对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rp-&gt;processing_is_mt()) &#123;</span><br><span class="line">    <span class="function">ParNewRefProcTaskExecutor <span class="title">task_executor</span><span class="params">(*<span class="keyword">this</span>, thread_state_set)</span></span>;</span><br><span class="line">    stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                              &amp;evacuate_followers, &amp;task_executor,</span><br><span class="line">                                              <span class="keyword">_gc_t</span>imer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    thread_state_set.flush();</span><br><span class="line">    gch-&gt;<span class="keyword">set_par_t</span>hreads(<span class="number">0</span>);  <span class="comment">// 0 ==&gt; non-parallel.</span></span><br><span class="line">    gch-&gt;save_marks();</span><br><span class="line">    stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,</span><br><span class="line">                                              &amp;evacuate_followers, NULL,</span><br><span class="line">                                              <span class="keyword">_gc_t</span>imer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行完了收集，其余诸如交换from 和 to，和DefNewGeneration没有太大的本质区别，就不再赘述了。</p>
</li>
</ol>
<h2 id="附录">附录</h2><h3 id="ParallelGCThreads缺省值计算方法">ParallelGCThreads缺省值计算方法</h3><p>入口在：Abstract_VM_Version::nof_parallel_worker_threads<br>主机的cpu如果小于8个，则使用cpu数，如果大于8个，则每增加一个cpu，不再增加一个线程，而是按一个比例增加，即使用如下公式计算。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(switch_pt + ((ncpus - switch_pt) * num) / den)</span><br></pre></td></tr></table></figure></p>
<p>其中，switch_pt：8, ncpus为cpu数， num：5, den：8。</p>
<h3 id="copy_to_survivor_space_avoiding_promotion_undo">copy_to_survivor_space_avoiding_promotion_undo</h3><p>诸如age判断之类的同DefNewGeneration，这里不再赘述。总体思路是，多个回收线程可以同时将一个对象拷贝到to区域，然后采用cas的方式设置源对象的forwarding指针，后设置的退回自己分配的内存。如果在to内存上分配失败，或者超过了age，也先使用cas修改forwarding指针，置为一个“假的”指针，然后在promote到下一个generation。为了达到在to上可以退回分配的内存，在ParScanThreadState中引入了一个ParGCAllocBuffer变量_to_space_alloc_buffer，_to_space_alloc_buffer管理着本回收线程在to区域上分配的内存，退回的内存可以再处理下一个对象时重新使用。</p>
<ol>
<li><p>在to上分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dummyOld.age() &lt; <span class="keyword">tenuring_t</span>hreshold()) &#123;</span><br><span class="line">    new_obj = (oop)par_scan_state-&gt;<span class="keyword">alloc_in_t</span>o_space(sz);</span><br><span class="line">    <span class="keyword">if</span> (new_obj == NULL) &#123;</span><br><span class="line">      set_survivor_overflow(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在to上没有分配成功，或者age超过了阈值，则先使用cas修改forwarding指针，置为一个“假的”指针，然后在promote到下一个generation，在修改forwarding指针时，如果发现别的回收线程捷足先登，则返回别人设置的“真正”的forwarding指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">forward_ptr = old-&gt;<span class="keyword">forward_t</span>o_atomic(ClaimedForwardPtr);</span><br><span class="line"><span class="keyword">if</span> (forward_ptr != NULL) &#123;</span><br><span class="line">  <span class="comment">// someone else beat us to it.</span></span><br><span class="line">    <span class="keyword">return</span> real_forwardee(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_obj = _next_gen-&gt;par_promote(par_scan_state-&gt;thread_num(),</span><br><span class="line">                                   old, m, sz);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果promote失败，处理方式和DefNewGeneration本质一样，不再赘述。</p>
<ol>
<li>如果在to上分配成功了，除了拷贝、修改age等常规动作外，使用cas，修改fowarding。</li>
<li>如果在以上cas操作中，是本线程胜利了，则将原来的对象加入到下一步scan的队列中。如果本线程没有胜利，如果已经在to分配了，调用<code>par_scan_state-&gt;undo_alloc_in_to_space((HeapWord*)new_obj, sz)</code>退回内存。</li>
</ol>
<h3 id="copy_to_survivor_space_with_undo">copy_to_survivor_space_with_undo</h3><p>诸如age判断之类的同DefNewGeneration，这里不再赘述。</p>
<ol>
<li><p>在to上分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dummyOld.age() &lt; <span class="keyword">tenuring_t</span>hreshold()) &#123;</span><br><span class="line">  new_obj = (oop)par_scan_state-&gt;<span class="keyword">alloc_in_t</span>o_space(sz);</span><br><span class="line">  <span class="keyword">if</span> (new_obj == NULL) &#123;</span><br><span class="line">    set_survivor_overflow(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在to上没有分配成功，或者age超过了阈值，直接在下一generation分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_obj = _next_gen-&gt;par_promote(par_scan_state-&gt;thread_num(),</span><br><span class="line">                                      old, m, sz);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在to上分配成功了，进行拷贝、修改age等常规动作。</p>
</li>
<li><p>如果上述的to上分配和promote没有出错，通过cas修改forwarding。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">failed_t</span>o_promote) &#123;</span><br><span class="line">  forward_ptr = old-&gt;<span class="keyword">forward_t</span>o_atomic(new_obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在以上cas操作中，是本线程胜利了，则将原来的对象加入到下一步scan的队列中，然后返回。</p>
</li>
<li>如果在cas修改中失败了，如果在to里分配的，调用<code>par_scan_state-&gt;undo_alloc_in_to_space((HeapWord*)new_obj, sz)</code>退回内存。如果在next generation里分配，调用<code>_next_gen-&gt;par_promote_alloc_undo</code>进行undo。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_in_reserved(new_obj)) &#123;</span><br><span class="line">   <span class="comment">// Must be in to_space.</span></span><br><span class="line">   assert(to()-&gt;is_in_reserved(new_obj), <span class="string">"Checking"</span>);</span><br><span class="line">   par_scan_state-&gt;<span class="keyword">undo_alloc_in_t</span>o_space((HeapWord*)new_obj, sz);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   assert(!_avoid_promotion_undo, <span class="string">"Should not be here if avoiding."</span>);</span><br><span class="line">   _next_gen-&gt;par_promote_alloc_undo(par_scan_state-&gt;thread_num(),</span><br><span class="line">                                     (HeapWord*)new_obj, sz);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>使用-XX:+UseParNewGC参数时，young generation为ParNewGeneration，其垃圾收集入口为：ParNewGeneration::collect。<br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DefNewGeneration垃圾收集]]></title>
    <link href="http://jangzq.info/2015/07/31/DefNewGeneration_collect/"/>
    <id>http://jangzq.info/2015/07/31/DefNewGeneration_collect/</id>
    <published>2015-07-31T14:12:10.000Z</published>
    <updated>2015-08-01T09:09:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>DefNewGeneration的垃圾回收方法入口在：DefNewGeneration::collect。<br><a id="more"></a></p>
<ul>
<li><p>首先判断在DefNewGeneration进行垃圾回收是否能成功，如果不能成功就直接跳过此Generation，否则白做无用工。判断的逻辑在DefNewGeneration::collection_attempt_is_safe，如果可以进行回收，返回true.</p>
<ol>
<li><p>首先判断to区域是否是空的，如果不空，说明上次回收都没有搞彻底，所以返回false。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!to()-&gt;is_empty()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    <span class="keyword">gclog_or_t</span>ty-&gt;print(<span class="string">" :: to is not empty :: "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过调用next generation的promotion_attempt_is_safe方法，得到next generation是否能容纳目前本generation已经使用的内存，如果能容纳，返回true，否则false。（一般在并不是只判断能不容纳当前的最大内存，而是也使用历史经验值判断）。</p>
</li>
</ol>
<p>此时在返回前，设置_incremental_collection_failed为true，即incremental collection将会失败。</p>
</li>
<li><p>遍历所有的root reference，处理现在存活的root对象，使用FastScanClosure处理每一个遍历到的oop， FastScanClosure的处理方法见附录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;gen_process_strong_roots(_level,</span><br><span class="line">                                <span class="keyword">true</span>,  <span class="comment">// Process younger gens, if any,</span></span><br><span class="line">                                       <span class="comment">// as strong roots.</span></span><br><span class="line">                                <span class="keyword">true</span>,  <span class="comment">// activate StrongRootsScope</span></span><br><span class="line">                                <span class="keyword">false</span>, <span class="comment">// not collecting perm generation.</span></span><br><span class="line">                                SharedHeap::SO_AllClasses,</span><br><span class="line">                                &amp;fsc_with_no_gc_barrier,</span><br><span class="line">                                <span class="keyword">true</span>,   <span class="comment">// walk *all* scavengable nmethods</span></span><br><span class="line">                                &amp;fsc_with_gc_barrier);</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历上一步得到root对象，遍历它们引用的对象，使用FastScanClosure处理每一个oop，直到遍历完。这是由<code>fastEvacuateFollowersClosure::do_void</code>实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  _gch-&gt;oop_since_save_marks_iterate(_level, _scan_cur_or_nonheap,</span><br><span class="line">                                     _scan_older);</span><br><span class="line">&#125; <span class="keyword">while</span> (!_gch-&gt;no_allocs_since_save_marks(_level));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在之前的遍历里，记录了所有java.lang.Reference相关对象，下面处理这些对象，处理方法和前面的类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FastKeepAliveClosure <span class="title">keep_alive</span><span class="params">(<span class="keyword">this</span>, &amp;scan_weak_ref)</span></span>;</span><br><span class="line">ReferenceProcessor* rp = ref_processor();</span><br><span class="line">rp-&gt;setup_policy(clear_all_soft_refs);</span><br><span class="line"><span class="keyword">const</span> ReferenceProcessorStats&amp; stats =</span><br><span class="line">  rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive, &amp;evacuate_followers,</span><br><span class="line">                                    NULL, <span class="keyword">_gc_t</span>imer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有发生promote错误，则</p>
<ol>
<li>交换from 和 to。</li>
<li>重新计算_tenuring_threshold，见附录。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swap_spaces();</span><br><span class="line"></span><br><span class="line">assert(to()-&gt;is_empty(), <span class="string">"to space should be empty now"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the desired survivor size to half the real survivor space</span></span><br><span class="line"><span class="keyword">_tenuring_t</span>hreshold =</span><br><span class="line">  <span class="keyword">age_t</span>able()-&gt;<span class="keyword">compute_tenuring_t</span>hreshold(to()-&gt;capacity()/HeapWordSize);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如果发生了promote错误，则</p>
<ol>
<li><p>如果一个对象已经挪到了新位置，并且所有引用它的指针已经指向了新位置，所以老的位置的对象就可以清除了，在成功的进行了gc时，整个from（原来的from）都可以不要，所以没必要单独处理每一个对象，但是现在由于eden、from 、to区域里都有活动的对象，以后进行full gc时，需要查看此区域，所以需要将eden和from区域里的对象里的forward oop全部清除。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_forwarding_pointers();</span><br></pre></td></tr></table></figure>
</li>
<li><p>交换from 和 to。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap_spaces();   <span class="comment">// For uniformity wrt ParNewGeneration.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>eden、from 、to区域里都有活动的对象，所以需要将to区域也加入到以后full gc需要compact的区域队列里。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from()-&gt;set_next_compaction_space(to());</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置incremental collection失败了的标志，</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;set_incremental_collection_failed();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通知next generation，发生了promote failure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_next_gen-&gt;promotion_failure_occurred();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="附录">附录</h2><h3 id="FastScanClosure">FastScanClosure</h3><p>如果对象在此generation里，进行下列处理，否则返回。<br>已经forward过了，则返回新地址，否则调用copy_to_survivor_space，拷贝到to或者promote到下一generation,并且返回新地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()</span><br><span class="line">                                    : _g-&gt;<span class="keyword">copy_t</span>o_survivor_space(obj);</span><br><span class="line">oopDesc::encode_store_heap_oop_not_null(p, new_obj);</span><br></pre></td></tr></table></figure></p>
<h3 id="DefNewGeneration::copy_to_survivor_space">DefNewGeneration::copy_to_survivor_space</h3><ol>
<li>如果oop的age小于阈值_tenuring_threshold，在to区域分配内存，如果分配成功，将对象拷贝到to区域，并且增加object的age。</li>
<li>如果在to上分配没有成功，或者age大于阈值，提升到下一个generation，如果promote失败，则留在原地。</li>
<li>如果移动成功了，则在原来的对象头上，记录forward到的新指针，并且增加age值。</li>
</ol>
<h3 id="重新计算_tenuring_threshold">重新计算_tenuring_threshold</h3><p>在每次gc之后，根据young generation里现存对象大小，计算出新的_tenuring_threshold，目标是使目前的对象大小，小于<code>to的大小 * TargetSurvivorRatio</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">  total += sizes[age];</span><br><span class="line">  <span class="comment">// check if including objects of age 'age' made us pass the desired</span></span><br><span class="line">  <span class="comment">// size, if so 'age' is the new threshold</span></span><br><span class="line">  <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">  age++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="正文">正文</h2><p>DefNewGeneration的垃圾回收方法入口在：DefNewGeneration::collect。<br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之垃圾收集]]></title>
    <link href="http://jangzq.info/2015/07/29/GenCollectedHeap_collect/"/>
    <id>http://jangzq.info/2015/07/29/GenCollectedHeap_collect/</id>
    <published>2015-07-29T13:51:12.000Z</published>
    <updated>2015-07-29T14:02:29.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="VM_GenCollectForAllocation">VM_GenCollectForAllocation</h2><p>在<a href="http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/">分代内存管理之慢速路径内存分配</a>中提到，当分配内存不成功时，使用VM_GenCollectForAllocation来进行GC并且分配，下面详细描述。<br>在<code>VM_GenCollectForAllocation::doit()</code> 方法中，调用了<code>GenCollectedHeap</code>的<code>satisfy_failed_allocation</code>方法，此方法又委托给了<code>GenCollectorPolicy::satisfy_failed_allocation</code>方法，下面即这个方法的实现方式。</p>
<ol>
<li><p>如果当前有jni方法在critical区域，并且有线程要求gc，则不能再请求GC，否则白白阻塞，所以heap如果还有扩展的空间，则扩展，并且分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GC_locker::is_active_and_needs_gc()) &#123;</span><br><span class="line"> <span class="comment">// GC locker is active; instead of a collection we will attempt</span></span><br><span class="line"> <span class="comment">// to expand the heap, if there's room for expansion.</span></span><br><span class="line">   <span class="keyword">if</span> (!gch-&gt;is_maximal_no_gc()) &#123;</span><br><span class="line">      result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;   <span class="comment">// could be null if we are out of space</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果GC没有被阻塞，则根据GenCollectedHeap的incremental_collection_will_fail决定进行full gc还是incremental gc. 如果incremental_collection_will_fail返回true，说明incremental gc将要失败，所以需要进行full gc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">  <span class="comment">// Do an incremental collection.</span></span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    <span class="keyword">gclog_or_t</span>ty-&gt;print(<span class="string">" :: Trying full because partial may fail :: "</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垃圾收集完成后，继续尝试分配内存，如果不成功，则尝试扩展堆大小，然后再次分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/*first_only*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, collection failed, try expansion.</span></span><br><span class="line">result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果还是不能成功分配，则进行一次full gc，并且清除所有soft reference。然后再次分配，如果成功，返回地址，否则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line"> result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/* first_only */</span>);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(!should_clear_all_soft_refs(),</span><br><span class="line">  <span class="string">"Flag should have been handled and cleared prior to this point"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// What else?  We might try synchronous finalization later.  If the total</span></span><br><span class="line"><span class="comment">// space available is large enough for the allocation, then a more</span></span><br><span class="line"><span class="comment">// complete compaction phase than we've tried so far might be</span></span><br><span class="line"><span class="comment">// appropriate.</span></span><br><span class="line"><span class="keyword">return</span> NULL;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="GenCollectedHeap::do_collection">GenCollectedHeap::do_collection</h2><a id="more"></a>
<ol>
<li><p>如果当前有线程进行jni操作，并且位于critical区域，则直接退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GC_locker::check_active_before_gc()) &#123;</span><br><span class="line">   <span class="keyword">return</span>; <span class="comment">// GC is disabled (e.g. JNI Get<span class="doctag"><span class="keyword">XXX</span></span>Critical operation)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行gc_prologue。</p>
<ol>
<li>处理TLAB，见 <a href="http://jangzq.info/2015/06/28/tlab/">HotSpot的TLAB实现解析</a>。</li>
<li>调用各个Generation的gc_prologue。</li>
</ol>
</li>
<li><p>如果是full gc，则需要找到开始回收的，最老的generation，这通过调用Generation的full_collects_younger_generations方法得到，当对此generation进行回收时，同时会回收更新的generation时，返回true。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (full) &#123;</span><br><span class="line">   <span class="comment">// Search for the oldest generation which will collect all younger</span></span><br><span class="line">   <span class="comment">// generations, and start collection loop there.</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = max_level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">     <span class="keyword">if</span> (_gens[i]-&gt;full_collects_younger_generations()) &#123;</span><br><span class="line">       starting_level = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从上一步得到的starting_level到最老的generation,依照从young到old的次序进行垃圾回收。<br> 对于每一个generation。</p>
<ol>
<li>首先，使用<code>_gens[i]-&gt;should_collect(full, size, is_tlab)</code>方法判断是否需要在此generation上进行collect。<br> 见附录。</li>
<li>调用generation的collect方法，进行回收，见后续文章。</li>
<li>检查是否满足分配。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">is_t</span>lab || _gens[i]-&gt;<span class="keyword">supports_t</span>lab_allocation()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size*HeapWordSize &lt;= _gens[i]-&gt;unsafe_max_alloc_nogc()) &#123;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>重新计算每个generation的大小,如果是full gc，则重新计算Perm的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = max_level_collected; j &gt;= <span class="number">0</span>; j -= <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// Adjust generation sizes.</span></span><br><span class="line">  _gens[j]-&gt;compute_new_size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (complete) &#123;</span><br><span class="line">  <span class="comment">// Ask the permanent generation to adjust size for full collections</span></span><br><span class="line">  perm()-&gt;compute_new_size();</span><br><span class="line">  update_full_collections_completed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 gc_epilogue</p>
<ol>
<li>重新调整TLAB大小，见<a href="http://jangzq.info/2015/06/28/tlab/">HotSpot的TLAB实现解析</a>。</li>
<li>调用每个generation上的 gc_epilogue。<br>见后续文章。</li>
</ol>
</li>
</ol>
<h2 id="附录">附录</h2><h3 id="should_collect">should_collect</h3><p>介绍每个generation的should_collect的实现方式。</p>
<h4 id="DefNewGeneration及其子类">DefNewGeneration及其子类</h4><p>如果是full，则返回true，否则判断需要分配的内存是否可以在此generation分配，如果不可以，就不需要回收此generation。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (full || should_allocate(word_size, <span class="keyword">is_t</span>lab));</span><br></pre></td></tr></table></figure></p>
<h4 id="TenuredGeneration">TenuredGeneration</h4><p>full gc， 或者需要分配的内存是否可以在此generation分配， 或者剩余空间少于10k，或者gc开始时的capacity，小于目前的capacity，即说明为了容纳young generation上移的内存，造成了本generationde 扩展。</p>
<h4 id="ConcurrentMarkSweepGeneration">ConcurrentMarkSweepGeneration</h4><p>如果是full，则返回true，否则判断需要分配的内存是否可以在此generation分配，如果不可以，就不需要回收此generation。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<h2 id="VM_GenCollectForAllocation">VM_GenCollectForAllocation</h2><p>在<a href="http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/">分代内存管理之慢速路径内存分配</a>中提到，当分配内存不成功时，使用VM_GenCollectForAllocation来进行GC并且分配，下面详细描述。<br>在<code>VM_GenCollectForAllocation::doit()</code> 方法中，调用了<code>GenCollectedHeap</code>的<code>satisfy_failed_allocation</code>方法，此方法又委托给了<code>GenCollectorPolicy::satisfy_failed_allocation</code>方法，下面即这个方法的实现方式。</p>
<ol>
<li><p>如果当前有jni方法在critical区域，并且有线程要求gc，则不能再请求GC，否则白白阻塞，所以heap如果还有扩展的空间，则扩展，并且分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GC_locker::is_active_and_needs_gc()) &#123;</span><br><span class="line"> <span class="comment">// GC locker is active; instead of a collection we will attempt</span></span><br><span class="line"> <span class="comment">// to expand the heap, if there's room for expansion.</span></span><br><span class="line">   <span class="keyword">if</span> (!gch-&gt;is_maximal_no_gc()) &#123;</span><br><span class="line">      result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;   <span class="comment">// could be null if we are out of space</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果GC没有被阻塞，则根据GenCollectedHeap的incremental_collection_will_fail决定进行full gc还是incremental gc. 如果incremental_collection_will_fail返回true，说明incremental gc将要失败，所以需要进行full gc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gch-&gt;incremental_collection_will_fail(<span class="keyword">false</span> <span class="comment">/* don't consult_young */</span>)) &#123;</span><br><span class="line">  <span class="comment">// Do an incremental collection.</span></span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">false</span>            <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">    <span class="keyword">gclog_or_t</span>ty-&gt;print(<span class="string">" :: Trying full because partial may fail :: "</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">false</span>            <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垃圾收集完成后，继续尝试分配内存，如果不成功，则尝试扩展堆大小，然后再次分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/*first_only*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, collection failed, try expansion.</span></span><br><span class="line">result = expand_heap_and_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果还是不能成功分配，则进行一次full gc，并且清除所有soft reference。然后再次分配，如果成功，返回地址，否则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  gch-&gt;do_collection(<span class="keyword">true</span>             <span class="comment">/* full */</span>,</span><br><span class="line">                     <span class="keyword">true</span>             <span class="comment">/* clear_all_soft_refs */</span>,</span><br><span class="line">                     size             <span class="comment">/* size */</span>,</span><br><span class="line">                     <span class="keyword">is_t</span>lab          <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                     number_of_generations() - <span class="number">1</span> <span class="comment">/* max_level */</span>);</span><br><span class="line"> result = gch-&gt;attempt_allocation(size, <span class="keyword">is_t</span>lab, <span class="keyword">false</span> <span class="comment">/* first_only */</span>);</span><br><span class="line"><span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">  assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(!should_clear_all_soft_refs(),</span><br><span class="line">  <span class="string">"Flag should have been handled and cleared prior to this point"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// What else?  We might try synchronous finalization later.  If the total</span></span><br><span class="line"><span class="comment">// space available is large enough for the allocation, then a more</span></span><br><span class="line"><span class="comment">// complete compaction phase than we've tried so far might be</span></span><br><span class="line"><span class="comment">// appropriate.</span></span><br><span class="line"><span class="keyword">return</span> NULL;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="GenCollectedHeap::do_collection">GenCollectedHeap::do_collection</h2>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之内存初始化]]></title>
    <link href="http://jangzq.info/2015/07/28/GenCollectedHeap_meminit/"/>
    <id>http://jangzq.info/2015/07/28/GenCollectedHeap_meminit/</id>
    <published>2015-07-28T13:30:58.000Z</published>
    <updated>2015-07-28T13:41:36.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理的内存初始化入口在：GenCollectedHeap::initialize。</p>
<h2 id="整体分配内存">整体分配内存</h2><p>在GenCollectedHeap::allocate方法中。在此之前，初始化CollectorPolicy时，已经计算了各个Generation的最大、最小、初始值，并且初始化了GenerationSpec数组。计算大小的过程见：<a href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/">分代内存管理之Generation Size</a><br><strong>注:</strong> 由于UseSharedSpaces只适用于Client mode，所以在此不分析相关代码。<br><strong>注：</strong> 这部分所说的分配内存，并不是真正的分配物理内存，而是在地址空间分配一段内存地址空间，在linux下使用mmap的匿名映射实现，当访问其中的某一地址时，产生缺页中断，由操作系统分配真实物理内存。</p>
<ul>
<li><p>计算需要的内存大小。</p>
<ol>
<li><p>遍历各个Generation Spec，将其最大内存相加。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  total_reserved = add_and_check_overflow(total_reserved, _gen_specs[i]-&gt;max_size());</span><br><span class="line">  n_covered_regions += _gen_specs[i]-&gt;n_covered_regions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再加上Perm区域的最大内存，及misc_data_size()、misc_code_size()<br>misc_data_size()、misc_code_size()并包含在heap内，只是在这里一起分配。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total_reserved = add_and_check_overflow(total_reserved, perm_gen_spec-&gt;max_size());</span><br><span class="line"><span class="keyword">size_t</span> misc = perm_gen_spec-&gt;misc_data_size() + perm_gen_spec-&gt;misc_code_size();</span><br><span class="line">total_reserved = add_and_check_overflow(total_reserved, misc);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>在使用压缩指针的情况下，需要确定heap的base address，和指针的encoding mode，然后在base address上分配，如果分配不成功，则整个虚拟机初始化失败。<br>hotspot中存在三种encoding mode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> NARROW_OOP_MODE &#123;</span><br><span class="line">  UnscaledNarrowOop  = <span class="number">0</span>,</span><br><span class="line">  ZeroBasedNarrowOop = <span class="number">1</span>,</span><br><span class="line">  HeapBasedNarrowOop = <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当heap内存小于4G的情况下，如果把heap分配到4G以下，则原64位指针，narrow为32位，即可作为narrow指针，这种情况即UnscaledNarrowOop。当内存大于4G，小于32G时，如果可以分配在32G以下的部分，则可以base为0,而shift为    LogMinObjAlignmentInBytes (默认为3)，这种对应的情况为ZeroBasedNarrowOop。如果不能分配在32G以下，则原64位指针需要减去一个base，再使用shift，转换为narrow的指针，这种情况即HeapBasedNarrowOop。<br> 如下面程序， 依次尝试 UnscaledNarrowOop、ZeroBasedNarrowOop、HeapBasedNarrowOop三种分配方式，分配成功即返回</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::UnscaledNarrowOop);</span><br><span class="line">*<span class="keyword">_t</span>otal_reserved = total_reserved;</span><br><span class="line">*_n_covered_regions = n_covered_regions;</span><br><span class="line">*heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                             UseLargePages, heap_address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (heap_address != NULL &amp;&amp; !heap_rs-&gt;is_reserved()) &#123;</span><br><span class="line">  <span class="comment">// Failed to reserve at specified address - the requested memory</span></span><br><span class="line">  <span class="comment">// region is taken already, for example, by 'java' launcher.</span></span><br><span class="line">  <span class="comment">// Try again to reserver heap higher.</span></span><br><span class="line">  heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::ZeroBasedNarrowOop);</span><br><span class="line">  *heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                               UseLargePages, heap_address);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (heap_address != NULL &amp;&amp; !heap_rs-&gt;is_reserved()) &#123;</span><br><span class="line">    <span class="comment">// Failed to reserve at specified address again - give up.</span></span><br><span class="line">    heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::HeapBasedNarrowOop);</span><br><span class="line">    assert(heap_address == NULL, <span class="string">""</span>);</span><br><span class="line">    *heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                                 UseLargePages, heap_address);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> heap_address;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有使用压缩指针，则直接分配内存。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">_t</span>otal_reserved = total_reserved;</span><br><span class="line">*_n_covered_regions = n_covered_regions;</span><br><span class="line">*heap_rs = ReservedHeapSpace(total_reserved, alignment,</span><br><span class="line">                          UseLargePages, heap_address);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="初始化CollectedHeap::_reserved">初始化CollectedHeap::_reserved</h2><p>定义：<code>MemRegion _reserved</code></p>
<ul>
<li>HeapWord* _start 设置为分配的地址。</li>
<li>size_t    _word_size 设置为实际的大小，即排除了misc_data_size()、misc_code_size()的大小。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> actual_heap_size = heap_rs.size() - perm_gen_spec-&gt;misc_data_size()</span><br><span class="line">                                          - perm_gen_spec-&gt;misc_code_size();</span><br><span class="line">       _reserved.set_end((HeapWord*)(heap_rs.base() + actual_heap_size));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="初始化Generation">初始化Generation</h2><p>对于所有的Generation，循环初始化。</p>
<ol>
<li>使用上文分配的地址范围，依次构造ReservedSpace对象（使用每一Generation的内存最大值），来描述每一个Generation的内存范围。</li>
<li>调用Generation Spec的init方法初始化。</li>
<li>初始化Perm Generation。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">    ReservedSpace this_rs = heap_rs.first_part(_gen_specs[i]-&gt;max_size(),</span><br><span class="line">                                              UseSharedSpaces, UseSharedSpaces);</span><br><span class="line">    _gens[i] = _gen_specs[i]-&gt;init(this_rs, i, rem_set());</span><br><span class="line">    <span class="comment">// tag generations in JavaHeap</span></span><br><span class="line">    MemTracker::<span class="keyword">record_virtual_memory_t</span>ype((address)this_rs.base(), mtJavaHeap);</span><br><span class="line">    heap_rs = heap_rs.last_part(_gen_specs[i]-&gt;max_size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">_perm_gen = perm_gen_spec-&gt;init(heap_rs, PermSize, rem_set());</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理的内存初始化入口在：GenCollectedHeap::initialize。</p>
<h2 id="整体分配内存">整体分配内存</h2><p>在GenCollectedHeap::allocate方法中。在此之前，初始化CollectorPolicy时，已经计算了各个Generation的最大、最小、初始值，并且初始化了GenerationSpec数组。计算大小的过程见：<a href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/">分代内存管理之Generation Size</a><br><strong>注:</strong> 由于UseSharedSpaces只适用于Client mode，所以在此不分析相关代码。<br><strong>注：</strong> 这部分所说的分配内存，并不是真正的分配物理内存，而是在地址空间分配一段内存地址空间，在linux下使用mmap的匿名映射实现，当访问其中的某一地址时，产生缺页中断，由操作系统分配真实物理内存。</p>
<ul>
<li><p>计算需要的内存大小。</p>
<ol>
<li><p>遍历各个Generation Spec，将其最大内存相加。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  total_reserved = add_and_check_overflow(total_reserved, _gen_specs[i]-&gt;max_size());</span><br><span class="line">  n_covered_regions += _gen_specs[i]-&gt;n_covered_regions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再加上Perm区域的最大内存，及misc_data_size()、misc_code_size()<br>misc_data_size()、misc_code_size()并包含在heap内，只是在这里一起分配。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total_reserved = add_and_check_overflow(total_reserved, perm_gen_spec-&gt;max_size());</span><br><span class="line"><span class="keyword">size_t</span> misc = perm_gen_spec-&gt;misc_data_size() + perm_gen_spec-&gt;misc_code_size();</span><br><span class="line">total_reserved = add_and_check_overflow(total_reserved, misc);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之Generation Size]]></title>
    <link href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/"/>
    <id>http://jangzq.info/2015/07/27/GenCollectedHeap_size/</id>
    <published>2015-07-27T14:04:41.000Z</published>
    <updated>2015-07-27T14:17:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理中各个generation的内存大小设置，保存在CollectorPolicy及其子类里，如下图所示。<br><img src="/images/gen_size.png" alt="CollectorPolicy"><br>从图中可以看出，CollectorPolicy类管理heap的大小，GenCollectorPolicy类管理着Generation 0的大小，而TwoGenerationCollectorPolicy管理着Generation 1的大小。</p>
<h2 id="Heap大小">Heap大小</h2><p>见：<a href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/">垃圾收集框架：CollectedHeap和CollectorPolicy</a></p>
<h2 id="Generation">Generation</h2><p><strong>Generation大小必须以<code>min_alignment()</code>对齐，一般为64k，并且最小不能小于<code>min_alignment()</code>。为了描述方便，下文有的地方省略对齐及最小值调整部分，请知晓</strong></p>
<h3 id="Generation_0">Generation 0</h3><a id="more"></a>
<h4 id="_max_gen0_size">_max_gen0_size</h4><p>首先，计算中间值max_new_size。</p>
<ul>
<li>当设置了MaxNewSize参数，_max_gen0_size由此参数决定。<ol>
<li>如果MaxNewSize小于最小对齐粒度<code>min_alignment()</code>（一般为64k），则max_new_size设为<code>min_alignment()</code>。</li>
<li>如果大于设置的“堆的最大值”<code>max_heap_byte_size()</code>，则设为<code>align_size_down(max_heap_byte_size() - min_alignment(), min_alignment())</code></li>
<li>否则，设为MaxNewSize，按最小对齐粒度对齐, <code>align_size_down(MaxNewSize, min_alignment())</code>。</li>
</ol>
</li>
<li>当没有设置MaxNewSize参数时，设为“堆的最大值”/(NewRatio+1)，NewRatio缺省为2, 当这个值小于最小对齐粒度<code>min_alignment()</code>（一般为64k），则max_new_size设为<code>min_alignment()</code>。<br>上述结果再根据设置的“堆的最大值”和“堆的最小值”进行调整。</li>
<li>如果“堆的最大值”等于“堆的最小值”，max_new_size不变。</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize，则max_new_size取（max_new_size， NewSize)两者最大的。<br>最后，设置_max_gen0_size为max_new_size，如果超过了“堆的最大值”，设为<code>align_size_down(max_heap_byte_size() - min_alignment(), min_alignment())</code>。</li>
</ul>
<h4 id="_initial_gen0_size">_initial_gen0_size</h4><ul>
<li>如果“堆的最大值”和“堆的最小值”相等， _initial_gen0_size设为max_new_size，</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize参数，则设为NewSize。如果没有设置NewSize，设为“堆的初始值”/(NewRatio+1)，和NewSize缺省值之间最大的。</li>
</ul>
<p>最后，根据“heap的初始值”进行调整，如果超过了“Heap的初始值” (<code>_initial_heap_byte_size</code>)，设为<code>align_size_down(initial_heap_byte_size() - min_alignment(), min_alignment())</code>。</p>
<p><strong>注:</strong> <em>在设置OLD Generation大小时，如果设置了OldSize，并且OldSize+_initial_gen0_size大于“堆的初始值”时，会调整此值。</em></p>
<h4 id="_min_gen0_size">_min_gen0_size</h4><ul>
<li>如果“堆的最大值”和“堆的最小值”相等， _min_gen0_size设为max_new_size，</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize参数，则设为NewSize。如果没有设置NewSize，设为“堆的最小值”/(NewRatio+1)，和NewSize缺省值之间最大的。</li>
</ul>
<p>最后，根据“heap的初始值”进行调整，如果超过了“Heap的最小值” (<code>_min_heap_byte_size</code>)，设为<code>align_size_down(min_heap_byte_size() - min_alignment(), min_alignment())</code>。</p>
<p><strong>注:</strong> <em>在设置OLD Generation大小时，如果设置了OldSize，并且OldSize+_min_gen0_size大于“堆的最小值”时，会调整此值。</em></p>
<h3 id="Generation_1">Generation 1</h3><h4 id="_max_gen1_size">_max_gen1_size</h4><p>设为“堆最大值”-_max_gen0_size，和min_alignment()的最大值。</p>
<h4 id="_initial_gen1_size">_initial_gen1_size</h4><ul>
<li>如果没有设置OldSize，设置为initial_heap_byte_size() - initial_gen0_size()。</li>
<li>如果设置了OldSize，此值设置为OldSize，如果_initial_gen0_size+OldSize 大于“堆的初始值”，则需要调整_initial_gen0_size。</li>
</ul>
<h4 id="_min_gen1_size">_min_gen1_size</h4><ul>
<li>如果没有设置OldSize，设置为initial_heap_byte_size() - _min_gen0_size。</li>
<li>如果设置了OldSize，此值设置为OldSize，如果_min_gen0_size+OldSize 大于“堆的最小值”，则需要调整_min_gen0_size。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理中各个generation的内存大小设置，保存在CollectorPolicy及其子类里，如下图所示。<br><img src="/images/gen_size.png" alt="CollectorPolicy"><br>从图中可以看出，CollectorPolicy类管理heap的大小，GenCollectorPolicy类管理着Generation 0的大小，而TwoGenerationCollectorPolicy管理着Generation 1的大小。</p>
<h2 id="Heap大小">Heap大小</h2><p>见：<a href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/">垃圾收集框架：CollectedHeap和CollectorPolicy</a></p>
<h2 id="Generation">Generation</h2><p><strong>Generation大小必须以<code>min_alignment()</code>对齐，一般为64k，并且最小不能小于<code>min_alignment()</code>。为了描述方便，下文有的地方省略对齐及最小值调整部分，请知晓</strong></p>
<h3 id="Generation_0">Generation 0</h3>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
</feed>