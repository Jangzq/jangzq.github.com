<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Jangzq技术研究]]></title>
  <subtitle><![CDATA[关注代码的秘密， 记录探索点滴， 分享技术收获]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jangzq.info//"/>
  <updated>2015-07-27T14:17:51.000Z</updated>
  <id>http://jangzq.info//</id>
  
  <author>
    <name><![CDATA[Zhang Zq]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[分代内存管理之Generation Size]]></title>
    <link href="http://jangzq.info/2015/07/27/GenCollectedHeap_size/"/>
    <id>http://jangzq.info/2015/07/27/GenCollectedHeap_size/</id>
    <published>2015-07-27T14:04:41.000Z</published>
    <updated>2015-07-27T14:17:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理中各个generation的内存大小设置，保存在CollectorPolicy及其子类里，如下图所示。<br><img src="/images/gen_size.png" alt="CollectorPolicy"><br>从图中可以看出，CollectorPolicy类管理heap的大小，GenCollectorPolicy类管理着Generation 0的大小，而TwoGenerationCollectorPolicy管理着Generation 1的大小。</p>
<h2 id="Heap大小">Heap大小</h2><p>见：<a href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/">垃圾收集框架：CollectedHeap和CollectorPolicy</a></p>
<h2 id="Generation">Generation</h2><p><strong>Generation大小必须以<code>min_alignment()</code>对齐，一般为64k，并且最小不能小于<code>min_alignment()</code>。为了描述方便，下文有的地方省略对齐及最小值调整部分，请知晓</strong></p>
<h3 id="Generation_0">Generation 0</h3><a id="more"></a>
<h4 id="_max_gen0_size">_max_gen0_size</h4><p>首先，计算中间值max_new_size。</p>
<ul>
<li>当设置了MaxNewSize参数，_max_gen0_size由此参数决定。<ol>
<li>如果MaxNewSize小于最小对齐粒度<code>min_alignment()</code>（一般为64k），则max_new_size设为<code>min_alignment()</code>。</li>
<li>如果大于设置的“堆的最大值”<code>max_heap_byte_size()</code>，则设为<code>align_size_down(max_heap_byte_size() - min_alignment(), min_alignment())</code></li>
<li>否则，设为MaxNewSize，按最小对齐粒度对齐, <code>align_size_down(MaxNewSize, min_alignment())</code>。</li>
</ol>
</li>
<li>当没有设置MaxNewSize参数时，设为“堆的最大值”/(NewRatio+1)，NewRatio缺省为2, 当这个值小于最小对齐粒度<code>min_alignment()</code>（一般为64k），则max_new_size设为<code>min_alignment()</code>。<br>上述结果再根据设置的“堆的最大值”和“堆的最小值”进行调整。</li>
<li>如果“堆的最大值”等于“堆的最小值”，max_new_size不变。</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize，则max_new_size取（max_new_size， NewSize)两者最大的。<br>最后，设置_max_gen0_size为max_new_size，如果超过了“堆的最大值”，设为<code>align_size_down(max_heap_byte_size() - min_alignment(), min_alignment())</code>。</li>
</ul>
<h4 id="_initial_gen0_size">_initial_gen0_size</h4><ul>
<li>如果“堆的最大值”和“堆的最小值”相等， _initial_gen0_size设为max_new_size，</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize参数，则设为NewSize。如果没有设置NewSize，设为“堆的初始值”/(NewRatio+1)，和NewSize缺省值之间最大的。</li>
</ul>
<p>最后，根据“heap的初始值”进行调整，如果超过了“Heap的初始值” (<code>_initial_heap_byte_size</code>)，设为<code>align_size_down(initial_heap_byte_size() - min_alignment(), min_alignment())</code>。</p>
<p><strong>注:</strong> <em>在设置OLD Generation大小时，如果设置了OldSize，并且OldSize+_initial_gen0_size大于“堆的初始值”时，会调整此值。</em></p>
<h4 id="_min_gen0_size">_min_gen0_size</h4><ul>
<li>如果“堆的最大值”和“堆的最小值”相等， _min_gen0_size设为max_new_size，</li>
<li>如果“堆的最大值”不等于“堆的最小值”，如果设置了NewSize参数，则设为NewSize。如果没有设置NewSize，设为“堆的最小值”/(NewRatio+1)，和NewSize缺省值之间最大的。</li>
</ul>
<p>最后，根据“heap的初始值”进行调整，如果超过了“Heap的最小值” (<code>_min_heap_byte_size</code>)，设为<code>align_size_down(min_heap_byte_size() - min_alignment(), min_alignment())</code>。</p>
<p><strong>注:</strong> <em>在设置OLD Generation大小时，如果设置了OldSize，并且OldSize+_min_gen0_size大于“堆的最小值”时，会调整此值。</em></p>
<h3 id="Generation_1">Generation 1</h3><h4 id="_max_gen1_size">_max_gen1_size</h4><p>设为“堆最大值”-_max_gen0_size，和min_alignment()的最大值。</p>
<h4 id="_initial_gen1_size">_initial_gen1_size</h4><ul>
<li>如果没有设置OldSize，设置为initial_heap_byte_size() - initial_gen0_size()。</li>
<li>如果设置了OldSize，此值设置为OldSize，如果_initial_gen0_size+OldSize 大于“堆的初始值”，则需要调整_initial_gen0_size。</li>
</ul>
<h4 id="_min_gen1_size">_min_gen1_size</h4><ul>
<li>如果没有设置OldSize，设置为initial_heap_byte_size() - _min_gen0_size。</li>
<li>如果设置了OldSize，此值设置为OldSize，如果_min_gen0_size+OldSize 大于“堆的最小值”，则需要调整_min_gen0_size。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代内存管理中各个generation的内存大小设置，保存在CollectorPolicy及其子类里，如下图所示。<br><img src="/images/gen_size.png" alt="CollectorPolicy"><br>从图中可以看出，CollectorPolicy类管理heap的大小，GenCollectorPolicy类管理着Generation 0的大小，而TwoGenerationCollectorPolicy管理着Generation 1的大小。</p>
<h2 id="Heap大小">Heap大小</h2><p>见：<a href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/">垃圾收集框架：CollectedHeap和CollectorPolicy</a></p>
<h2 id="Generation">Generation</h2><p><strong>Generation大小必须以<code>min_alignment()</code>对齐，一般为64k，并且最小不能小于<code>min_alignment()</code>。为了描述方便，下文有的地方省略对齐及最小值调整部分，请知晓</strong></p>
<h3 id="Generation_0">Generation 0</h3>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分代内存管理之慢速路径内存分配]]></title>
    <link href="http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/"/>
    <id>http://jangzq.info/2015/07/26/GenCollectedHeap_allocate/</id>
    <published>2015-07-26T03:45:47.000Z</published>
    <updated>2015-07-26T12:39:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代的内存管理使用GenCollectedHeap。generation的类如下：</p>
<p><img src="/images/generation.png" alt="Generation"></p>
<p>在这里我们主要剖析慢速路径使用的GenCollectedHeap::mem_allocate方法。其内存分配委托给了相应的CollectorPolicy实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> collector_policy()-&gt;mem_allocate_work(size,</span><br><span class="line">                                             <span class="keyword">false</span> <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                                             gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure>
<p>所以，下面剖析GenCollectorPolicy::mem_allocate_work的实现。</p>
<ul>
<li><p>内存分配的逻辑在下列循环中，说明此方法只有两个出口，或者分配成功，或者抛出异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> try_count = <span class="number">1</span>; <span class="comment">/* return or throw */</span>; try_count += <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分代的内存管理，在Young generation里实现无锁的分配方式，从assert中可以看出，Young generation必须满足<code>supports_inline_contig_alloc</code>，即必须满足，在堆中必须有一块儿连续的空间，可用范围由top_addr()，end_addr()决定的，并且可以靠移动top_addr来分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(gen0-&gt;supports_inline_contig_alloc(),</span><br><span class="line">      <span class="string">"Otherwise, must do alloc within heap lock"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，在Young generation进行无锁分配。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gen0-&gt;should_allocate(size, <span class="keyword">is_t</span>lab)) &#123;</span><br><span class="line">  result = gen0-&gt;par_allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    assert(gch-&gt;is_in_reserved(result), <span class="string">"result not in heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bool should_allocate(size_t word_size, bool is_tlab)</strong>：在这个generation中是否可以分配<code>word_size</code>大小的内存。<br><em>defNewGeneration及其子类</em><br>1、没有overflows，即没有超过size_t表示的范围。<br>2、如果设置了PretenureSizeThreshold，小于此值。</p>
<p><em>其它</em><br>只判断是否overflows。</p>
<p><strong>HeapWord* par_allocate(size_t word_size, bool is_tlab)</strong>: 在慢速路径分配时，提供不加锁分配内存的方式。<br><em>defNewGeneration</em>:<br>调用Eden区的par_allocate方法，使用cmpxchg方式修改top指针，分配内存。</p>
</li>
<li><p>如果上面没有分配成功，将使用有锁的慢速分配，这部分使用的是GenCollectedHeap::attempt_allocation方法。首先需要确认是否只在Young generation进行分配，如果只需在Young generation进行分配，那么当不能成功分配的时候，就进行GC，否则尝试在更老的Generation上分配，所以这个判断是很重要的。<br><strong>bool GenCollectorPolicy::should_try_older_generation_allocation(size_t word_size) const</strong>: 判断是否只在Young generation上进行分配。<br>满足下列三个条件之一，就需要在更老的Generation尝试。</p>
<ol>
<li>调用<code>gch-&gt;get_gen(0)-&gt;capacity_before_gc()</code>得到Young generation不用GC，最多能分配的内存大小，defNewGeneration及其子类，直接返回Eden的容量。即如果要分配的内存大于Eden的容量，则需要尝试next generation.</li>
<li><code>GC_locker::is_active_and_needs_gc()</code>，即当前有jni方法在critical区域，并且有线程要求gc，这时如果只在Young generation分配，则势必需要GC，造成阻塞，所以需要尝试next generation.</li>
<li><code>gch-&gt;incremental_collection_failed()</code>，即最近一次的incremental收集错误，也就是在Young generation层GC应该没有效果，所以需要尝试next generation.</li>
</ol>
<p>在GenCollectedHeap::attempt_allocation中，以此调用各个Generation的allocate方法进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_gens[i]-&gt;should_allocate(size, <span class="keyword">is_t</span>lab)) &#123;</span><br><span class="line">    res = _gens[i]-&gt;allocate(size, <span class="keyword">is_t</span>lab);</span><br><span class="line">    <span class="keyword">if</span> (res != NULL) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first_only) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果到此还没有分配成功，首先不要急于GC，如果<code>GC_locker::is_active_and_needs_gc()</code>，即当前有jni方法在critical区域，并且有线程要求gc，则进行如下处理。</p>
<ol>
<li>如果是要求在TLAB上分配，则直接返回NULL，调用者会尝试接下来的分配方式。</li>
<li>使用<code>GenCollectedHeap::is_maximal_no_gc</code>得到各个generation是否没有达到最大设置，如果存在这样的generation，调用<code>GenCollectorPolicy::expand_heap_and_allocate</code>扩展并且分配。</li>
<li>如果上一步没有分配成功，则等待处于critical的jni线程退出后，再次从头执行分配流程。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!jthr-&gt;in_critical()) &#123;</span><br><span class="line">        <span class="function">MutexUnlocker <span class="title">mul</span><span class="params">(Heap_lock)</span></span>;</span><br><span class="line">        <span class="comment">// Wait for JNI critical section to be exited</span></span><br><span class="line">        GC_locker::stall_until_clear();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>进行GC，并且同时分配。</p>
<ol>
<li><p>提交GC. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VM_GenCollectForAllocation <span class="title">op</span><span class="params">(size,</span><br><span class="line">                            is_tlab,</span><br><span class="line">                            gc_count_before)</span></span>;</span><br><span class="line">VMThread::execute(&amp;op);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果别的线程已经请求GC了，则从头执行分配流程重试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op.prologue_succeeded()) &#123;</span><br><span class="line">  result = op.result();</span><br><span class="line">  <span class="keyword">if</span> (op.gc_locked()) &#123;</span><br><span class="line">     assert(result == NULL, <span class="string">"must be NULL if gc_locked() is true"</span>);</span><br><span class="line">     <span class="keyword">continue</span>;  <span class="comment">// retry and/or stall as necessary</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果执行完gc，但是花费了很多时间，才回收下很少内存，返回NULL，并且给<code>gc_overhead_limit_was_exceeded</code>赋值。</p>
</li>
<li>gc并分配成功，返回结果。</li>
</ol>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>分代的内存管理使用GenCollectedHeap。generation的类如下：</p>
<p><img src="/images/generation.png" alt="Generation"></p>
<p>在这里我们主要剖析慢速路径使用的GenCollectedHeap::mem_allocate方法。其内存分配委托给了相应的CollectorPolicy实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> collector_policy()-&gt;mem_allocate_work(size,</span><br><span class="line">                                             <span class="keyword">false</span> <span class="comment">/* is_tlab */</span>,</span><br><span class="line">                                             gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure>
<p>所以，下面剖析GenCollectorPolicy::mem_allocate_work的实现。</p>
<ul>
<li><p>内存分配的逻辑在下列循环中，说明此方法只有两个出口，或者分配成功，或者抛出异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> try_count = <span class="number">1</span>; <span class="comment">/* return or throw */</span>; try_count += <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分代的内存管理，在Young generation里实现无锁的分配方式，从assert中可以看出，Young generation必须满足<code>supports_inline_contig_alloc</code>，即必须满足，在堆中必须有一块儿连续的空间，可用范围由top_addr()，end_addr()决定的，并且可以靠移动top_addr来分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(gen0-&gt;supports_inline_contig_alloc(),</span><br><span class="line">      <span class="string">"Otherwise, must do alloc within heap lock"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，在Young generation进行无锁分配。</p>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过解释器的new操作看内存分配]]></title>
    <link href="http://jangzq.info/2015/07/05/new/"/>
    <id>http://jangzq.info/2015/07/05/new/</id>
    <published>2015-07-04T16:13:29.000Z</published>
    <updated>2015-07-04T16:30:24.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>了解hotspot的内存分配流程，TemplateTable::_new方法是个比较好的入口，这个方法生成了供以后解释执行时使用的汇编代码。从这个方法入手，可以了解hotspot创建对象所需要的操作，对我们开发应用程序时，进行内存管理设计有很大的帮助。</p>
<h2 id="概述">概述</h2><p>新建一个对象，有三种方式。</p>
<ol>
<li><p>在TLAB中分配<br>如果<code>UseTLAB</code>为真（缺省是true），就先进行TLAB分配，本部分的内容在<a href="http://jangzq.info/2015/06/28/tlab/">《HotSpot的TLAB实现解析》</a>一文里也进行了简单的说明，本文后面详细说明。</p>
</li>
<li><p>在shared eden中快速分配。<br>TLAB是eden中的每个线程自己使用的部分，shared eden就是共享的部分。当在TLAB中分配失败后，也就是TLAB中的内存大小不够时，就有可能在shared eden中分配。之所以是有可能，是需要满足以下的条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> allow_shared_alloc =</span><br><span class="line">   Universe::heap()-&gt;supports_inline_contig_alloc() &amp;&amp; !CMSIncrementalMode</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>supports_inline_contig_alloc</code>与具体的<code>CollectedHeap</code>有关，也就是必须满足，在堆中必须有一块儿连续的空间，可用范围由<code>top_addr()</code>，<code>end_addr()</code>决定的，并且可以靠移动<code>top_addr</code>来分配内存。<br><code>CMSIncrementalMode</code>是增量CMS模式，当设置了增量CMS模式时，不允许在share eden中快速分配。</p>
<ol>
<li>慢速路径<br>调用<code>InterpreterRuntime::_new</code>进行分配。当类没有解析或者初始化时，还有上面的两种分配方式都不成功的时候，进入慢速模式。</li>
</ol>
<h2 id="源码解析">源码解析</h2><a id="more"></a>
<h3 id="得到类的大小">得到类的大小</h3><p>要分配内存，首先要知道大小，所以通过下面的操作得到类的大小。<br>首先判断这个类的符号连接在常量池里是否已经解析，没有解析的话，就不能走快速路径了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ <span class="keyword">get_cpool_and_t</span>ags(rsi, rax); <span class="comment">//rsi指向了常量池地址，rax指向了常量池的tags。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tags_offset = typeArrayOopDesc::header_size(T_BYTE) * wordSize;</span><br><span class="line">__ cmpb(Address(rax, rdx, Address::times_1, tags_offset),</span><br><span class="line">        JVM_CONSTANT_Class);</span><br><span class="line">__ jcc(Assembler::notEqual, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>得到instanceKlass，并且判断是否初始化，如果没有初始化，也不能走快速路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__ movptr(rsi, Address(rsi, rdx,</span><br><span class="line">          Address::times_8, <span class="keyword">sizeof</span>(constantPoolOopDesc)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure klass is initialized &amp; doesn't have finalizer</span></span><br><span class="line"><span class="comment">// make sure klass is fully initialized</span></span><br><span class="line">__ cmpb(Address(rsi,</span><br><span class="line">                instanceKlass::init_state_offset()),</span><br><span class="line">        instanceKlass::fully_initialized);</span><br><span class="line">__ jcc(Assembler::notEqual, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>注：解析和初始化的概念请参考《java虚拟机规范》。<br>当分配的是普通类对象（非数组）时， 如果klass::_layout_helper为正数，这个值就是对象的大小。如果最低位为1的话，则说明不能应用快速路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get instance_size in instanceKlass (scaled to a count of bytes)</span></span><br><span class="line"> __ movl(rdx,</span><br><span class="line">         Address(rsi,</span><br><span class="line">                 Klass::layout_helper_offset()));</span><br><span class="line"> <span class="comment">// test to see if it has a finalizer or is malformed in some way</span></span><br><span class="line"> __ testl(rdx, Klass::_lh_instance_slow_path_bit);</span><br><span class="line"> __ jcc(Assembler::notZero, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>经过以上步骤，对象的大小已经放在了rdx寄存器中，下面进行内存分配。</p>
<h3 id="TLAB分配">TLAB分配</h3><p>如果<code>UseTLAB</code>为真（缺省是true），就先进行TLAB分配。<br>首先，尝试直接修改TLAB的当前指针分配。当前线程的TLAB当前待分配指针存放在<code>JavaThread</code>的<code>tlab_top_offset</code>属性里，而r15指向了当前线程的<code>JavaThread</code>，所以首先将其存放到rax里，然后加上前面得到的对象大小，得到如果在TLAB里分配，指针的位置。然后比较这个位置和当前tlab的最大指针，如果超出了这个位置，说明tlab里的空间不足以分配这个对象，否则移动tlab的当前指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ movptr(rax, Address(<span class="keyword">r15_t</span>hread, in_bytes(JavaThread::<span class="keyword">tlab_t</span>op_offset())));</span><br><span class="line"> __ lea(rbx, Address(rax, rdx, Address::times_1));</span><br><span class="line"> __ cmpptr(rbx, Address(<span class="keyword">r15_t</span>hread, in_bytes(JavaThread::tlab_end_offset())));</span><br><span class="line"> __ jcc(Assembler::above, allow_shared_alloc ? allocate_shared : slow_case);</span><br><span class="line"> __ movptr(Address(<span class="keyword">r15_t</span>hread, in_bytes(JavaThread::<span class="keyword">tlab_t</span>op_offset())), rbx);</span><br></pre></td></tr></table></figure></p>
<p>从上面代码中可以看出，如果没空间，根据是否允许在share eden中快速分配，选择 allocate_shared，或者慢速路径。<br>如果设置了ZeroTLAB,则分配的内存已经全置为0了，就不需要初始化对象，只需要初始化header。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ZeroTLAB) &#123;</span><br><span class="line">      <span class="comment">// the fields have been already cleared</span></span><br><span class="line">      __ jmp(initialize_header);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// initialize both the header and fields</span></span><br><span class="line">      __ jmp(initialize_object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Shared_eden快速分配">Shared eden快速分配</h3><p>由于shared eden是共享的，所以不能直接移动指针分配，需要保护机制。在x86_64里，采用的是<code>cmpxchg</code>指令。<br>首先， 比较shared eden的当前指针+对象大小，是否超过了shared eden的范围，如果超过了，只好去慢速路径。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__ lea(rbx, Address(rax, rdx, Address::times_1));</span><br><span class="line"> __ cmpptr(rbx, Address(RendAddr, <span class="number">0</span>));</span><br><span class="line"> __ jcc(Assembler::above, slow_case);</span><br></pre></td></tr></table></figure></p>
<p>然后， 用cas修改当前指针的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    __ lock();</span><br><span class="line">&#125;</span><br><span class="line">__ cmpxchgptr(rbx, Address(RtopAddr, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// if someone beat us on the allocation, try again, otherwise continue</span></span><br><span class="line">__ jcc(Assembler::notEqual, retry);</span><br></pre></td></tr></table></figure></p>
<p><code>__ lock()</code>方法生成lock前缀， 然后使用<code>cmpxchg</code>，给当前top指针赋值。具体含义为：因为现在rax中存放的是根据当前的top地址计算的object的起始地址，rbx存放的是object的结束地址，当内存中的rtopaddr处的内容等于rax时，将rbx的内容存入内存的这个地方，否则的话，说明别的线程已经改了这个地址的内存，这时将内存此处的值放入rax，以上操作是原子的。当修改失败的时候，需要重试。</p>
<h3 id="初始化对象和头">初始化对象和头</h3><p>初始化对象，即将对象全部清0。<br>初始化头，即初始化对象前面的oopDesc。</p>
<h3 id="慢速分配">慢速分配</h3><p>入口为：<code>InterpreterRuntime::_new</code>。<br>首先，检查类是否已经解析和初始化，然后进入实质分配内存部分：<code>CollectedHeap::common_mem_allocate_noinit</code>。</p>
<h4 id="TLAB分配-1">TLAB分配</h4><p>首先在tlab中分配。这里面可以扩展新的TLAB空间，《HotSpot的TLAB实现解析》里描述的比较详细，请参考。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">  result = <span class="keyword">allocate_from_t</span>lab(klass, THREAD, size);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    assert(!HAS_PENDING_EXCEPTION,</span><br><span class="line">           <span class="string">"Unexpected exception, will result in uninitialized storage"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="CollectedHeap分配">CollectedHeap分配</h4><p>分配不成功，调用当前<code>CollectedHeap</code>的<code>mem_allocate</code>方法，这个是个虚函数，由具体的子类实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = Universe::heap()-&gt;mem_allocate(size,</span><br><span class="line">                                        &amp;gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure></p>
<p>详细描述在另外单独文章描述，请关注<a href="http://jangzq.info/">Jangzq技术研究</a>。</p>
<h4 id="内存溢出处理">内存溢出处理</h4><p>当还没有分配成功，这时就需要报告内存溢出。<br>详细描述在另外单独文章描述，请关注<a href="http://jangzq.info/">Jangzq技术研究</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>了解hotspot的内存分配流程，TemplateTable::_new方法是个比较好的入口，这个方法生成了供以后解释执行时使用的汇编代码。从这个方法入手，可以了解hotspot创建对象所需要的操作，对我们开发应用程序时，进行内存管理设计有很大的帮助。</p>
<h2 id="概述">概述</h2><p>新建一个对象，有三种方式。</p>
<ol>
<li><p>在TLAB中分配<br>如果<code>UseTLAB</code>为真（缺省是true），就先进行TLAB分配，本部分的内容在<a href="http://jangzq.info/2015/06/28/tlab/">《HotSpot的TLAB实现解析》</a>一文里也进行了简单的说明，本文后面详细说明。</p>
</li>
<li><p>在shared eden中快速分配。<br>TLAB是eden中的每个线程自己使用的部分，shared eden就是共享的部分。当在TLAB中分配失败后，也就是TLAB中的内存大小不够时，就有可能在shared eden中分配。之所以是有可能，是需要满足以下的条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> allow_shared_alloc =</span><br><span class="line">   Universe::heap()-&gt;supports_inline_contig_alloc() &amp;&amp; !CMSIncrementalMode</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>supports_inline_contig_alloc</code>与具体的<code>CollectedHeap</code>有关，也就是必须满足，在堆中必须有一块儿连续的空间，可用范围由<code>top_addr()</code>，<code>end_addr()</code>决定的，并且可以靠移动<code>top_addr</code>来分配内存。<br><code>CMSIncrementalMode</code>是增量CMS模式，当设置了增量CMS模式时，不允许在share eden中快速分配。</p>
<ol>
<li>慢速路径<br>调用<code>InterpreterRuntime::_new</code>进行分配。当类没有解析或者初始化时，还有上面的两种分配方式都不成功的时候，进入慢速模式。</li>
</ol>
<h2 id="源码解析">源码解析</h2>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[垃圾收集框架：CollectedHeap和CollectorPolicy]]></title>
    <link href="http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/"/>
    <id>http://jangzq.info/2015/07/03/CollectedHeapCollectorPolicy/</id>
    <published>2015-07-03T14:10:27.000Z</published>
    <updated>2015-07-05T11:38:10.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>hotspot的垃圾收集框架有两个主要的组成部分，其一是CollectedHeap、其一是CollectorPolicy。根据不同的启动参数，hotspot选择相应的Heap和Policy。<br>首先我们看一下类图，看一下有多少种CollectedHeap和CollectorPolicy。</p>
<p><img src="/images/heap_policy.png" alt="类图"></p>
<p>下面列出的是CollectorPolicy和CollectedHeap的关键属性和方法，我们以此来看一下Policy和Heap各自的特性。</p>
<h2 id="CollectedHeap">CollectedHeap</h2><p>CollectedHeap是java堆在hotspot中的体现，根据垃圾收集算法的不同，具有不同类型的子类，CollectedHeap的主要功能是分配内存，在这个父类里实现的主要是分配的流程，包括TLAB、其它分配等。但是不负责真正的内存分配，因为内存是由其子类管理，所以只定义这些分配的抽象方法。</p>
<p><strong>属性</strong><br><a id="more"></a></p>
<ul>
<li><p>MemRegion _reserved<br>描述地址空间中一块儿连续的区域，由子类负责初始化、使用。</p>
</li>
<li><p>uint _n_par_threads<br>并行线程数。</p>
</li>
<li><p>GCCause::Cause _gc_cause<br>GC原因</p>
</li>
<li><p>GCCause::Cause _gc_lastcause<br>最后一次的GC原因</p>
</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><p>virtual HeapWord* allocate_new_tlab(size_t size)<br>创建一个新的TLAB，在CollectedHeap中没有实现这个方法，由子类负责实现。</p>
</li>
<li><p>inline static HeapWord<em> allocate_from_tlab(KlassHandle klass, Thread</em> thread, size_t size);<br>从TLAB里分配内存，流程如下：<br>首先调用thread对象中的_tlab（类型为：ThreadLocalAllocBuffer）的allocate方法,在TLAB上分配内存，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = thread-&gt;tlab().allocate(size)</span><br></pre></td></tr></table></figure>
<p>  如果没有分配成功，调用<code>allocate_from_tlab_slow</code>分配。 </p>
</li>
<li><p>static HeapWord<em> allocate_from_tlab_slow(KlassHandle klass, Thread</em> thread, size_t size)<br>  首先判断本TLAB中剩余内存，是否大于可以浪费的内存limit，如果大于，则不能在TLAB中分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread-&gt;tlab().<span class="built_in">free</span>() &gt; thread-&gt;tlab().refill_waste_limit()) &#123;</span><br><span class="line">   thread-&gt;tlab().record_slow_allocation(size);</span><br><span class="line">   <span class="keyword">return</span> NULL;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>  否则，计算新的TLAB的大小，新分配一个TLAB，并且为了遍历对象，把原来分配TLAB没有使用的部分清0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="keyword">new_t</span>lab_size = thread-&gt;tlab().compute_size(size);</span><br><span class="line">thread-&gt;tlab().clear_before_allocation();</span><br></pre></td></tr></table></figure>
<p>  调用<code>allocate_new_tlab</code>分配了TLAB，如果设置了ZeroTLAB，还需要进行清0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = Universe::heap()-&gt;<span class="keyword">allocate_new_t</span>lab(<span class="keyword">new_t</span>lab_size);</span><br><span class="line"><span class="keyword">if</span> (obj == NULL) &#123;</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ZeroTLAB) &#123;</span><br><span class="line">  Copy::<span class="keyword">zero_t</span>o_words(obj, <span class="keyword">new_t</span>lab_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在新的tlab上分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;tlab().fill(obj, obj + size, <span class="keyword">new_t</span>lab_size);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static HeapWord* common_mem_allocate_noinit(KlassHandle klass, size_t size, TRAPS)<br>  分配对象内存。<br>  首先在tlab中分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">  result = <span class="keyword">allocate_from_t</span>lab(klass, THREAD, size);</span><br><span class="line">  <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">    assert(!HAS_PENDING_EXCEPTION,</span><br><span class="line">           <span class="string">"Unexpected exception, will result in uninitialized storage"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  分配不成功，调用当前CollectedHeap的mem_allocate方法，这个是个虚函数，由具体的子类实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = Universe::heap()-&gt;mem_allocate(size,</span><br><span class="line">                                        &amp;gc_overhead_limit_was_exceeded);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>inline static HeapWord* common_mem_allocate_init(KlassHandle klass, size_t size, TRAPS)<br>分配并初始化对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_noinit(klass, size, CHECK_NULL);</span><br><span class="line">init_obj(obj, size);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static HeapWord* common_permanent_mem_allocate_noinit(size_t size, TRAPS)<br>在Perm段分配内存。<br>调用虚函数<code>permanent_mem_allocate</code>进行分配，这个函数由子类实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* result = Universe::heap()-&gt;permanent_mem_allocate(size);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果失败，报告oom。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_java_out_of_memory(<span class="string">"PermGen space"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>inline static HeapWord* common_permanent_mem_allocate_init(size_t size, TRAPS)<br>在Perm段分配内存，并初始化。<br>调用common_permanent_mem_allocate_noinit，并初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_permanent_mem_allocate_noinit(size, CHECK_NULL);</span><br><span class="line">init_obj(obj, size);</span><br></pre></td></tr></table></figure>
</li>
<li><p>static oop Class_obj_allocate(KlassHandle klass, int size, KlassHandle real_klass, TRAPS)<br>  分配并且初始化class对象，即创建mirror class时使用。在jdk7里，class对象从PermGen移到了Heap里，可以通过-XX:+JavaObjectsInPerm，使其还在PermGen分配。</p>
<p>  首先在合适位置分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (JavaObjectsInPerm) &#123;</span><br><span class="line">  obj = common_permanent_mem_allocate_init(size, CHECK_NULL);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  assert(ScavengeRootsInCode &gt; <span class="number">0</span>, <span class="string">"must be"</span>);</span><br><span class="line">  obj = common_mem_allocate_init(real_klass, size, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  初始化并且互相设置引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">post_allocation_setup_common(klass, obj);</span><br><span class="line">assert(Universe::is_bootstrapping() ||</span><br><span class="line">       !((oop)obj)-&gt;blueprint()-&gt;oop_is_array(), <span class="string">"must not be an array"</span>);</span><br><span class="line">NOT_PRODUCT(Universe::heap()-&gt;check_for_bad_heap_word_value(obj, size));</span><br><span class="line">oop mirror = (oop)obj;</span><br><span class="line"></span><br><span class="line">java_lang_Class::set_oop_size(mirror, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup indirections</span></span><br><span class="line"><span class="keyword">if</span> (!real_klass.is_null()) &#123;</span><br><span class="line">  java_lang_Class::set_klass(mirror, real_klass());</span><br><span class="line">  real_klass-&gt;set_java_mirror(mirror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static oop obj_allocate(KlassHandle klass, int size, TRAPS)<br>分配对象内存，并初始化.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);</span><br><span class="line">post_allocation_setup_obj(klass, obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static oop array_allocate(KlassHandle klass, int size, int length, TRAPS)<br>分配数组内存，并初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_init(klass, size, CHECK_NULL);</span><br><span class="line">post_allocation_setup_array(klass, obj, length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inline static oop array_allocate_nozero(KlassHandle klass, int size, int length, TRAPS)<br>分配数组内存，不初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* obj = common_mem_allocate_noinit(klass, size, CHECK_NULL);</span><br><span class="line">((oop)obj)-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">post_allocation_setup_array(klass, obj, length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>virtual HeapWord<em> mem_allocate(size_t size, bool</em> gc_overhead_limit_was_exceeded) = 0;<br>真实的分配内存，纯虚函数，由子类实现。</p>
</li>
<li><p>virtual HeapWord* permanent_mem_allocate(size_t size) = 0;<br>真实的分配Perm内存，纯虚函数，由子类实现。</p>
</li>
<li><p>virtual bool supports_inline_contig_alloc() const<br>必须满足，在堆中必须有一块儿连续的空间，可用范围由top_addr()，end_addr()决定的，并且可以靠移动top_addr来分配内存。由子类实现。</p>
</li>
<li><p>virtual HeapWord** top_addr() const<br>见supports_inline_contig_alloc</p>
</li>
<li><p>virtual HeapWord** end_addr() const<br>见supports_inline_contig_alloc</p>
</li>
<li><p>virtual void ensure_parsability(bool retire_tlabs)<br>在解析heap之前调用，在这个类里负责调用tlab的相关方法，剩下的由子类实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (JavaThread *thread = Threads::first(); thread; thread = thread-&gt;next()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">use_t</span>lab) thread-&gt;tlab().make_parsable(<span class="keyword">retire_t</span><span class="built_in">labs</span>);</span><br><span class="line"><span class="preprocessor">#ifdef COMPILER2</span></span><br><span class="line">     <span class="comment">// The deferred store barriers must all have been flushed to the</span></span><br><span class="line">     <span class="comment">// card-table (or other remembered set structure) before GC starts</span></span><br><span class="line">     <span class="comment">// processing the card-table (or other remembered set).</span></span><br><span class="line">     <span class="keyword">if</span> (deferred) flush_deferred_store_barrier(thread);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">     assert(!deferred, <span class="string">"Should be false"</span>);</span><br><span class="line">     assert(thread-&gt;deferred_card_mark().is_empty(), <span class="string">"Should be empty"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>virtual size_t unsafe_max_alloc() = 0;<br>返回在不触发垃圾收集和扩展的情况下，最大能分配的内存。</p>
</li>
<li><p>virtual bool supports_tlab_allocation()<br>是否支持TLAB.</p>
</li>
<li><p>virtual size_t tlab_capacity(Thread *thr)<br>TLAB可以使用的内存大小。</p>
</li>
<li><p>virtual size_t unsafe_max_tlab_alloc(Thread *thr) const<br>返回在不触发垃圾收集和扩展的情况下，最大能在TLAB分配的内存。</p>
</li>
<li><p>virtual void collect(GCCause::Cause cause) = 0<br>提供了垃圾收集的对外接口，供“System.gc”等调用。</p>
</li>
</ul>
<h2 id="CollectorPolicy">CollectorPolicy</h2><p>CollectorPolicy及其子类用来定义垃圾收集的属性。</p>
<p><strong>属性</strong><br>PermanentGenerationSpec *_permanent_generation</p>
<blockquote>
<p>PermanentGenerationSpec<br>size_t           _init_size<br>由PermSize参数决定，缺省为ScaleForWordSize(16<em>M)。<br>size_t           _max_size<br>由MaxPermSize参数决定，缺省为ScaleForWordSize(64</em>M)<br>size_t           _read_only_size<br>由SharedReadOnlySize参数决定，缺省为10M<br>size_t           _read_write_size<br>由SharedReadWriteSize参数确定，缺省13M<br>size_t           _misc_data_size<br>由SharedReadWriteSize参数确定，缺省5M<br>size_t           _misc_code_size<br>由SharedMiscCodeSize参数确定，缺省4M<br>bool             _enable_shared_spaces<br>在client模式下，如果是serial模式的垃圾收集。为了提高启动速度，和减少占用空间。如果jre是通过installer安装的，那么在安装的时候，installer会把一些核心的类，以一种内部格式的形式，dump到client/classes.jsa中，以后启动&gt;时，直接加载这个文件即可。如果不是用installer安装的，可以使用java -Xshare:dump生成，或者运行share模式时，自动生成。我们关注的是server模式，所以不多讨论。</p>
</blockquote>
<p>size_t _max_heap_byte_size<br>如果设置了-Xmx，则为设置值。<br>如果没有设置-Xmx，通过下列几步得到：</p>
<ol>
<li>MaxHeapSize最初的缺省值为：<code>ScaleForWordSize(96*M)</code><br>如果主机内存太小，小于<code>MaxHeapSize * MinRAMFraction(缺省为2）</code>，即大概为250m左右。 MaxHeapSize设置为<code>内存大小/MinRAMFraction</code>,即内存的一半。<br>如果不是内存太小的情况，设置为<code>phys_mem / MaxRAMFraction(缺省为4)</code>和 缺省的MaxHeapSize两者之中较大的。即为内存的四分之一，最小<code>ScaleForWordSize(96*M)</code>。</li>
<li>如果使用UseCompressedOops，还需要考虑不能超过compressedOops能表示的地址范围，这个值大约30多G，所以一般没什么影响。</li>
<li>如果按上述规则得到的值，小于设置的-Xms值，设置为-Xms的大小。</li>
</ol>
<p>size_t _initial_heap_byte_size<br>如果设置了-Xms，则为此值。<br>如果没有设置-Xms，则：设置为<code>内存大小/InitialRAMFraction(缺省为64)</code>，但是这个值不能小于<code>OldSize（缺省大小ScaleForWordSize(4*M)) + NewSize（缺省大小ScaleForWordSize(1*M))</code>,同时也不能大于前面计算的MaxHeapSize。</p>
<p>size_t _min_heap_byte_size<br><code>OldSize（缺省大小ScaleForWordSize(4*M)) + NewSize（缺省大小ScaleForWordSize(1*M))</code></p>
<p><strong>方法</strong><br>virtual GenRemSet* create_rem_set(MemRegion reserved, int max_covered_regions)<br>建立Remember Set。目前没有子类重新实现这个方法，都使用CollectorPolicy中的这个方法。<br>目前只处理CardTable实现方式，用于跨代指针处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CardTableRS* res = <span class="keyword">new</span> CardTableRS(whole_heap, max_covered_regions);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<p>virtual HeapWord<em> mem_allocate_work(size_t size,  bool is_tlab, bool</em> gc_overhead_limit_was_exceeded)<br>由子类实现，在描述各种收集方法时再描述。请关注<a href="http://jangzq.info/">Jangzq技术研究</a></p>
<p>virtual HeapWord *satisfy_failed_allocation(size_t size, bool is_tlab)<br>由子类实现，在描述各种收集方法时再描述，请关注<a href="http://jangzq.info/">Jangzq技术研究</a></p>
<h2 id="GC参数">GC参数</h2><p>gc参数对应的CollectorPolicy和CollectedHeap如下：</p>
<table>
<thead>
<tr>
<th>GC参数</th>
<th>CollectorPolicy</th>
<th>CollectedHeap</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>MarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>MarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC -XX:+UseAdaptiveSizePolicy</td>
<td>ASConcurrentMarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>ConcurrentMarkSweepPolicy</td>
<td>GenCollectedHeap</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1CollectorPolicy</td>
<td>G1CollectedHeap</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p><em>注：未特殊说明，都指的是JDK7.0</em></p>
<p>hotspot的垃圾收集框架有两个主要的组成部分，其一是CollectedHeap、其一是CollectorPolicy。根据不同的启动参数，hotspot选择相应的Heap和Policy。<br>首先我们看一下类图，看一下有多少种CollectedHeap和CollectorPolicy。</p>
<p><img src="/images/heap_policy.png" alt="类图"></p>
<p>下面列出的是CollectorPolicy和CollectedHeap的关键属性和方法，我们以此来看一下Policy和Heap各自的特性。</p>
<h2 id="CollectedHeap">CollectedHeap</h2><p>CollectedHeap是java堆在hotspot中的体现，根据垃圾收集算法的不同，具有不同类型的子类，CollectedHeap的主要功能是分配内存，在这个父类里实现的主要是分配的流程，包括TLAB、其它分配等。但是不负责真正的内存分配，因为内存是由其子类管理，所以只定义这些分配的抽象方法。</p>
<p><strong>属性</strong><br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[classpath中没用到的jar的影响]]></title>
    <link href="http://jangzq.info/2015/07/02/classpath_jar/"/>
    <id>http://jangzq.info/2015/07/02/classpath_jar/</id>
    <published>2015-07-02T13:19:16.000Z</published>
    <updated>2015-07-02T13:28:07.000Z</updated>
    <content type="html"><![CDATA[<p>有时，我们的classpath中包含很多并没有用到的jar，这些jar有什么影响，影响大不大，下面分析一下。<br>通过阅读源码，发现在打开jar文件的时候，调用了下面这个方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jzfile *  ZIP_Put_In_Cache0(<span class="keyword">const</span> <span class="keyword">char</span> *name, ZFILE zfd, <span class="keyword">char</span> **pmsg, jlong lastModified, jboolean usemmap)</span><br></pre></td></tr></table></figure></p>
<p>在这个方法里，调用<code>static jlong readCEN(jzfile *zip, jint knownTotal)</code>方法“读取”了zip的central directory部分，里面关键的一句为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mappedAddr = mmap64(<span class="number">0</span>, zip-&gt;mlen, PROT_READ, MAP_SHARED, zip-&gt;zfd, (<span class="keyword">off64_t</span>) offset)</span><br></pre></td></tr></table></figure></p>
<p>即：将zip的 central directory部分进行了文件映射。上文中“读取”两字，我加了引号，就是因为并不是真正的读取了这块儿内容，而是采用文件映射的方式，将文件的这部分内容映射进了内存空间。这个方法里有一处值得我们注意，即是用了MAP_SHARED参数，即这一块儿空间是和其他进程共享的。<br>在JDK6之前，map了这个jar文件，这样占用了大量的地址空间（并没有占用内存），所以改为只映射 central directory，因为 central directory中包含检索包含文件的全部信息。<br>通过pmap，我们可以看到内存映射：</p>
<blockquote>
<p>00007f7bb818a000  63960K ——-   [ anon ]<br>00007f7bbc00a000      8K r—s- axis-ant-1.2.1.jar<br>00007f7bbc00c000      8K r—s- asm-attrs.jar<br>00007f7bbc00e000     20K r—s- antlr-2.7.6rc1.jar<br>00007f7bbc013000     28K r—s- ant-1.4.1.jar<br>00007f7bbc01a000     52K r—s- acegi-security-1.0.7.jar<br>00007f7bbc027000     44K r—s- charsets.jar<br>00007f7bbc032000   5968K rw—-   [ anon ]<br>00007f7bbc606000   1788K r—s- rt.jar<br>00007f7bbc7c5000   5264K rw—-   [ anon ]</p>
</blockquote>
<p>通过上述分析，我们可以得到如下结论：</p>
<ul>
<li>classpath包含的jar，会把 central directory映射到内存中去，在load class时会进行访问，所以会占用内存。如果jar文件较多，而且比较大，也会占用不少空间。</li>
<li>对于一台主机上的不同java进程，引用相同的jar，最好使用同一个文件，这样会共享同一块内存，减少内存占用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时，我们的classpath中包含很多并没有用到的jar，这些jar有什么影响，影响大不大，下面分析一下。<br>通过阅读源码，发现在打开jar文件的时候，调用了下面这个方法。<br><figure class="highlight c"><table><tr><td c]]>
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HotSpot的TLAB实现解析]]></title>
    <link href="http://jangzq.info/2015/06/28/tlab/"/>
    <id>http://jangzq.info/2015/06/28/tlab/</id>
    <published>2015-06-28T09:12:50.000Z</published>
    <updated>2015-06-28T09:12:59.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文解析了TLAB的实现机制，最后讨论了如何利用TLAB机制，进行高效程序设计，如果你对原理不感兴趣，也请看下<strong>启示</strong>部分。</p>
<p>内存分配是虚拟机最常见的操作之一，所以处理效率高低对整体性能有很大的影响。同时，虚拟机是一个多线程的运行环境，内存分配也不可避免的受到并发的制约，而锁又是造成性能下降的主因之一，即使使用CAS，对于如此频繁的操作也是巨大的性能负担。<br>一个自然而然的想法是将内存分为几个部分，每个线程只使用自己的内存区域，这样内存分配就不用进行同步，当然能达到较高的效率，TLAB就是这种想法的产物。每一个线程都有自己的一片内存区域，这片区域就叫<strong>TLAB(Thread Local alloc Buffer)</strong>，虚拟机的任务就是合理的分配TLAB的大小，使内存分配都尽量在TLAB中完成，以达到更高的效率。</p>
<h2 id="TLAB机制解析">TLAB机制解析</h2><p>hotspot用Thread类（Thread.cpp，不是java类）来描述一个线程，在Thread类里有一个<code>ThreadLocalAllocBuffer _tlab</code>变量，表征这个线程的tlab。在ThreadLocalAllocBuffer 类里，有三个属性描述了tlab的范围及使用情况，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* _start;      <span class="comment">//当前tlab的起始地址</span></span><br><span class="line">HeapWord* <span class="keyword">_t</span>op;        <span class="comment">//最后一次在tlab上分配内存后的指针位置。</span></span><br><span class="line">HeapWord* _end;       <span class="comment">//tlab的结束地址。</span></span><br></pre></td></tr></table></figure></p>
<p>采用这样的方法，首先要考虑，给每个线程的TLAB分配多大空间。分配大了，别的线程又无法使用，造成了浪费；分配小了，剩余的空间不够分配的时候，还需要采用别的方式分配。每个线程需要分配的内存是不同的，有的线程需要分配的内存多，有的现场分配的内存少，给所有线程分配同样大小的TLAB空间显然是不适合的。另外，一个线程不同的时间可能有不同的内存要求，这段时间使用内存多，过一会儿又少了，所以给一个线程固定的TLAB空间显然也是不适合的。也就是，需要解决下面两个问题：1）一个线程的TLAB初始时分配多大。2）什么时候进行动态调整，调整成多大。本文将围绕这两个问题，深入hotspot源码，探究答案。</p>
<h3 id="初始分配">初始分配</h3><a id="more"></a>
<p>当一个线程刚刚创建的时候，虚拟机这个线程的行为习惯一无所知，所以需要给它分配一个初始值。最简单的情况是，在启动虚拟机的时候通过<code>TLABSize</code>参数进行指定，需要注意的是，这个参数指定的值，也就是这时候使用一次，以后的TLAB大小和这个值就无关了（见<code>ThreadLocalAllocBuffer::initial_desired_size</code>方法）。如果没有指定这个值，虚拟机就需要自行决定给这个现场分配TLAB的大小了，显而易见，一个线程TLAB应该分配多少，和三个参数有关，一个是<strong>线程总数</strong>，线程越多，每个线程能分配的就越少；另一个参数就是<strong>可供分配的总空间</strong>；不可能把所有的可分配的空间都分配给线程做TLAB，如果这样分配，当一个线程的TLAB不够分配的时候，又没有别的适合分配的空间，势必造成gc，导致别的线程没有使用的TLAB造成了浪费，所以最后一个参数是<strong>每次分配的比例</strong>，这个比例越大，当gc时候，没使用的造成的浪费就越大。这里有一个例外情况，当这个线程是主线程的时候，这个时候heap还没有创建，所以hotspot给它分配了一个缺省值2K，这个值可以由启动参数<code>MinTLABSize</code>指定（见<code>ThreadLocalAllocBuffer::initial_desired_size</code>方法）。<br>当线程不是主线程的时候，就需要结合上面提到的三个参数，确定合适的值。首要问题是这两个值怎么得到，下面首先讨论线程数。由于TLAB分配后要使用一段时间，所以使用当时的线程数是没有意义的，所以在hotspot中，使用的线程数是一种自适应的加权平均的线程数（<code>GlobalTLABStats</code>的<code>_allocating_threads_avg</code>变量，类型是<code>AdaptiveWeightedAverage</code>）。hotspot在每次gc前，统计当前线程中从上次gc以来，曾经使用过TLAB的线程数，用这个线程数和过去得到的历史值进行一个加权平均，即<code>(100.0 - weight) * 历史平均值 / 100.0 + weight * 当前采样值 / 100.0</code>。公式中的weight由<code>TLABAllocationWeight</code>参数决定，如果不设置的话，缺省是35。（线程数的计算过程，见程序<code>ThreadLocalAllocBuffer::accumulate_statistics_before_gc</code>）。<br>第二个参数：可供分配的总空间，在hotspot中，调用<code>CollectedHeap</code>的<code>tlab_capacity</code>函数得到可供tlab分配的总空间，这个函数是一个虚函数，依赖于具体的实现。在采用分代的gc方法时，这个值是整个eden的大小（见<code>DefNewGeneration::tlab_capacity</code>）。<br>最后一个参数：一次分配的比例。在hotspot中通过eden可以浪费的百分比（Percentage of Eden that can be wasted）来指定，虚拟机参数为：<code>TLABWasteTargetPercent</code>。这个值缺省为1，即在gc的时候，已经分配给TLAB，还没有使用的内存，不应该超过eden的1%，所以一次分配eden的2%，当gc的时候，从概率上说，有一半的还没有用，所以浪费了1%，也就是说，一次分配的比例，应该是<code>TLABWasteTargetPercent*2</code>，在hotspot中，将<code>100/(TLABWasteTargetPercent*2）</code>称为<code>_target_refills</code>，即希望在<code>_target_refills</code>次分配后，分配完所有的空间，这个值仅是”期望“，并没有任何的硬性限制。<br>确定了三个参数后，一个线程最初分配的tlab的大小即：<code>可供分配的总空间/(线程数*_target_refills)</code>，在hotspot中，这个值叫做<code>desired_size</code>。（见<code>ThreadLocalAllocBuffer::initial_desired_size</code>方法）</p>
<h3 id="动态调整">动态调整</h3><p>解决了线程TLAB初始分配的问题后，我看看看hotspot如何使用tlab，我们看的代码在：<code>CollectedHeap::common_mem_allocate_noinit</code>。其实，当hotspot用new指令生成对象的时候，通常情况下不会执行到这个方法，hotspot会使用快速分配，首先使用tlab，从当前的线程的tlab的<code>top</code>指针开始分配指定大小的内存，直接修改<code>top</code>指针即可，如果分配的内存大于当前tlab还剩下来的空间，则需要在eden上非tlab的空间进行分配，当然这个过程就需要使用CAS来保证（这个不是本文的研究内容，所以略过），当使用慢速分配或者分配数组的空间时，就会执行<code>CollectedHeap::common_mem_allocate_noinit</code>这个方法。在这个方法里，调用了<code>allocate_from_tlab</code>，顾名思义，即在Tlab上进行分配，只不过这个方法在TLAB空间不够的情况下，会分配新的TLAB空间。由于在Eden中，内存的分配是连续的，所以不能扩大一个已有的TLAB的大小，只有新建一个，这样还没有使用的内存就浪费了，所以并不是每次TLAB不够分配的时候，都会分配新的TLAB，在hotspot中，会查看TLAB剩余的大小，是否小于一个阈值，如果大于这个阈值，那么就不会新分配一个TLAB，而是不在TLAB分配内存，否则就新建一个TLAB。这个阈值由两个JDK参数控制: <code>TLABRefillWasteFraction</code>和<code>TLABWasteIncrement</code>，最初，等于<code>desired_size/TLABRefillWasteFraction</code>，<code>TLABRefillWasteFraction</code>缺省为64，当每一次不成功的分配，这个阈值增长<code>TLABWasteIncrement</code>，单位是<code>HeapWordSize</code>。在丢弃原来的TLAB时，调用<code>make_parsable</code>将剩余的空间填上对象，这个是便于gc时使用。</p>
<p>在TLAB的设计中，处处体现了动态调整的思想。给每个线程分配的TLAB空间并不是一成不变的，这个调整的时机就是GC的时候。当GC后，hotspot会调整所有TLAB的大小，调整的依据当然是每个线程过去对于TLAB的使用情况，同上文中的“线程数”的计算思路一致，也是采用加权平均的方法。<code>ThreadLocalAllocBuffer</code>类的<code>_allocation_fraction</code>变量即代表了这个加权平均值，采样的是：线程的TLAB占所有已经使用的内存的比例（<code>ThreadLocalAllocBuffer::accumulate_statistics</code>）。具体实现细节就不需赘述了，请自行参考源代码(<code>ThreadLocalAllocBuffer::resize</code>)。</p>
<h3 id="结论">结论</h3><p>可以看出，hotspot的TLAB实现中的各种手段，都是为了达到“尽量少的浪费空间”和“尽可能多在TLAB中分配”的平衡，如果一个线程的TLAB分配的空间过大，造成别的线程分配内存不够用，引起gc，造成了空间的浪费；如果分配的过小，造成在TLAB中无法分配，只能在share eden中分配，造成使用CAS等同步操作。所以hotspot采用一种自适应的方式，根据一个线程的过往行为，动态的调整其TLAB大小，力争达到最优的结果。</p>
<h2 id="启示">启示</h2><p>首先，不讨论线程创建的开销，即使从TLAB的角度来看，频繁的生成短生命周期的线程是不可取的，因为hotspot费劲力气设计的“动态调整TLAB”算法，在这种情况下根本用不上，回回只能用初始的值，不能保证内存分配的效果。所以我们一定要使用接近固定的线程池。 其次，尽量的保证每个线程里的行为特征比较固定，让程序的行为能被jvm所侦知，否则基于统计的大小预测效果不会太好，造成大量的TLAB浪费，更加频繁的gc。最后，说句题外话，这应该是一切程序开发的准则，按照“底层依赖系统”期望你的行为去执行，才能达到最高效率，软硬都是如此，比如cpu的cache、比如cpu的指令预取，linux文件预读…….。如果辜负了“底层依赖系统”的期望，轻则效率低，重则踩坑，焉能不慎乎？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文解析了TLAB的实现机制，最后讨论了如何利用TLAB机制，进行高效程序设计，如果你对原理不感兴趣，也请看下<strong>启示</strong>部分。</p>
<p>内存分配是虚拟机最常见的操作之一，所以处理效率高低对整体性能有很大的影响。同时，虚拟机是一个多线程的运行环境，内存分配也不可避免的受到并发的制约，而锁又是造成性能下降的主因之一，即使使用CAS，对于如此频繁的操作也是巨大的性能负担。<br>一个自然而然的想法是将内存分为几个部分，每个线程只使用自己的内存区域，这样内存分配就不用进行同步，当然能达到较高的效率，TLAB就是这种想法的产物。每一个线程都有自己的一片内存区域，这片区域就叫<strong>TLAB(Thread Local alloc Buffer)</strong>，虚拟机的任务就是合理的分配TLAB的大小，使内存分配都尽量在TLAB中完成，以达到更高的效率。</p>
<h2 id="TLAB机制解析">TLAB机制解析</h2><p>hotspot用Thread类（Thread.cpp，不是java类）来描述一个线程，在Thread类里有一个<code>ThreadLocalAllocBuffer _tlab</code>变量，表征这个线程的tlab。在ThreadLocalAllocBuffer 类里，有三个属性描述了tlab的范围及使用情况，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeapWord* _start;      <span class="comment">//当前tlab的起始地址</span></span><br><span class="line">HeapWord* <span class="keyword">_t</span>op;        <span class="comment">//最后一次在tlab上分配内存后的指针位置。</span></span><br><span class="line">HeapWord* _end;       <span class="comment">//tlab的结束地址。</span></span><br></pre></td></tr></table></figure></p>
<p>采用这样的方法，首先要考虑，给每个线程的TLAB分配多大空间。分配大了，别的线程又无法使用，造成了浪费；分配小了，剩余的空间不够分配的时候，还需要采用别的方式分配。每个线程需要分配的内存是不同的，有的线程需要分配的内存多，有的现场分配的内存少，给所有线程分配同样大小的TLAB空间显然是不适合的。另外，一个线程不同的时间可能有不同的内存要求，这段时间使用内存多，过一会儿又少了，所以给一个线程固定的TLAB空间显然也是不适合的。也就是，需要解决下面两个问题：1）一个线程的TLAB初始时分配多大。2）什么时候进行动态调整，调整成多大。本文将围绕这两个问题，深入hotspot源码，探究答案。</p>
<h3 id="初始分配">初始分配</h3>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://jangzq.info/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[overcommit_memory深入解析]]></title>
    <link href="http://jangzq.info/2015/06/27/overcommit_memory/"/>
    <id>http://jangzq.info/2015/06/27/overcommit_memory/</id>
    <published>2015-06-27T15:32:52.000Z</published>
    <updated>2015-06-28T09:14:03.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文从内核角度分析了内核参数<code>overcommit_memory</code>的影响，并给出了如何应用此参数的建议意见。</p>
<h2 id="实例">实例</h2><p>首先，从一个实例开始：<br><strong>操作系统： </strong></p>
<blockquote>
<p>linux 2.6.38</p>
</blockquote>
<p><strong>JDK版本：</strong></p>
<blockquote>
<p>java version “1.6.0_30”<br>Java(TM) SE Runtime Environment (build 1.6.0_30-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 20.5-b03, mixed mode)</p>
</blockquote>
<p>现象：启动java进程的时候，报如下的错误后退出</p>
<blockquote>
<p>Error occurred during initialization of VM<br>Could not reserve enough space for object heap<br>Could not create the Java virtual machine.</p>
</blockquote>
<p>疑惑：粗略的考虑一下，linux是使用虚拟内存的，而且linux分配给进程内存时候，只是分配一个地址空间，并不是马上分配内存，那么是什么限制导致了java虚拟机在初始化的时候即退出呢?</p>
<h2 id="解析">解析</h2><p>首先，我们看一下java虚拟机是用什么系统调用来请求内存？<br>java虚拟机使用-Xms 和-Xmx指出java的堆的初始大小和最大大小，在java进程启动的时候，java虚拟机按照初始大小请求内存，但是虚拟机是用什么来请求内存呢？我们使用strace来看一下（我们使用 -Xms1G -Xmx1G的参数启动）：<br>得到如下输出<br><a id="more"></a><br>[pid 15854] mmap(NULL, 1159725056, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0) = -1 ENOMEM (Cannot allocate memory)<br>从以上打印我们可以看出，java虚拟机是通过mmap系统调用来请求内存的，在这里返回了-1，即ENOMEM</p>
<p>然后，我们看一下mmap的源代码，发现了在mm/mmap.c中的__vm_enough_memory方法中，判断了是否有足够内存，下面我们深入分析一下。<br>在这个函数中我们发现了导致此问题的内核参数:overcommit_memory，此参数在/proc下的文件为：/proc/sys/vm/overcommit_memory 。这个参数的解释如下：</p>
<blockquote>
<p>This file contains the kernel virtual memory accounting mode. Values are:<br>              0: heuristic overcommit (this is the default)<br>              1: always overcommit, never check<br>              2: always check, never overcommit</p>
</blockquote>
<p>检查一下这台机子上的配置，</p>
<blockquote>
<p>cat /proc/sys/vm/overcommit_memory<br>2 </p>
</blockquote>
<p>果然被设置成了2。<br>改成0后，再执行，确实就不在报错退出了。<br>我们下一步通过源码进一步分析一下各个参数值的含义。<br>当参数为1时，这时不检查，直接返回0（内存足够）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>当参数时0时，这时候先拿要请求页数和这个计算值比较：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(global_page_state(NR_FILE_PAGES)+ nr_swap_pages+global_page_state(NR_SLAB_RECLAIMABLE))*<span class="number">31</span>/<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p>即：文件缓存所占的页数+空闲的swap page数量+可以回收的SLAB的空间，然后再留下3%供root使用。<br>如果请求页数小于这个计算值，则返回0，否则把上面的计算值再加上一个值，再比较，这个值是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（global_page_state(NR_FREE_PAGES) -totalreserve_pages）*<span class="number">31</span>/<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<p>空闲的内存（页数）-需要保留的内存（必须保留备用的内存），再留下3%供root使用的。<br>通过上面的公式可以看出，在这个参数的情况下，操作系统就是看一下还可用的页（包括swap中和内存中的）是否能满足这次请求的内存，而不管别的进程是否已经请求了很大的内存。这实际是存在风险的，因为虚拟内存已经申请，只是暂时没用，等大家一起使用内存的时候，内存有可能不够用，就会造成OOM-killed进程来终止进程了。<br>为什么需要分以上两步，这是因为历史原因，在以前的版本，nr_free_pages()开销比较大，所以先比较第一步，如果第一步不能满足才比较第二步，2.6.38的代码中，这个函数也是直接取计数器的值了，所以开销应该不大了。</p>
<p>当参数时2时，这时操作系统是拿所有进程请求的(commit)的内存，和一个阈值比较，这个阈值为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（(totalram_pages - <span class="keyword">hugetlb_t</span>otal_pages()) * sysctl_overcommit_ratio / <span class="number">100</span>）*<span class="number">31</span>/<span class="number">32</span>+total_swap_pages</span><br></pre></td></tr></table></figure></p>
<p>含义是：(所有的内存-大页面所占的内存)然后，乘上<code>sysctl_overcommit_ratio</code>设定的百分比，保留给root用的之后，加上swap的大小。<br>即：所有进程的虚拟内存申请量不能大于 所有内存（除去大页面内存）*<code>sysctl_overcommit_ratio</code>，在加上swap的大小。<code>sysctl_overcommit_ratio</code>这个名称现在似乎名不符实，是不是？</p>
<h2 id="结论">结论</h2><p>这两个内核参数应当谨慎设置，以免引起不必要的麻烦。<br>1）在生产环境里，<code>overcommit_memory</code>尽量不要设置为1，这是因为这会大大增加OOM-killed的几率，增加了整个系统的不稳定性。<br>2）如果运行的应用程序的内存可以预测，如数据库，我们可以使用2，因为数据库启动后，将关键的所需内存全部申请了虚拟内存，所以可以防止在数据库主机上运行某些不重要的程序时，造成oom，导致数据库被kill，限制其它程序申请虚拟内存，还可以减少内存导入导出的可能性。<br>3）如果实在不能确定所需内存（我们尽量避免这种情况），就用0吧，但一定要考虑到oom的风险。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文为原创文章，欢迎转载，请注明： 转载自<a href="http://jangzq.info/">Jangzq技术研究</a></strong></p>
<p>本文从内核角度分析了内核参数<code>overcommit_memory</code>的影响，并给出了如何应用此参数的建议意见。</p>
<h2 id="实例">实例</h2><p>首先，从一个实例开始：<br><strong>操作系统： </strong></p>
<blockquote>
<p>linux 2.6.38</p>
</blockquote>
<p><strong>JDK版本：</strong></p>
<blockquote>
<p>java version “1.6.0_30”<br>Java(TM) SE Runtime Environment (build 1.6.0_30-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 20.5-b03, mixed mode)</p>
</blockquote>
<p>现象：启动java进程的时候，报如下的错误后退出</p>
<blockquote>
<p>Error occurred during initialization of VM<br>Could not reserve enough space for object heap<br>Could not create the Java virtual machine.</p>
</blockquote>
<p>疑惑：粗略的考虑一下，linux是使用虚拟内存的，而且linux分配给进程内存时候，只是分配一个地址空间，并不是马上分配内存，那么是什么限制导致了java虚拟机在初始化的时候即退出呢?</p>
<h2 id="解析">解析</h2><p>首先，我们看一下java虚拟机是用什么系统调用来请求内存？<br>java虚拟机使用-Xms 和-Xmx指出java的堆的初始大小和最大大小，在java进程启动的时候，java虚拟机按照初始大小请求内存，但是虚拟机是用什么来请求内存呢？我们使用strace来看一下（我们使用 -Xms1G -Xmx1G的参数启动）：<br>得到如下输出<br>]]>
    
    </summary>
    
      <category term="linux内核" scheme="http://jangzq.info/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
</feed>